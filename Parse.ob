MODULE Parse;

IMPORT AST, Lex, Out;

TYPE
  StringId = Lex.PoolIndex;

VAR
  l :Lex.Lexer;
  ParseExpression :PROCEDURE;
  ParseStatementSequence :PROCEDURE;
  ParseType :PROCEDURE () :AST.Type;
  ParseDeclarationSequence :PROCEDURE;

PROCEDURE IsToken(kind :Lex.TokenKind) :BOOLEAN;
BEGIN
  RETURN l.t.kind = kind
END IsToken;

PROCEDURE MatchToken(kind :Lex.TokenKind) :BOOLEAN;
VAR
  found :BOOLEAN;
BEGIN
  IF IsToken(kind) THEN
    Lex.NextToken(l);
    found := TRUE;
  ELSE
    found := FALSE;
  END;
  RETURN found
END MatchToken;

PROCEDURE ExpectToken(kind :Lex.TokenKind);
BEGIN
  IF IsToken(kind) THEN
    Lex.NextToken(l);
  ELSE
    Lex.Error(l, "Expected ");
    Out.Str(Lex.TokenNames[kind]);
    Out.Str(", got ");
    Out.PrintLn(Lex.TokenNames[l.t.kind]);
  END;
END ExpectToken;

PROCEDURE ExpectIdentifier() :StringId;
VAR
  s :StringId;
BEGIN
  s := l.t.sVal;
  ExpectToken(Lex.tIDENT);
  RETURN s
END ExpectIdentifier;

PROCEDURE IsImportedModule(ident :StringId) :BOOLEAN;
BEGIN
  RETURN Lex.ImportHack(l, ident)
END IsImportedModule;

PROCEDURE ParseQualident() :AST.Decl;
VAR
  (*moduleName,*) ident :StringId;
  d :AST.Decl;
BEGIN
  ident := ExpectIdentifier();
  IF IsImportedModule(ident) THEN
    (*moduleName := ident; *)
    ExpectToken(Lex.tDOT);
    ident := ExpectIdentifier();
    (* lookup moduleName.ident *)
  ELSE
    d := AST.LookupDecl(l, ident);
    (* lookup ident *)
  END;
  RETURN d
END ParseQualident;

PROCEDURE ParseQualidentAndGetType() :AST.Type;
VAR
  d :AST.Decl;
  t :AST.Type;
BEGIN
  t := NIL;
  d := ParseQualident();
  IF d # NIL THEN
    t := d.typ;
    IF d.kind # AST.declType THEN
      Lex.Error(l, "");
      Lex.OutStr(l, d.name);
      Out.PrintLn(" is not a TYPE");
    END;
  END;
  RETURN t
END ParseQualidentAndGetType;

PROCEDURE ParseSetElement;
BEGIN
  ParseExpression;
  IF MatchToken(Lex.tDOTDOT) THEN
    ParseExpression;
  END;
END ParseSetElement;

PROCEDURE ParseSet;
BEGIN
  ExpectToken(Lex.tLBRACE);
  IF IsToken(Lex.tRBRACE) THEN
    (* empty set *)
  ELSE
    ParseSetElement;
    WHILE MatchToken(Lex.tCOMMA) DO
      ParseSetElement;
    END;
  END;
  ExpectToken(Lex.tRBRACE);
END ParseSet;

PROCEDURE IsTypeGuard() :BOOLEAN;
BEGIN
  RETURN FALSE
END IsTypeGuard;

PROCEDURE ParseDesignator;
BEGIN
  ParseQualident;
  WHILE IsToken(Lex.tDOT) OR IsToken(Lex.tLBRACK) OR IsToken(Lex.tCARET) OR
        (IsTypeGuard() & IsToken(Lex.tLPAREN)) DO
    IF MatchToken(Lex.tDOT) THEN
      (* identref - lookup decl *)
      ExpectIdentifier;
    ELSIF MatchToken(Lex.tLBRACK) THEN
      (* arrayref *)
      ParseExpression;
      WHILE MatchToken(Lex.tCOMMA) DO
        ParseExpression;
      END;
      ExpectToken(Lex.tRBRACK);
    ELSIF MatchToken(Lex.tCARET) THEN
      (* pointerderef *)
    ELSIF IsTypeGuard() & MatchToken(Lex.tLPAREN) THEN
      (* typeguard *)
      ParseQualident;
    ELSE
      ASSERT(FALSE);
    END
  END;
END ParseDesignator;

PROCEDURE ParseActualParameters;
BEGIN
  ExpectToken(Lex.tLPAREN);
  IF ~IsToken(Lex.tRPAREN) THEN
    ParseExpression;
    WHILE MatchToken(Lex.tCOMMA) DO
      ParseExpression;
    END;
  END;
  ExpectToken(Lex.tRPAREN);
END ParseActualParameters;

PROCEDURE ParseFactor;
BEGIN
  IF IsToken(Lex.tINT) THEN
    MatchToken(Lex.tINT);
  ELSIF IsToken(Lex.tREAL) THEN
    MatchToken(Lex.tREAL);
  ELSIF IsToken(Lex.tSTRING) THEN
    MatchToken(Lex.tSTRING);
  ELSIF MatchToken(Lex.tNIL) THEN
    (* nil *)
  ELSIF MatchToken(Lex.tTRUE) THEN
    (* true *)
  ELSIF MatchToken(Lex.tFALSE) THEN
    (* false *)
  ELSIF MatchToken(Lex.tFALSE) THEN
    (* false *)
  ELSIF IsToken(Lex.tLBRACE) THEN
    ParseSet;
  ELSIF IsToken(Lex.tIDENT) THEN
    ParseDesignator;
    IF IsToken(Lex.tLPAREN) THEN
      ParseActualParameters;
    END;
  ELSIF MatchToken(Lex.tLPAREN) THEN
    ParseExpression;
    ExpectToken(Lex.tRPAREN);
  ELSIF MatchToken(Lex.tTILDE) THEN
    ParseFactor;
  ELSE
    Lex.ErrorLn(l, "Factor expected");
  END;
END ParseFactor;

PROCEDURE IsMulOperator() :BOOLEAN;
BEGIN
  RETURN IsToken(Lex.tSTAR) OR IsToken(Lex.tSLASH) OR IsToken(Lex.tDIV) OR
         IsToken(Lex.tMOD) OR IsToken(Lex.tAMP) OR IsToken(Lex.tXOR)
END IsMulOperator;

PROCEDURE ParseTerm;
BEGIN
  ParseFactor;
  WHILE IsMulOperator() DO
    (* TokenKind op = token.kind; *)
    Lex.NextToken(l);
    ParseFactor;
  END;
END ParseTerm;

PROCEDURE IsAddOperator() :BOOLEAN;
BEGIN
  RETURN IsToken(Lex.tPLUS) OR IsToken(Lex.tMINUS) OR IsToken(Lex.tOR)
END IsAddOperator;

PROCEDURE ParseSimpleExpression;
BEGIN
  IF MatchToken(Lex.tPLUS) THEN
    (* unary plus *)
  ELSIF MatchToken(Lex.tMINUS) THEN
    (* unary minus *)
  END;

  ParseTerm;
  WHILE IsAddOperator() DO
    (* TokenKind op = token.kind; *)
    Lex.NextToken(l);
    ParseTerm;
  END;
END ParseSimpleExpression;

PROCEDURE IsRelation() :BOOLEAN;
BEGIN
  RETURN IsToken(Lex.tEQ) OR IsToken(Lex.tPOUND) OR IsToken(Lex.tLT) OR
         IsToken(Lex.tLTEQ) OR IsToken(Lex.tGT) OR IsToken(Lex.tGTEQ) OR
         IsToken(Lex.tIN) OR IsToken(Lex.tIS)
END IsRelation;

PROCEDURE ParseExpression0;
BEGIN
  ParseSimpleExpression;
  IF IsRelation() THEN
    (* TokenKind op = token.kind; *)
    Lex.NextToken(l);
    ParseSimpleExpression;
  END;
END ParseExpression0;

PROCEDURE ParseIfStatement;
BEGIN
  ExpectToken(Lex.tIF);
  ParseExpression;
  ExpectToken(Lex.tTHEN);
  ParseStatementSequence;
  WHILE MatchToken(Lex.tELSIF) DO
    ParseExpression;
    ExpectToken(Lex.tTHEN);
    ParseStatementSequence;
  END;
  IF MatchToken(Lex.tELSE) THEN
    ParseStatementSequence;
  END;
  ExpectToken(Lex.tEND);
END ParseIfStatement;

PROCEDURE ParseCaseLabel;
BEGIN
  IF IsToken(Lex.tINT) OR IsToken(Lex.tSTRING) OR IsToken(Lex.tIDENT) THEN
    ParseFactor;
  ELSE
    Lex.ErrorLn(l, "Case label (INTEGER, STRING, IDENT) expected");
  END;
END ParseCaseLabel;

PROCEDURE ParseCaseLabelRange;
BEGIN
  ParseCaseLabel;
  IF MatchToken(Lex.tDOTDOT) THEN
    ParseCaseLabel;
  END;
END ParseCaseLabelRange;

PROCEDURE ParseCaseLabelList;
BEGIN
  ParseCaseLabelRange;
  WHILE MatchToken(Lex.tCOMMA) DO
    ParseCaseLabelRange;
  END;
END ParseCaseLabelList;

PROCEDURE ParseCase;
BEGIN
  IF IsToken(Lex.tINT) OR IsToken(Lex.tSTRING) OR IsToken(Lex.tIDENT) THEN
    ParseCaseLabelList;
    ExpectToken(Lex.tCOLON);
    ParseStatementSequence;
  END;
END ParseCase;

PROCEDURE ParseCaseStatement;
BEGIN
  ExpectToken(Lex.tCASE);
  ParseExpression;
  ExpectToken(Lex.tOF);
  ParseCase;
  WHILE MatchToken(Lex.tVBAR) DO
    ParseCase;
  END;
  ExpectToken(Lex.tEND);
END ParseCaseStatement;

PROCEDURE ParseWhileStatement;
BEGIN
  ExpectToken(Lex.tWHILE);
  ParseExpression;
  ExpectToken(Lex.tDO);
  ParseStatementSequence;
  WHILE MatchToken(Lex.tELSIF) DO
    ParseExpression;
    ExpectToken(Lex.tDO);
    ParseStatementSequence;
  END;
  ExpectToken(Lex.tEND);
END ParseWhileStatement;

PROCEDURE ParseRepeatStatement;
BEGIN
  ExpectToken(Lex.tREPEAT);
  ParseStatementSequence;
  ExpectToken(Lex.tUNTIL);
  ParseExpression;
END ParseRepeatStatement;

PROCEDURE ParseForStatement;
BEGIN
  ExpectToken(Lex.tFOR);
  ExpectIdentifier;
  ExpectToken(Lex.tASSIGN);
  ParseExpression;
  ExpectToken(Lex.tTO);
  ParseExpression;
  IF MatchToken(Lex.tBY) THEN
    ParseExpression;
  END;
  ExpectToken(Lex.tDO);
  ParseStatementSequence;
  ExpectToken(Lex.tEND);
END ParseForStatement;

PROCEDURE ParseAssignOrProcCall;
BEGIN
  ParseDesignator;
  IF MatchToken(Lex.tASSIGN) THEN
    (* Assignment *)
    ParseExpression;
  ELSE
    (* Procedure call *)
    IF IsToken(Lex.tLPAREN) THEN
      ParseActualParameters;
    END;
  END;
END ParseAssignOrProcCall;

PROCEDURE ParseStatement;
BEGIN
  IF IsToken(Lex.tIF) THEN
    ParseIfStatement;
  ELSIF IsToken(Lex.tCASE) THEN
    ParseCaseStatement;
  ELSIF IsToken(Lex.tWHILE) THEN
    ParseWhileStatement;
  ELSIF IsToken(Lex.tREPEAT) THEN
    ParseRepeatStatement;
  ELSIF IsToken(Lex.tFOR) THEN
    ParseForStatement;
  ELSIF IsToken(Lex.tIDENT) THEN
    ParseAssignOrProcCall;
  ELSE
    (* Empty *)
  END;
END ParseStatement;

PROCEDURE ParseStatementSequence0;
BEGIN
  ParseStatement;
  WHILE MatchToken(Lex.tSEMI) DO
    ParseStatement;
  END;
END ParseStatementSequence0;

PROCEDURE ParseFieldIdentDef(VAR recordScope :AST.Decl) :AST.Decl;
VAR
  d    :AST.Decl;
  name :StringId;
BEGIN
  name := ExpectIdentifier();
  d := AST.AddDecl(l, recordScope, name);
  IF MatchToken(Lex.tSTAR) THEN
    d.exported := TRUE;
  END;
  RETURN d
END ParseFieldIdentDef;

PROCEDURE ParseIdentDef() :AST.Decl;
VAR
  d :AST.Decl;
  n :StringId;
BEGIN
  n := ExpectIdentifier();
  d := AST.AddScopeDecl(l, n);
  IF MatchToken(Lex.tSTAR) THEN
    d.exported := TRUE;
  END;
  RETURN d
END ParseIdentDef;

PROCEDURE ParseArrayType() :AST.Type;
VAR
  outer, current, last :AST.Type;
BEGIN
  ExpectToken(Lex.tARRAY);
  outer := AST.NewArrayType(NIL);
  last := outer;
  ParseExpression;
  WHILE MatchToken(Lex.tCOMMA) DO
    current := AST.NewArrayType(NIL);
    last.base := current;
    last := current;
    ParseExpression;
  END;
  ExpectToken(Lex.tOF);
  current := ParseType();
  last.base := current;
  RETURN outer
END ParseArrayType;

PROCEDURE ParseRecordType() :AST.Type;
VAR
  r, base, fieldType              :AST.Type;
  baseDecl, firstField, lastField :AST.Decl;
BEGIN
  base := NIL;
  ExpectToken(Lex.tRECORD);
  IF MatchToken(Lex.tLPAREN) THEN
    baseDecl := ParseQualident();
    ExpectToken(Lex.tRPAREN);
    IF baseDecl # NIL THEN
      base := baseDecl.typ;
    END;
  END;
  r := AST.NewRecordType(l, base);
  IF IsToken(Lex.tIDENT) THEN
    REPEAT
      firstField := ParseFieldIdentDef(r.fields);
      lastField := firstField;
      WHILE MatchToken(Lex.tCOMMA) DO
        lastField := ParseFieldIdentDef(r.fields);
      END;
      ExpectToken(Lex.tCOLON);
      fieldType := ParseType();
      WHILE (firstField # NIL) & (lastField # NIL) & (firstField # lastField.next) DO
        firstField.kind := AST.declField;
        firstField.typ := fieldType;
        firstField := firstField.next;
      END;
      MatchToken(Lex.tSEMI);
    UNTIL IsToken(Lex.tEND) OR IsToken(Lex.tEOF)
  END;
  ExpectToken(Lex.tEND);
  RETURN r
END ParseRecordType;

PROCEDURE ParsePointerType() :AST.Type;
VAR
  t :AST.Type;
BEGIN
  ExpectToken(Lex.tPOINTER);
  ExpectToken(Lex.tTO);
  IF IsToken(Lex.tIDENT) THEN
    t := AST.NewPointerTypeByName(l, ExpectIdentifier());
  ELSE
    t := AST.NewPointerType(l, ParseType());
  END;
  RETURN t
END ParsePointerType;

PROCEDURE ParseFPSection(procType :AST.Type);
VAR
  name                  :StringId;
  firstParam, lastParam :AST.Decl;
  paramType             :AST.Type;
  varParameter          :BOOLEAN;
BEGIN
  varParameter := MatchToken(Lex.tVAR);
  name := ExpectIdentifier();
  firstParam := AST.AddDecl(l, procType.fields, name);
  lastParam := firstParam;
  IF varParameter THEN firstParam.kind := AST.declVarParam ELSE firstParam.kind := AST.declParam END;
  WHILE MatchToken(Lex.tCOMMA) DO
    name := ExpectIdentifier();
    lastParam := AST.AddDecl(l, procType.fields, name);
    IF varParameter THEN lastParam.kind := AST.declVarParam ELSE lastParam.kind := AST.declParam END;
  END;
  ExpectToken(Lex.tCOLON);
  (* The formal descrition of Oberon-07 is rather restrictive here. This *)
  (* could just as easily be :<TYPE> where TYPE is any type. Oberon-07   *)
  (* requires that the type be an identifier, although the "official"    *)
  (* Oberon-07 compiler (in Project Oberon 2013) actually allows         *)
  (* procedures here, *)
  WHILE MatchToken(Lex.tARRAY) DO
    (* ARRAY OF ... *)
    ExpectToken(Lex.tOF);
    (* TODO: Open Array *)
  END;
  paramType := ParseQualidentAndGetType();
  WHILE (firstParam # NIL) & (lastParam # NIL) & (firstParam # lastParam.next) DO
    firstParam.typ := paramType;
    firstParam := firstParam.next;
  END;
END ParseFPSection;

PROCEDURE ParseFormalParameters() :AST.Type;
VAR
  t :AST.Type;
BEGIN
  t := AST.NewProcedureType();
  IF MatchToken(Lex.tLPAREN) THEN
    IF IsToken(Lex.tVAR) OR IsToken(Lex.tIDENT) THEN
      ParseFPSection(t);
    END;
    WHILE MatchToken(Lex.tSEMI) DO
      ParseFPSection(t);
    END;
    ExpectToken(Lex.tRPAREN);
    IF MatchToken(Lex.tCOLON) THEN
      t.base := ParseQualidentAndGetType();
    END;
  END;
  RETURN t
END ParseFormalParameters;

PROCEDURE ParseProcedureType() :AST.Type;
BEGIN
  ExpectToken(Lex.tPROCEDURE);
  RETURN ParseFormalParameters()
END ParseProcedureType;

PROCEDURE ParseType0() :AST.Type;
VAR
  t :AST.Type;
BEGIN
  t := NIL;
  IF IsToken(Lex.tIDENT) THEN
    t := ParseQualidentAndGetType();
  ELSIF IsToken(Lex.tARRAY) THEN
    t := ParseArrayType();
  ELSIF IsToken(Lex.tRECORD) THEN
    t := ParseRecordType();
  ELSIF IsToken(Lex.tPOINTER) THEN
    t := ParsePointerType();
  ELSIF IsToken(Lex.tPROCEDURE) THEN
    t := ParseProcedureType();
  ELSE
    Lex.ErrorLn(l, "identifier, ARRAY, RECORD, POINTER, or PROCEDURE expected");
  END;
  RETURN t
END ParseType0;

PROCEDURE ParseConstDeclaration;
BEGIN
  ParseIdentDef;
  ExpectToken(Lex.tEQ);
  ParseExpression;
END ParseConstDeclaration;

PROCEDURE ParseTypeDeclaration;
VAR
  d :AST.Decl;
  t :AST.Type;
BEGIN
  d := ParseIdentDef();
  ExpectToken(Lex.tEQ);
  d.kind := AST.declType;
  d.typ := ParseType();

END ParseTypeDeclaration;

PROCEDURE ParseVarDeclaration;
VAR
  first, last :AST.Decl;
  t           :AST.Type;
BEGIN
  first := ParseIdentDef();
  last := first;
  WHILE MatchToken(Lex.tCOMMA) DO
    last := ParseIdentDef();
  END;
  ExpectToken(Lex.tCOLON);
  t := ParseType();
  WHILE (first # NIL) & (last # NIL) & (first # last.next) DO
    first.kind := AST.declVar;
    first.typ := t;
    first := first.next;
  END;
END ParseVarDeclaration;

PROCEDURE ParseProcedureBody(procDecl :AST.Decl);
VAR
  oldScope :AST.Decl;
BEGIN
  oldScope := AST.OpenScope();
  AST.AddFormalParamsToScope(l, procDecl);
  ParseDeclarationSequence;
  IF MatchToken(Lex.tBEGIN) THEN
    ParseStatementSequence;
  END;
  IF MatchToken(Lex.tRETURN) THEN
    ParseExpression;
  END;
  ExpectToken(Lex.tEND);
  AST.CloseScope(oldScope);
END ParseProcedureBody;

PROCEDURE ParseProcedureHeading() :AST.Decl;
VAR
  d :AST.Decl;
BEGIN
  MatchToken(Lex.tNATIVE);
  ExpectToken(Lex.tPROCEDURE);
  d := ParseIdentDef();
  d.kind := AST.declProcedure;
  d.typ := ParseFormalParameters();
  RETURN d
END ParseProcedureHeading;

PROCEDURE ParseProcedureDeclaration;
VAR
  d       :AST.Decl;
  endName :StringId;
BEGIN
  d := ParseProcedureHeading();
  ExpectToken(Lex.tSEMI);
  ParseProcedureBody(d);
  endName := ExpectIdentifier();
  IF d.name # endName THEN
    Lex.Error(l, "Procedure end name [");
    Lex.OutStr(l, endName);
    Out.Str("] must match start name [");
    Lex.OutStr(l, d.name);
    Out.PrintLn("]");
  END;
END ParseProcedureDeclaration;

PROCEDURE ParseDeclarationSequence0;
BEGIN
  IF MatchToken(Lex.tCONST) THEN
    WHILE IsToken(Lex.tIDENT) DO
      ParseConstDeclaration;
      ExpectToken(Lex.tSEMI);
    END;
  END;
  IF MatchToken(Lex.tTYPE) THEN
    WHILE IsToken(Lex.tIDENT) DO
      ParseTypeDeclaration;
      ExpectToken(Lex.tSEMI);
    END;
  END;
  AST.ResolveForwards(l);
  IF MatchToken(Lex.tVAR) THEN
    WHILE IsToken(Lex.tIDENT) DO
      ParseVarDeclaration;
      ExpectToken(Lex.tSEMI);
    END;
  END;
  WHILE IsToken(Lex.tPROCEDURE) OR IsToken(Lex.tNATIVE) DO
    ParseProcedureDeclaration;
    ExpectToken(Lex.tSEMI);
  END;
END ParseDeclarationSequence0;

PROCEDURE ParseImport;
BEGIN
  ExpectIdentifier;
  IF MatchToken(Lex.tASSIGN) THEN
    ExpectIdentifier;
  END;
END ParseImport;

PROCEDURE ParseImportList;
BEGIN
  ExpectToken(Lex.tIMPORT);
  ParseImport;
  WHILE MatchToken(Lex.tCOMMA) DO
    ParseImport;
  END;
  ExpectToken(Lex.tSEMI);
END ParseImportList;

PROCEDURE ParseModule;
VAR
  s, e :StringId;
  d    :AST.Decl;
BEGIN
  d := AST.OpenScope();
  ExpectToken(Lex.tMODULE);
  s := ExpectIdentifier();
  ExpectToken(Lex.tSEMI);
  IF IsToken(Lex.tIMPORT) THEN
    ParseImportList;
  END;
  ParseDeclarationSequence;
  IF MatchToken(Lex.tBEGIN) THEN
    ParseStatementSequence;
  END;
  ExpectToken(Lex.tEND);
  e := ExpectIdentifier();
  IF s # e THEN
    Lex.Error(l, "Module end name [");
    Lex.OutStr(l, e);
    Out.Str("] must match start name [");
    Lex.OutStr(l, s);
    Out.PrintLn("]");
  END;
  ExpectToken(Lex.tDOT);
  AST.CloseScope(d);
END ParseModule;

PROCEDURE TestParse;
BEGIN
(*
  Lex.LexerInitFromString(l, "WHILE i < 10 DO a;b;c; i := i + 1 END; j := i;");
  AST.InitGlobalScope(l);
  Lex.NextToken(l);
  ParseStatementSequence;
  Lex.LexerInitFromString(l, "RECORD (Wow) a, b, c :POINTER TO J; k :REAL; m:ARRAY 2,3,4OF CHAR END;");
  AST.InitGlobalScope(l);
  Lex.NextToken(l);
  ParseType;
  Lex.LexerInitFromString(l, "
  MODULE abc;
  CONST k=1*2+3+4;
  TYPE MySet* = SET;
  FooRec = ARRAY 5, 10, 15, 20 OF INTEGER;
  q* = INTEGER; r = q;
  END abc.
  ");
  AST.InitGlobalScope(l);
  Lex.NextToken(l);
  ParseModule;
  Lex.LexerInitFromFile(l, "AST.ob");
  AST.InitGlobalScope(l);
  Lex.NextToken(l);
  ParseModule;
  Lex.LexerInitFromFile(l, "Lex.ob");
  AST.InitGlobalScope(l);
  Lex.NextToken(l);
  ParseModule;
  Lex.LexerInitFromFile(l, "Parse.ob");
  AST.InitGlobalScope(l);
  Lex.NextToken(l);
  ParseModule;
  *)
  Lex.LexerInitFromString(l, "MODULE x; TYPE
  Wow = POINTER TO R2;
  R1 = RECORD a, b*, c, d :INTEGER; END;
  R2 = RECORD (R1) e, f*, g :INTEGER; END;
  Z1 = POINTER TO R1;
  Z2 = POINTER TO R2;
  Z3 = POINTER TO R3;
  R3 = RECORD z :Z3; i :INTEGER END;
  aa = ARRAY 10,20 OF INTEGER;
  P1 = PROCEDURE;
  P2 = PROCEDURE () :CHAR;
  P3 = PROCEDURE (a, b, c :INTEGER; VAR d :REAL; VAR e, f :CHAR) :SET;
  a = INTEGER; b* = CHAR; c = REAL; d = a; VAR rr :R1;
  PROCEDURE X1; BEGIN rr.a := 4; X1 END X1;
  PROCEDURE Zen(xa, xb :INTEGER); VAR rr :INTEGER; BEGIN rr := xa + xb; END Zen;
  END x.");
  AST.InitGlobalScope(l);
  Lex.NextToken(l);
  ParseModule;
  Out.PrintLn("PASS: Parser test");
END TestParse;

BEGIN
  ParseExpression := ParseExpression0;
  ParseStatementSequence := ParseStatementSequence0;
  ParseType := ParseType0;
  ParseDeclarationSequence := ParseDeclarationSequence0;
  TestParse
END Parse.

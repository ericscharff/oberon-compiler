MODULE Parse;

IMPORT AST, Decls, Lex, Out;

TYPE
  StringId = Lex.PoolIndex;
  CachedImport = RECORD
    name  :StringId;
    decls :AST.Decl;
  END;
VAR
  l :Lex.Lexer;
  importCache :ARRAY 128 OF CachedImport;
  importCacheEnd :INTEGER;
  lastModuleDecls :AST.Decl;
  ParseExpression :PROCEDURE () :AST.Expr;
  ParseStatementSequence :PROCEDURE;
  ParseType :PROCEDURE () :AST.Type;
  ParseDeclarationSequence :PROCEDURE;
  importCallback :Lex.LexCallback;

PROCEDURE IsToken(kind :Lex.TokenKind) :BOOLEAN;
BEGIN
  RETURN l.t.kind = kind
END IsToken;

PROCEDURE MatchToken(kind :Lex.TokenKind) :BOOLEAN;
VAR
  found :BOOLEAN;
BEGIN
  IF IsToken(kind) THEN
    Lex.NextToken(l);
    found := TRUE;
  ELSE
    found := FALSE;
  END;
  RETURN found
END MatchToken;

PROCEDURE ExpectToken(kind :Lex.TokenKind);
BEGIN
  IF IsToken(kind) THEN
    Lex.NextToken(l);
  ELSE
    Lex.Error(l, "Expected ");
    Out.Str(Lex.TokenNames[kind]);
    Out.Str(", got ");
    Out.PrintLn(Lex.TokenNames[l.t.kind]);
  END;
END ExpectToken;

PROCEDURE ExpectIdentifier() :StringId;
VAR
  s :StringId;
BEGIN
  s := l.t.sVal;
  ExpectToken(Lex.tIDENT);
  RETURN s
END ExpectIdentifier;

PROCEDURE IsImportedModule(ident :StringId) :BOOLEAN;
VAR
  d :AST.Decl;
BEGIN
  d := Decls.LookupDecl(l, ident);
  RETURN (d # NIL) & (d.kind = AST.declImport)
END IsImportedModule;

PROCEDURE ParseQualident() :AST.Decl;
VAR
  moduleName, ident :StringId;
  d :AST.Decl;
BEGIN
  ident := ExpectIdentifier();
  IF IsImportedModule(ident) THEN
    moduleName := ident;
    ExpectToken(Lex.tDOT);
    ident := ExpectIdentifier();
    d := Decls.LookupImport(l, moduleName, ident);
  ELSE
    d := Decls.LookupDecl(l, ident);
    (* lookup ident *)
  END;
  RETURN d
END ParseQualident;

PROCEDURE ParseQualidentAndGetType() :AST.Type;
VAR
  d :AST.Decl;
  t :AST.Type;
BEGIN
  t := NIL;
  d := ParseQualident();
  IF d # NIL THEN
    t := d.typ;
    IF d.kind # AST.declType THEN
      Lex.Error(l, "");
      Lex.OutStr(l, d.name);
      Out.PrintLn(" is not a TYPE");
    END;
  END;
  RETURN t
END ParseQualidentAndGetType;

PROCEDURE ParseSetElement() :AST.Expr;
VAR
  e :AST.Expr;
BEGIN
  e := ParseExpression();
  IF MatchToken(Lex.tDOTDOT) THEN
    e := AST.NewExprSetRange(l, e, ParseExpression(), Decls.setType);
  ELSE
    e := AST.NewExprSetElement(l, e, Decls.setType);
  END;
  RETURN e
END ParseSetElement;

PROCEDURE ParseSet() :AST.Expr;
VAR
  e :AST.Expr;
BEGIN
  ExpectToken(Lex.tLBRACE);
  IF IsToken(Lex.tRBRACE) THEN
    (* empty set *)
    e := AST.NewExprSet(Decls.setType);
  ELSE
    e := ParseSetElement();
    WHILE MatchToken(Lex.tCOMMA) DO
      e := AST.NewExprSetUnion(l, e, ParseSetElement());
    END;
  END;
  ExpectToken(Lex.tRBRACE);
  RETURN e
END ParseSet;

PROCEDURE IsTypeGuard(e :AST.Expr) :BOOLEAN;
BEGIN
  RETURN (e.typ.kind = AST.typePointer) OR ((e.typ.kind = AST.typeRecord) & (e.kind = AST.exprIdentRef) & (e.decl.kind = AST.declVarParam))
END IsTypeGuard;

PROCEDURE ParseDesignator() :AST.Expr;
VAR
  e :AST.Expr;
BEGIN
  e := AST.NewExprIdentRef(ParseQualident());
  WHILE IsToken(Lex.tDOT) OR IsToken(Lex.tLBRACK) OR IsToken(Lex.tCARET) OR
        (IsTypeGuard(e) & IsToken(Lex.tLPAREN)) DO
    IF MatchToken(Lex.tDOT) THEN
      e := AST.NewExprFieldRef(l, e, ExpectIdentifier());
    ELSIF MatchToken(Lex.tLBRACK) THEN
      e := AST.NewExprArrayRef(l, e, ParseExpression());
      WHILE MatchToken(Lex.tCOMMA) DO
        e := AST.NewExprArrayRef(l, e, ParseExpression());
      END;
      ExpectToken(Lex.tRBRACK);
    ELSIF MatchToken(Lex.tCARET) THEN
      e := AST.NewExprPointerDeref(l, e);
    ELSIF IsTypeGuard(e) & MatchToken(Lex.tLPAREN) THEN
      e := AST.NewExprTypeGuard(l, e, ParseQualident());
      ExpectToken(Lex.tRPAREN);
    ELSE
      ASSERT(FALSE);
    END
  END;
  RETURN e
END ParseDesignator;

PROCEDURE ParseActualParameters() :AST.Expr;
VAR
  head, tail :AST.Expr;
BEGIN
  head := NIL;
  ExpectToken(Lex.tLPAREN);
  IF ~IsToken(Lex.tRPAREN) THEN
    head := ParseExpression();
    tail := head;
    WHILE MatchToken(Lex.tCOMMA) DO
      tail.next := ParseExpression();
      tail := tail.next;
    END;
  END;
  ExpectToken(Lex.tRPAREN);
  RETURN head
END ParseActualParameters;

PROCEDURE ParseFactor() :AST.Expr;
VAR
  e :AST.Expr;
BEGIN
  e := AST.NewExprNil(Decls.nilType);
  IF IsToken(Lex.tINT) THEN
    e := AST.NewExprInteger(l.t.iVal, Decls.integerType);
    MatchToken(Lex.tINT);
  ELSIF IsToken(Lex.tREAL) THEN
    e := AST.NewExprReal(l.t.rVal, Decls.realType);
    MatchToken(Lex.tREAL);
  ELSIF IsToken(Lex.tSTRING) THEN
    e := AST.NewExprString(l.t.sVal, Decls.stringType);
    MatchToken(Lex.tSTRING);
  ELSIF MatchToken(Lex.tNIL) THEN
    e := AST.NewExprNil(Decls.nilType);
  ELSIF MatchToken(Lex.tTRUE) THEN
    e := AST.NewExprBoolean(1, Decls.booleanType);
  ELSIF MatchToken(Lex.tFALSE) THEN
    e := AST.NewExprBoolean(0, Decls.booleanType);
  ELSIF IsToken(Lex.tLBRACE) THEN
    e := ParseSet();
  ELSIF IsToken(Lex.tIDENT) THEN
    e := ParseDesignator();
    IF IsToken(Lex.tLPAREN) THEN
      e := AST.NewExprProcCall(l, e, ParseActualParameters());
    END;
  ELSIF MatchToken(Lex.tLPAREN) THEN
    e := ParseExpression();
    ExpectToken(Lex.tRPAREN);
  ELSIF MatchToken(Lex.tTILDE) THEN
    e := AST.NewExprUnary(l, Lex.tTILDE, ParseFactor());
  ELSE
    Lex.ErrorLn(l, "Factor expected");
  END;
  RETURN e
END ParseFactor;

PROCEDURE IsMulOperator() :BOOLEAN;
BEGIN
  RETURN IsToken(Lex.tSTAR) OR IsToken(Lex.tSLASH) OR IsToken(Lex.tDIV) OR
         IsToken(Lex.tMOD) OR IsToken(Lex.tAMP) OR IsToken(Lex.tXOR)
END IsMulOperator;

PROCEDURE ParseTerm() :AST.Expr;
VAR
  e  :AST.Expr;
  op :Lex.TokenKind;
BEGIN
  e := ParseFactor();
  WHILE IsMulOperator() DO
    op := l.t.kind;
    Lex.NextToken(l);
    e := AST.NewExprBinary(l, op, e, ParseFactor(), Decls.booleanType);
  END;
  RETURN e
END ParseTerm;

PROCEDURE IsAddOperator() :BOOLEAN;
BEGIN
  RETURN IsToken(Lex.tPLUS) OR IsToken(Lex.tMINUS) OR IsToken(Lex.tOR)
END IsAddOperator;

PROCEDURE ParseSimpleExpression() :AST.Expr;
VAR
  e                     :AST.Expr;
  op                    :Lex.TokenKind;
  unaryPlus, unaryMinus :BOOLEAN;
BEGIN
  unaryPlus := FALSE;
  unaryMinus := FALSE;
  IF MatchToken(Lex.tPLUS) THEN
    unaryPlus := TRUE;
  ELSIF MatchToken(Lex.tMINUS) THEN
    unaryMinus := TRUE;
  END;

  e := ParseTerm();
  IF unaryPlus THEN
    e := AST.NewExprUnary(l, Lex.tPLUS, e);
  END;
  IF unaryMinus THEN
    e := AST.NewExprUnary(l, Lex.tMINUS, e);
  END;
  WHILE IsAddOperator() DO
    op := l.t.kind;
    Lex.NextToken(l);
    e := AST.NewExprBinary(l, op, e, ParseTerm(), Decls.booleanType);
  END;
  RETURN e
END ParseSimpleExpression;

PROCEDURE IsRelation() :BOOLEAN;
BEGIN
  RETURN IsToken(Lex.tEQ) OR IsToken(Lex.tPOUND) OR IsToken(Lex.tLT) OR
         IsToken(Lex.tLTEQ) OR IsToken(Lex.tGT) OR IsToken(Lex.tGTEQ) OR
         IsToken(Lex.tIN) OR IsToken(Lex.tIS)
END IsRelation;

PROCEDURE ParseExpression0() :AST.Expr;
VAR
  e  :AST.Expr;
  op :Lex.TokenKind;
BEGIN
  e := ParseSimpleExpression();
  IF IsRelation() THEN
    op := l.t.kind;
    Lex.NextToken(l);
    e := AST.NewExprBinary(l, op, e, ParseSimpleExpression(), Decls.booleanType);
  END;
  RETURN e
END ParseExpression0;

PROCEDURE ParseIfStatement;
BEGIN
  ExpectToken(Lex.tIF);
  ParseExpression;
  ExpectToken(Lex.tTHEN);
  ParseStatementSequence;
  WHILE MatchToken(Lex.tELSIF) DO
    ParseExpression;
    ExpectToken(Lex.tTHEN);
    ParseStatementSequence;
  END;
  IF MatchToken(Lex.tELSE) THEN
    ParseStatementSequence;
  END;
  ExpectToken(Lex.tEND);
END ParseIfStatement;

PROCEDURE ParseCaseLabel;
BEGIN
  IF IsToken(Lex.tINT) OR IsToken(Lex.tSTRING) OR IsToken(Lex.tIDENT) THEN
    ParseFactor;
  ELSE
    Lex.ErrorLn(l, "Case label (INTEGER, STRING, IDENT) expected");
  END;
END ParseCaseLabel;

PROCEDURE ParseCaseLabelRange;
BEGIN
  ParseCaseLabel;
  IF MatchToken(Lex.tDOTDOT) THEN
    ParseCaseLabel;
  END;
END ParseCaseLabelRange;

PROCEDURE ParseCaseLabelList;
BEGIN
  ParseCaseLabelRange;
  WHILE MatchToken(Lex.tCOMMA) DO
    ParseCaseLabelRange;
  END;
END ParseCaseLabelList;

PROCEDURE ParseCase;
BEGIN
  IF IsToken(Lex.tINT) OR IsToken(Lex.tSTRING) OR IsToken(Lex.tIDENT) THEN
    ParseCaseLabelList;
    ExpectToken(Lex.tCOLON);
    ParseStatementSequence;
  END;
END ParseCase;

PROCEDURE ParseCaseStatement;
BEGIN
  ExpectToken(Lex.tCASE);
  ParseExpression;
  ExpectToken(Lex.tOF);
  ParseCase;
  WHILE MatchToken(Lex.tVBAR) DO
    ParseCase;
  END;
  ExpectToken(Lex.tEND);
END ParseCaseStatement;

PROCEDURE ParseWhileStatement;
BEGIN
  ExpectToken(Lex.tWHILE);
  ParseExpression;
  ExpectToken(Lex.tDO);
  ParseStatementSequence;
  WHILE MatchToken(Lex.tELSIF) DO
    ParseExpression;
    ExpectToken(Lex.tDO);
    ParseStatementSequence;
  END;
  ExpectToken(Lex.tEND);
END ParseWhileStatement;

PROCEDURE ParseRepeatStatement;
BEGIN
  ExpectToken(Lex.tREPEAT);
  ParseStatementSequence;
  ExpectToken(Lex.tUNTIL);
  ParseExpression;
END ParseRepeatStatement;

PROCEDURE ParseForStatement;
BEGIN
  ExpectToken(Lex.tFOR);
  ExpectIdentifier;
  ExpectToken(Lex.tASSIGN);
  ParseExpression;
  ExpectToken(Lex.tTO);
  ParseExpression;
  IF MatchToken(Lex.tBY) THEN
    ParseExpression;
  END;
  ExpectToken(Lex.tDO);
  ParseStatementSequence;
  ExpectToken(Lex.tEND);
END ParseForStatement;

PROCEDURE ParseAssignOrProcCall;
BEGIN
  ParseDesignator;
  IF MatchToken(Lex.tASSIGN) THEN
    (* Assignment *)
    AST.DumpExpr(l, ParseExpression());
  ELSE
    (* Procedure call *)
    IF IsToken(Lex.tLPAREN) THEN
      ParseActualParameters;
    END;
  END;
END ParseAssignOrProcCall;

PROCEDURE ParseStatement;
BEGIN
  IF IsToken(Lex.tIF) THEN
    ParseIfStatement;
  ELSIF IsToken(Lex.tCASE) THEN
    ParseCaseStatement;
  ELSIF IsToken(Lex.tWHILE) THEN
    ParseWhileStatement;
  ELSIF IsToken(Lex.tREPEAT) THEN
    ParseRepeatStatement;
  ELSIF IsToken(Lex.tFOR) THEN
    ParseForStatement;
  ELSIF IsToken(Lex.tIDENT) THEN
    ParseAssignOrProcCall;
  ELSE
    (* Empty *)
  END;
END ParseStatement;

PROCEDURE ParseStatementSequence0;
BEGIN
  ParseStatement;
  WHILE MatchToken(Lex.tSEMI) DO
    ParseStatement;
  END;
END ParseStatementSequence0;

PROCEDURE ParseFieldIdentDef(VAR recordScope :AST.Decl) :AST.Decl;
VAR
  d    :AST.Decl;
  name :StringId;
BEGIN
  name := ExpectIdentifier();
  d := Decls.AddDecl(l, recordScope, name);
  IF MatchToken(Lex.tSTAR) THEN
    d.exported := TRUE;
  END;
  RETURN d
END ParseFieldIdentDef;

PROCEDURE ParseIdentDef() :AST.Decl;
VAR
  d :AST.Decl;
  n :StringId;
BEGIN
  n := ExpectIdentifier();
  d := Decls.AddScopeDecl(l, n);
  IF MatchToken(Lex.tSTAR) THEN
    d.exported := TRUE;
  END;
  RETURN d
END ParseIdentDef;

PROCEDURE ParseArrayType() :AST.Type;
VAR
  outer, current, last :AST.Type;
  e                    :AST.Expr;
BEGIN
  ExpectToken(Lex.tARRAY);
  e := ParseExpression();
  outer := Decls.NewArrayType(l, e);
  ASSERT(e.iVal > 0);
  last := outer;
  WHILE MatchToken(Lex.tCOMMA) DO
    e := ParseExpression();
    current := Decls.NewArrayType(l, e);
    ASSERT(e.iVal > 0);
    last.base := current;
    last := current;
  END;
  ExpectToken(Lex.tOF);
  current := ParseType();
  last.base := current;
  RETURN outer
END ParseArrayType;

PROCEDURE ParseRecordType() :AST.Type;
VAR
  r, base, fieldType              :AST.Type;
  baseDecl, firstField, lastField :AST.Decl;
BEGIN
  base := NIL;
  ExpectToken(Lex.tRECORD);
  IF MatchToken(Lex.tLPAREN) THEN
    baseDecl := ParseQualident();
    ExpectToken(Lex.tRPAREN);
    IF baseDecl # NIL THEN
      base := baseDecl.typ;
    END;
  END;
  r := Decls.NewRecordType(l, base);
  IF IsToken(Lex.tIDENT) THEN
    REPEAT
      firstField := ParseFieldIdentDef(r.fields);
      lastField := firstField;
      WHILE MatchToken(Lex.tCOMMA) DO
        lastField := ParseFieldIdentDef(r.fields);
      END;
      ExpectToken(Lex.tCOLON);
      fieldType := ParseType();
      WHILE (firstField # NIL) & (lastField # NIL) & (firstField # lastField.next) DO
        firstField.kind := AST.declField;
        firstField.typ := fieldType;
        firstField := firstField.next;
      END;
      MatchToken(Lex.tSEMI);
    UNTIL IsToken(Lex.tEND) OR IsToken(Lex.tEOF)
  END;
  ExpectToken(Lex.tEND);
  RETURN r
END ParseRecordType;

PROCEDURE ParsePointerType() :AST.Type;
VAR
  t :AST.Type;
BEGIN
  ExpectToken(Lex.tPOINTER);
  ExpectToken(Lex.tTO);
  IF IsToken(Lex.tIDENT) THEN
    t := Decls.NewPointerTypeByName(l, ExpectIdentifier());
  ELSE
    t := Decls.NewPointerType(l, ParseType());
  END;
  RETURN t
END ParsePointerType;

PROCEDURE ParseFPSection(procType :AST.Type);
VAR
  name                  :StringId;
  firstParam, lastParam :AST.Decl;
  paramType, arrType    :AST.Type;
  varParameter, openArr :BOOLEAN;
BEGIN
  varParameter := MatchToken(Lex.tVAR);
  openArr := FALSE;
  name := ExpectIdentifier();
  firstParam := Decls.AddDecl(l, procType.fields, name);
  lastParam := firstParam;
  IF varParameter THEN firstParam.kind := AST.declVarParam ELSE firstParam.kind := AST.declParam END;
  WHILE MatchToken(Lex.tCOMMA) DO
    name := ExpectIdentifier();
    lastParam := Decls.AddDecl(l, procType.fields, name);
    IF varParameter THEN lastParam.kind := AST.declVarParam ELSE lastParam.kind := AST.declParam END;
  END;
  ExpectToken(Lex.tCOLON);
  (* The formal descrition of Oberon-07 is rather restrictive here. This *)
  (* could just as easily be :<TYPE> where TYPE is any type. Oberon-07   *)
  (* requires that the type be an identifier, although the "official"    *)
  (* Oberon-07 compiler (in Project Oberon 2013) actually allows         *)
  (* procedures here, *)
  IF MatchToken(Lex.tARRAY) THEN
    (* ARRAY OF ... *)
    ExpectToken(Lex.tOF);
    openArr := TRUE;
  END;
  paramType := ParseQualidentAndGetType();
  IF openArr THEN
    arrType := Decls.NewArrayType(l, AST.NewExprInteger(0, Decls.integerType));
    arrType.base := paramType;
    paramType := arrType;
  END;
  WHILE (firstParam # NIL) & (lastParam # NIL) & (firstParam # lastParam.next) DO
    firstParam.typ := paramType;
    firstParam := firstParam.next;
  END;
END ParseFPSection;

PROCEDURE ParseFormalParameters() :AST.Type;
VAR
  t :AST.Type;
BEGIN
  t := Decls.NewProcedureType();
  IF MatchToken(Lex.tLPAREN) THEN
    IF IsToken(Lex.tVAR) OR IsToken(Lex.tIDENT) THEN
      ParseFPSection(t);
    END;
    WHILE MatchToken(Lex.tSEMI) DO
      ParseFPSection(t);
    END;
    ExpectToken(Lex.tRPAREN);
    IF MatchToken(Lex.tCOLON) THEN
      t.base := ParseQualidentAndGetType();
    ELSE
      t.base := Decls.nilType;
    END;
  END;
  Decls.CountProcedureArgs(t);
  RETURN t
END ParseFormalParameters;

PROCEDURE ParseProcedureType() :AST.Type;
BEGIN
  ExpectToken(Lex.tPROCEDURE);
  RETURN ParseFormalParameters()
END ParseProcedureType;

PROCEDURE ParseType0() :AST.Type;
VAR
  t :AST.Type;
BEGIN
  t := NIL;
  IF IsToken(Lex.tIDENT) THEN
    t := ParseQualidentAndGetType();
  ELSIF IsToken(Lex.tARRAY) THEN
    t := ParseArrayType();
  ELSIF IsToken(Lex.tRECORD) THEN
    t := ParseRecordType();
  ELSIF IsToken(Lex.tPOINTER) THEN
    t := ParsePointerType();
  ELSIF IsToken(Lex.tPROCEDURE) THEN
    t := ParseProcedureType();
  ELSE
    Lex.ErrorLn(l, "Identifier, ARRAY, RECORD, POINTER, or PROCEDURE expected");
  END;
  RETURN t
END ParseType0;

PROCEDURE ParseConstDeclaration;
VAR
  d :AST.Decl;
  e :AST.Expr;
  t :AST.Type;
BEGIN
  d := ParseIdentDef();
  ExpectToken(Lex.tEQ);
  e := ParseExpression();
  d.kind := AST.declConst;
  d.typ := e.typ;
  d.expr := e;
  IF ~AST.IsConst(e) THEN
    Lex.ErrorLn(l, "CONST declaration is not constant");
  END;
  AST.DumpDecl(l, d);
END ParseConstDeclaration;

PROCEDURE ParseTypeDeclaration;
VAR
  d :AST.Decl;
  t :AST.Type;
BEGIN
  d := ParseIdentDef();
  ExpectToken(Lex.tEQ);
  d.kind := AST.declType;
  d.typ := ParseType();

END ParseTypeDeclaration;

PROCEDURE ParseVarDeclaration;
VAR
  first, last :AST.Decl;
  t           :AST.Type;
BEGIN
  first := ParseIdentDef();
  last := first;
  WHILE MatchToken(Lex.tCOMMA) DO
    last := ParseIdentDef();
  END;
  ExpectToken(Lex.tCOLON);
  t := ParseType();
  WHILE (first # NIL) & (last # NIL) & (first # last.next) DO
    first.kind := AST.declVar;
    first.typ := t;
    first := first.next;
  END;
END ParseVarDeclaration;

PROCEDURE ParseProcedureBody(procDecl :AST.Decl);
VAR
  oldScope :AST.Decl;
BEGIN
  oldScope := Decls.OpenScope();
  Decls.AddFormalParamsToScope(l, procDecl);
  ParseDeclarationSequence;
  IF MatchToken(Lex.tBEGIN) THEN
    ParseStatementSequence;
  END;
  IF MatchToken(Lex.tRETURN) THEN
    ParseExpression;
  END;
  ExpectToken(Lex.tEND);
  Decls.CloseScope(oldScope);
END ParseProcedureBody;

PROCEDURE ParseProcedureHeading() :AST.Decl;
VAR
  d :AST.Decl;
BEGIN
  MatchToken(Lex.tNATIVE);
  ExpectToken(Lex.tPROCEDURE);
  d := ParseIdentDef();
  d.kind := AST.declProcedure;
  d.typ := ParseFormalParameters();
  RETURN d
END ParseProcedureHeading;

PROCEDURE ParseProcedureDeclaration;
VAR
  d       :AST.Decl;
  endName :StringId;
BEGIN
  d := ParseProcedureHeading();
  ExpectToken(Lex.tSEMI);
  ParseProcedureBody(d);
  endName := ExpectIdentifier();
  IF d.name # endName THEN
    Lex.Error(l, "Procedure end name [");
    Lex.OutStr(l, endName);
    Out.Str("] must match start name [");
    Lex.OutStr(l, d.name);
    Out.PrintLn("]");
  END;
END ParseProcedureDeclaration;

PROCEDURE ParseDeclarationSequence0;
BEGIN
  IF MatchToken(Lex.tCONST) THEN
    WHILE IsToken(Lex.tIDENT) DO
      ParseConstDeclaration;
      ExpectToken(Lex.tSEMI);
    END;
  END;
  IF MatchToken(Lex.tTYPE) THEN
    WHILE IsToken(Lex.tIDENT) DO
      ParseTypeDeclaration;
      ExpectToken(Lex.tSEMI);
    END;
  END;
  Decls.ResolveForwards(l);
  IF MatchToken(Lex.tVAR) THEN
    WHILE IsToken(Lex.tIDENT) DO
      ParseVarDeclaration;
      ExpectToken(Lex.tSEMI);
    END;
  END;
  WHILE IsToken(Lex.tPROCEDURE) OR IsToken(Lex.tNATIVE) DO
    ParseProcedureDeclaration;
    ExpectToken(Lex.tSEMI);
  END;
END ParseDeclarationSequence0;

PROCEDURE GetModuleImports(moduleName :StringId) :AST.Decl;
VAR
  i :INTEGER;
  d :AST.Decl;
BEGIN
  i := 0;
  WHILE (i < importCacheEnd) & (importCache[i].name # moduleName) DO
    INC(i);
  END;
  IF importCache[i].name = moduleName THEN
    d := importCache[i].decls;
  ELSE
    ASSERT(importCacheEnd < 128);
    Lex.ImportHelper(l, moduleName, importCallback);
    d := lastModuleDecls;
    importCache[importCacheEnd].name := moduleName;
    importCache[importCacheEnd].decls := d;
    INC(importCacheEnd);
  END;
  RETURN d
END GetModuleImports;

PROCEDURE ParseImport;
VAR
  name, alias :StringId;
  d           :AST.Decl;
BEGIN
  name := ExpectIdentifier();
  alias := name;
  IF MatchToken(Lex.tASSIGN) THEN
    name := ExpectIdentifier();
  END;
  d := GetModuleImports(name);
  Decls.AddImportDecl(l, alias, d);
END ParseImport;

PROCEDURE ParseImportList;
BEGIN
  ExpectToken(Lex.tIMPORT);
  ParseImport;
  WHILE MatchToken(Lex.tCOMMA) DO
    ParseImport;
  END;
  ExpectToken(Lex.tSEMI);
END ParseImportList;

PROCEDURE ParseModule;
VAR
  s, e :StringId;
  d    :AST.Decl;
BEGIN
  Decls.InitGlobalScope(l);
  d := Decls.OpenScope();
  ExpectToken(Lex.tMODULE);
  s := ExpectIdentifier();
  ExpectToken(Lex.tSEMI);
  IF IsToken(Lex.tIMPORT) THEN
    ParseImportList;
  END;
  ParseDeclarationSequence;
  IF MatchToken(Lex.tBEGIN) THEN
    ParseStatementSequence;
  END;
  ExpectToken(Lex.tEND);
  e := ExpectIdentifier();
  IF s # e THEN
    Lex.Error(l, "Module end name [");
    Lex.OutStr(l, e);
    Out.Str("] must match start name [");
    Lex.OutStr(l, s);
    Out.PrintLn("]");
  END;
  ExpectToken(Lex.tDOT);
  lastModuleDecls := Decls.CurrentScope();
  Decls.CloseScope(d);
END ParseModule;

(* This is called by the lexer. See Lex.ImportHelper. *)
PROCEDURE ImportHelper;
VAR
  savedScope :AST.Decl;
BEGIN
  (* ParseModule (below) will set the state back to the global scope. *)
  (* Thus, we save the previous MODULE's scope here, parse the new    *)
  (* MODULE, and then restore the old state. This handles a case like *)
  (* MODULE X imports A, B.                                           *)
  (* 1) start MODULE X parse (reset to global scope)                  *)
  (* 2) start MODULE A parse (reset TO global scope)                  *)
  (* 3) end MODULE A parse (a decls saved in lastModuleDecls)         *)
  (* 4) Add decl FOR A to X's scope                                   *)
  (* 5) start MODULE B parse (reset TO global scope)                  *)
  (* 6) end MODULE B parse (a decls saved in lastModuleDecls)         *)
  (* 7) Add decl FOR B to X's scope                                   *)
  (* This savedScope call ensures we hold on to the A and B defs      *)
  (* after all the global scope resetting.                            *)
  savedScope := Decls.CurrentScope();
  Lex.NextToken(l);
  ParseModule;
  Decls.CloseScope(savedScope);
END ImportHelper;

PROCEDURE TestParse;
BEGIN
(*
  Lex.LexerInitFromFile(l, "Decls.ob");
  Lex.NextToken(l);
  ParseModule;
  Decls.TestCleanup(); importCacheEnd := 0;
  Lex.LexerInitFromFile(l, "Lex.ob");
  Lex.NextToken(l);
  ParseModule;
  Decls.TestCleanup(); importCacheEnd := 0;
  Lex.LexerInitFromFile(l, "Parse.ob");
  Lex.NextToken(l);
  ParseModule;
*)
  Lex.LexerInitFromFile(l, "Simple.ob");
  Lex.NextToken(l);
  ParseModule;
  Out.PrintLn("PASS: Parser test");
END TestParse;

BEGIN
  importCacheEnd := 0;
  ParseExpression := ParseExpression0;
  ParseStatementSequence := ParseStatementSequence0;
  ParseType := ParseType0;
  ParseDeclarationSequence := ParseDeclarationSequence0;
  importCallback := ImportHelper;
  TestParse
END Parse.

MODULE CCodegen;

IMPORT AST, Lex, Out;

VAR
  indent :INTEGER;

PROCEDURE GenStr(s :ARRAY OF CHAR);
BEGIN
  Out.Str(s);
END GenStr;

PROCEDURE GenInt(i :INTEGER);
BEGIN
  Out.Int(i);
END GenInt;

PROCEDURE GenReal(r :REAL);
BEGIN
  Out.Real(r);
END GenReal;

PROCEDURE GenLn;
BEGIN
  Out.Ln
END GenLn;

PROCEDURE GenI;
VAR
  i :INTEGER;
BEGIN
  FOR i := 1 TO indent DO GenStr("  ") END
END GenI;

PROCEDURE GenQName(l :Lex.Lexer; name :AST.QName);
BEGIN
  IF name.moduleName > 0 THEN
    Lex.OutStr(l, name.moduleName);
    GenStr("_");
  END;
  IF name.name > 0 THEN
    Lex.OutStr(l, name.name);
  END;
END GenQName;

PROCEDURE GenType(l :Lex.Lexer; t :AST.Type; name :AST.QName; skipDecl, procDecl :BOOLEAN);
VAR
  f :AST.Decl;
  q :AST.QName;
  p :AST.Type;
BEGIN
  q.moduleName := 0;
  q.name := 0;
  IF (t.decl = NIL) OR skipDecl THEN
    CASE t.kind OF
      AST.typeInteger:
        GenStr("int ");
        GenQName(l, name);
    | AST.typeReal:
        GenStr("float ");
        GenQName(l, name);
    | AST.typeBoolean:
        GenStr("bool ");
        GenQName(l, name);
    | AST.typeChar:
        GenStr("char ");
        GenQName(l, name);
    | AST.typeSet:
        GenStr("int ");
        GenQName(l, name);
    | AST.typePointer:
        IF t.base.decl = NIL THEN
          GenType(l, t.base, q, FALSE, FALSE);
        ELSE
          GenStr("struct ");
          GenQName(l, t.base.decl.qname);
        END;
        GenStr(" *");
        GenQName(l, name);
    | AST.typeArray:
        p := t;
        WHILE p.kind = AST.typeArray DO
          p := p.base;
        END;
        GenType(l, p, name, FALSE, FALSE);
        p := t;
        WHILE (p.kind = AST.typeArray) DO
          GenStr("[");
          GenInt(p.length);
          GenStr("]");
          p := p.base;
        END;
    | AST.typeRecord:
        GenStr("struct ");
        GenQName(l, name);
        GenStr(" {");
        GenLn;
        INC(indent);
        IF AST.NeedsTypeInfo(t) THEN
          GenI; GenStr("oberon typid _tid;"); GenLn;
        END;
        f := t.fields;
        WHILE (f # NIL) & (f.kind # AST.declEND) DO
          (* Drop package from field name *)
          q.name := f.qname.name;
          GenI;
          GenType(l, f.typ, q, FALSE, FALSE);
          GenStr(";");
          GenLn;
          f := f.next;
        END;
        DEC(indent);
        GenI; GenStr("} "); GenQName(l, name);
    | AST.typeProcedure:
        IF t.base.kind = AST.typeNil THEN
          GenStr("void ")
        ELSE
          GenType(l, t.base, q, FALSE, FALSE);
        END;
        IF procDecl THEN
          GenQName(l, name);
        ELSE
          GenStr(" (*");
          GenQName(l, name);
          GenStr(")");
        END;
        GenStr("(");
        IF t.fields = NIL THEN
          GenStr("void"); (* For C++, this would be empty *)
        ELSE
          f := t.fields;
          WHILE f.kind # AST.declEND DO
            t := f.typ;
            IF procDecl THEN
              q.name := f.qname.name;
            END;
            IF (t.kind IN {AST.typeRecord, AST.typeArray}) & (f.kind # AST.declVarParam) THEN
              GenStr("const ");
            END;
            IF (t.kind = AST.typeRecord) OR (f.kind = AST.declVarParam) THEN
              q.name := 0;
              GenType(l, t, q, FALSE, FALSE);
              GenStr(" *");
              IF procDecl THEN
                q.name := f.qname.name;
                GenQName(l, q);
              END;
            ELSIF (t.kind = AST.typeRecord) OR AST.IsOpenArray(t) THEN
              q.name := 0;
              GenType(l, t.base, q, FALSE, FALSE);
              GenStr(" *");
              IF procDecl THEN
                q.name := f.qname.name;
                GenQName(l, q);
              END;
            ELSE
              GenType(l, t, q, FALSE, FALSE);
            END;
            IF AST.IsOpenArray(t) THEN
              GenStr(", size_t");
              IF procDecl THEN
                GenStr(" ");
                GenQName(l, q);
                GenStr("__len");
              END;
            END;
            IF f.next.kind # AST.declEND THEN
              GenStr(", ");
            END;
            f := f.next;
          END;
        END;
        GenStr(")");
    END;
  ELSE
    GenQName(l, t.decl.qname);
    GenStr(" ");
    GenQName(l, name);
  END;
END GenType;

PROCEDURE GenVal(l :Lex.Lexer; e :AST.Expr);
BEGIN
  ASSERT(e.typ # NIL);
  IF e.typ.kind = AST.typeNil THEN
    GenStr("0 /*NULL*/");
  ELSIF e.typ.kind IN {AST.typeInteger, AST.typeBoolean, AST.typeChar, AST.typeSet} THEN
    GenInt(e.iVal);
  ELSIF e.typ.kind = AST.typeReal THEN
    GenReal(e.rVal);
  ELSIF e.typ.kind = AST.typeString THEN
    Lex.OutStrEscaped(l, e.iVal);
  ELSE
    ASSERT(FALSE);
  END;
END GenVal;

PROCEDURE GenLengthof(l :Lex.Lexer; e :AST.Expr);
VAR
  q :AST.QName;
BEGIN
  q.moduleName := 0;
  IF e.typ.kind = AST.typeString THEN
    GenInt(Lex.StringLenI(l, e.iVal) + 1);
  ELSIF e.typ.length > 0 THEN
    GenInt(e.typ.length);
  ELSE
    ASSERT(e.kind = AST.exprIdentRef);
    q.name := e.decl.qname.name;
    GenQName(l, q);
    GenStr("__len");
  END;
END GenLengthof;

PROCEDURE GenExpr(l :Lex.Lexer; e :AST.Expr);
VAR
  q      :AST.QName;
  formal :AST.Decl;
BEGIN
  ASSERT(e # NIL);
  ASSERT(e.kind >= AST.exprVal);
  ASSERT(e.kind <= AST.exprAssign);
  CASE e.kind OF
    AST.exprVal:
      GenVal(l, e);
  | AST.exprUnary:
      GenStr("TODO UNARY");
  | AST.exprBinary:
      GenStr("TODO BINARY");
  | AST.exprIdentRef:
      IF (e.decl.kind IN {AST.declVar, AST.declProcedure}) & (e.decl.nesting = 0) THEN
        q.moduleName := e.decl.qname.moduleName;
      ELSE
        (* Local variables don't get a prefix, just for readability *)
        q.moduleName := 0;
      END;
      q.name := e.decl.qname.name;
      IF (e.decl.kind = AST.declVarParam) OR
         ((e.decl.kind = AST.declParam) & (e.typ.kind = AST.typeRecord)) THEN
        GenStr("(*");
        GenQName(l, q);
        GenStr(")");
      ELSE
        GenQName(l, q);
      END;
  | AST.exprProcCall:
      GenExpr(l, e.lhs);
      GenStr("(");
      formal := e.lhs.typ.fields;
      e := e.rhs;
      WHILE e # NIL DO
        IF e.typ.kind = AST.typeArray THEN
          (* Arrays are always passed by pointer, no special procesing  *)
          GenExpr(l, e);
        ELSIF (e.typ.kind = AST.typeRecord) OR (formal.kind = AST.declVarParam) THEN
          (* Record (and VAR parameters) are always passed by reference *)
          GenStr("&(");
          GenExpr(l, e);
          GenStr(")");
        ELSE
          (* Everything else is passed by value.                        *)
          GenExpr(l, e);
        END;
        IF AST.IsOpenArray(formal.typ) THEN
          GenStr(", ");
          GenLengthof(l, e);
        END;
        IF e.next # NIL THEN
          GenStr(", ");
        END;
        e := e.next;
        formal := formal.next;
      END;
      GenStr(")");
  | AST.exprFieldRef:
      GenStr("TODO FIELD_REF");
  | AST.exprPointerDeref:
      GenStr("TODO POINTER_DEREF");
  | AST.exprArrayRef:
      GenStr("TODO ARRAY_REF");
  | AST.exprTypeGuard:
      GenStr("TODO TYPE_GUARD");
  | AST.exprBuiltin:
      GenStr("TODO BUILTIN");
  | AST.exprAssign:
      (* TODO - this isn't right becuase params are special *)
      GenExpr(l, e.lhs);
      GenStr(" = ");
      GenExpr(l, e.rhs);
  END;
END GenExpr;

PROCEDURE GenParenExpr(l :Lex.Lexer; e :AST.Expr);
BEGIN
  IF e.kind = AST.exprBinary THEN
    GenExpr(l, e);
  ELSE
    GenStr("(");
    GenExpr(l, e);
    GenStr(")");
  END;
END GenParenExpr;

PROCEDURE GenStatements(l :Lex.Lexer; s :AST.Stmt);
BEGIN
  WHILE s # NIL DO
    ASSERT(s.kind >= AST.stmtAssign);
    ASSERT(s.kind <= AST.stmtEmpty);
    GenI;
    CASE s.kind OF
      AST.stmtAssign, AST.stmtProcCall:
        GenExpr(l, s.cond);
        GenStr(";");
    | AST.stmtIf:
        GenStr("if ");
        GenParenExpr(l, s.cond);
        GenStr(" {");
        GenLn;
        INC(indent);
        GenStatements(l, s.body);
        DEC(indent);
        GenStatements(l, s.elsifs);
        GenI;
        GenStr("}");
    | AST.stmtWhile:
        GenStr("TODO WHILE");
    | AST.stmtRepeat:
        GenStr("TODO REPEAT");
    | AST.stmtFor:
        GenStr("TODO FOR");
    | AST.stmtCase:
        GenStr("TODO CASE");
    | AST.stmtCaseItem:
        GenStr("TODO CASE_ITEM");
    | AST.stmtElsIf:
        ASSERT(s.next = NIL);
        GenStr("} else if ");
        GenParenExpr(l, s.cond);
        GenStr(" {");
        GenLn;
        INC(indent);
        GenStatements(l, s.body);
        DEC(indent);
        GenStatements(l, s.elsifs);
    | AST.stmtElse:
        ASSERT(s.elsifs = NIL);
        ASSERT(s.next = NIL);
        GenStr("} else {");
        GenLn;
        INC(indent);
        GenStatements(l, s.body);
        DEC(indent);
    END;
    GenLn;
    s := s.next;
  END;
END GenStatements;

PROCEDURE GenTypedef(l :Lex.Lexer; d :AST.Decl);
BEGIN
  IF d.typ.kind # AST.typeNil THEN
    GenI;
    GenStr("typedef ");
    GenType(l, d.typ, d.qname, TRUE, FALSE);
    GenStr(";");
    GenLn;
  END;
END GenTypedef;

PROCEDURE GenVar(l :Lex.Lexer; d :AST.Decl);
BEGIN
  GenType(l, d.typ, d.qname, FALSE, FALSE);
  GenStr(";");
  GenLn;
END GenVar;

PROCEDURE GenProc(l :Lex.Lexer; d :AST.Decl);
VAR
  p :AST.Decl;
  q :AST.QName;
BEGIN
  q.moduleName := 0;
  GenType(l, d.typ, d.qname, FALSE, TRUE);
  GenStr(" {");
  GenLn;
  INC(indent);
  IF d.procVars # NIL THEN
    p := d.procVars;
    WHILE p.kind # AST.declEND DO
      q.name := p.qname.name;
      IF p.kind = AST.declVar THEN
        GenI;
        GenType(l, p.typ, q, FALSE, FALSE);
        GenStr(";");
        GenLn;
        (* TODO - Add initializers if necessary *)
      ELSIF AST.IsOpenArray(p.typ) THEN
        (* Generate code to avoid unused variable warnings *)
        GenI;
        GenStr("(void)");
        GenQName(l, q);
        GenStr("__len;");
        GenLn;
      END;
      p := p.next;
    END;
  END;
  GenStatements(l, d.body);
  IF d.expr # NIL THEN
    GenI;
    GenStr("return (");
    GenExpr(l, d.expr);
    GenStr(");");
    GenLn;
  END;
  DEC(indent);
  GenI;
  GenStr("}");
  GenLn;
END GenProc;

PROCEDURE Generate*(l :Lex.Lexer; d :AST.Decl);
BEGIN
  IF d.nesting = 0 THEN
    CASE d.kind OF
      AST.declType: GenTypedef(l, d);
    | AST.declVar: GenVar(l, d);
    | AST.declProcedure: GenProc(l, d);
    END;
  END;
END Generate;

BEGIN
  indent := 0
END CCodegen.

MODULE CCodegen;

IMPORT AST, Lex, Out;

VAR
  indent :INTEGER;

PROCEDURE GenStr(s :ARRAY OF CHAR);
BEGIN
  Out.Str(s);
END GenStr;

PROCEDURE GenInt(i :INTEGER);
BEGIN
  Out.Int(i);
END GenInt;

PROCEDURE GenLn;
BEGIN
  Out.Ln
END GenLn;

PROCEDURE GenI;
VAR
  i :INTEGER;
BEGIN
  FOR i := 1 TO indent DO GenStr("  ") END
END GenI;

PROCEDURE GenQName(l :Lex.Lexer; name :AST.QName);
BEGIN
  IF name.moduleName > 0 THEN
    Lex.OutStr(l, name.moduleName);
    GenStr("_");
  END;
  IF name.name > 0 THEN
    Lex.OutStr(l, name.name);
  END;
END GenQName;

PROCEDURE GenType(l :Lex.Lexer; t :AST.Type; name :AST.QName; skipDecl, procDecl :BOOLEAN);
VAR
  f :AST.Decl;
  q :AST.QName;
  p :AST.Type;
BEGIN
  q.moduleName := 0;
  q.name := 0;
  IF (t.decl = NIL) OR skipDecl THEN
    CASE t.kind OF
      AST.typeInteger:
        GenStr("int ");
        GenQName(l, name);
    | AST.typeReal:
        GenStr("float ");
        GenQName(l, name);
    | AST.typeBoolean:
        GenStr("bool ");
        GenQName(l, name);
    | AST.typeChar:
        GenStr("char ");
        GenQName(l, name);
    | AST.typeSet:
        GenStr("int ");
        GenQName(l, name);
    | AST.typePointer:
        IF t.base.decl = NIL THEN
          GenType(l, t.base, q, FALSE, FALSE);
        ELSE
          GenStr("struct ");
          GenQName(l, t.base.decl.qname);
        END;
        GenStr(" *");
        GenQName(l, name);
    | AST.typeArray:
        p := t;
        WHILE p.kind = AST.typeArray DO
          p := p.base;
        END;
        GenType(l, p, name, FALSE, FALSE);
        p := t;
        WHILE (p.kind = AST.typeArray) DO
          GenStr("[");
          GenInt(p.length);
          GenStr("]");
          p := p.base;
        END;
    | AST.typeRecord:
        GenStr("struct ");
        GenQName(l, name);
        GenStr(" {");
        GenLn;
        INC(indent);
        IF AST.NeedsTypeInfo(t) THEN
          GenI; GenStr("oberon typid _tid;"); GenLn;
        END;
        f := t.fields;
        WHILE (f # NIL) & (f.kind # AST.declEND) DO
          (* Drop package from field name *)
          q.name := f.qname.name;
          GenI;
          GenType(l, f.typ, q, FALSE, FALSE);
          GenStr(";");
          GenLn;
          f := f.next;
        END;
        DEC(indent);
        GenI; GenStr("} "); GenQName(l, name);
    | AST.typeProcedure:
        IF t.base.kind = AST.typeNil THEN
          GenStr("void ")
        ELSE
          GenType(l, t.base, q, FALSE, FALSE);
        END;
        IF procDecl THEN
          GenQName(l, name);
        ELSE
          GenStr(" (*");
          GenQName(l, name);
          GenStr(")");
        END;
        GenStr("(");
        IF t.fields = NIL THEN
          GenStr("void"); (* For C++, this would be empty *)
        ELSE
          f := t.fields;
          WHILE f.kind # AST.declEND DO
            t := f.typ;
            IF procDecl THEN
              q.name := f.qname.name;
            END;
            IF (t.kind IN {AST.typeRecord, AST.typeArray}) & (f.kind # AST.declVarParam) THEN
              GenStr("const ");
            END;
            IF t.kind = AST.typeRecord THEN
              q.name := 0;
              GenType(l, t, q, FALSE, FALSE);
              GenStr(" *");
              IF procDecl THEN
                q.name := f.qname.name;
                GenQName(l, q);
              END;
            ELSIF (t.kind = AST.typeRecord) OR AST.IsOpenArray(t) THEN
              q.name := 0;
              GenType(l, t.base, q, FALSE, FALSE);
              GenStr(" *");
              IF procDecl THEN
                q.name := f.qname.name;
                GenQName(l, q);
              END;
            ELSE
              GenType(l, t, q, FALSE, FALSE);
            END;
            IF AST.IsOpenArray(t) THEN
              GenStr(", size_t");
              IF procDecl THEN
                GenStr(" ");
                GenQName(l, q);
                GenStr("__len");
              END;
            END;
            IF f.next.kind # AST.declEND THEN
              GenStr(", ");
            END;
            f := f.next;
          END;
        END;
        GenStr(")");
    END;
  ELSE
    GenQName(l, t.decl.qname);
    GenStr(" ");
    GenQName(l, name);
  END;
END GenType;

PROCEDURE GenTypedef(l :Lex.Lexer; d :AST.Decl);
BEGIN
  IF d.typ.kind # AST.typeNil THEN
    GenI;
    GenStr("typedef ");
    GenType(l, d.typ, d.qname, TRUE, FALSE);
    GenStr(";");
    GenLn;
  END;
END GenTypedef;

PROCEDURE GenVar(l :Lex.Lexer; d :AST.Decl);
BEGIN
  GenType(l, d.typ, d.qname, FALSE, FALSE);
  GenStr(";");
  GenLn;
END GenVar;

PROCEDURE GenProc(l :Lex.Lexer; d :AST.Decl);
VAR
  p :AST.Decl;
  q :AST.QName;
BEGIN
  q.moduleName := 0;
  GenType(l, d.typ, d.qname, FALSE, TRUE);
  GenStr(" {");
  GenLn;
  INC(indent);
  IF d.procVars # NIL THEN
    p := d.procVars;
    WHILE p.kind # AST.declEND DO
      q.name := p.qname.name;
      IF p.kind = AST.declVar THEN
        GenI;
        GenType(l, p.typ, q, FALSE, FALSE);
        GenStr(";");
        GenLn;
        (* TODO - Add initializers if necessary *)
      ELSIF AST.IsOpenArray(p.typ) THEN
        (* Generate code to avoid unused variable warnings *)
        GenI;
        GenStr("(void)");
        GenQName(l, q);
        GenStr("__len;");
        GenLn;
      END;
      p := p.next;
    END;
  END;
  DEC(indent);
  GenI;
  GenStr("}");
  GenLn;
END GenProc;

PROCEDURE Generate*(l :Lex.Lexer; d :AST.Decl);
BEGIN
  IF d.nesting = 0 THEN
    CASE d.kind OF
      AST.declType: GenTypedef(l, d);
    | AST.declVar: GenVar(l, d);
    | AST.declProcedure: GenProc(l, d);
    END;
  END;
END Generate;

BEGIN
  indent := 0
END CCodegen.

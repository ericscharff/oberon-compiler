MODULE KnightsTour;

(*
  Produce a Knights tour by a brute force recursive descent technique. The
  board is represented as a two-dimensional array of INTEGER, where a square
  that has yet to be visited has a value of -1, otherwise the number is the
  sequence (the first visited square is 0, second is 1, and so on.

  This works for small boards and starting in the corner. On larger boards,
  this will likely work but be painfully slow.

  A knight can make eight moves, each represented in the two parallel arrays
  moveX and moveY.  For example, the second entry is 1 over and 2 down.
*)
CONST
  W = 6;
  H = 4;

VAR
  board :ARRAY H, W OF INTEGER;
  moveX, moveY :ARRAY 8 OF INTEGER;

PROCEDURE Setup;
VAR i, j :INTEGER;
BEGIN
  FOR i := 0 TO H-1 DO
    FOR j := 0 TO W-1 DO
      board[i][j] := -1
    END
  END;
  moveX[0] := 2; moveX[1] := 1; moveX[2] := -1; moveX[3] := -2;
  moveX[4] := -2; moveX[5] := -1; moveX[6] := 1; moveX[7] := 2;

  moveY[0] := 1; moveY[1] := 2; moveY[2] := 2; moveY[3] := 1;
  moveY[4] := -1; moveY[5] := -2; moveY[6] := -2; moveY[7] := -1;
END Setup;

PROCEDURE Solve(curX, curY, curMove :INTEGER) :BOOLEAN;
VAR
  done :BOOLEAN;
  move, newX, newY :INTEGER;
BEGIN
  IF curMove = W*H THEN
    done := TRUE
  ELSE
    done := FALSE;
    move := 0;
    WHILE (~done) & (move < 8) DO
      newX := curX + moveX[move];
      newY := curY + moveY[move];
      IF ((newX >= 0) & (newX < W) & (newY >= 0) & (newY < H) &
        (board[newY][newX] = -1)) THEN
        board[newY][newX] := curMove;
        IF Solve(newX, newY, curMove+1) THEN
          done := TRUE
        ELSE
          board[newY][newX] := -1
        END
      END;
      INC(move)
    END
  END;
  RETURN done
END Solve;

PROCEDURE PrintBoard;
VAR x, y :INTEGER;
BEGIN
  FOR y := 0 TO H-1 DO
    FOR x := 0 TO W-1 DO
      WriteInt(board[y, x])
    END;
    WriteLn;
  END;
END PrintBoard;

BEGIN
  Setup;
  board[0, 0] := 0;
  Solve(0, 0, 1);
  PrintBoard;
END KnightsTour.

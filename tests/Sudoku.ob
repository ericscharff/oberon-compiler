MODULE Sudoku;

(**
 * Generates valid Sudoku boards. The random number generator depends on an
 * internal table of random bits to make it self contained. Demonstrates
 * use of the SET type (to keep track of which numbers are possible for which
 * cells) as well as ARRAYs of SETs.
 *)

IMPORT Out;

VAR
  RANDOM_BYTES: ARRAY 256 OF INTEGER;
  BOXES: ARRAY 9 OF INTEGER;
  randomIdx: INTEGER;
  board: ARRAY 81 OF INTEGER;

PROCEDURE InitTables;
BEGIN
  RANDOM_BYTES[0] := 0D2H; RANDOM_BYTES[1] := 065H; RANDOM_BYTES[2] := 09EH; RANDOM_BYTES[3] := 059H;
  RANDOM_BYTES[4] := 05EH; RANDOM_BYTES[5] := 05AH; RANDOM_BYTES[6] := 02EH; RANDOM_BYTES[7] := 0A3H;
  RANDOM_BYTES[8] := 02EH; RANDOM_BYTES[9] := 0ABH; RANDOM_BYTES[10] := 0E6H; RANDOM_BYTES[11] := 021H;
  RANDOM_BYTES[12] := 00BH; RANDOM_BYTES[13] := 033H; RANDOM_BYTES[14] := 060H; RANDOM_BYTES[15] := 00CH;
  RANDOM_BYTES[16] := 068H; RANDOM_BYTES[17] := 0B7H; RANDOM_BYTES[18] := 0C9H; RANDOM_BYTES[19] := 0CCH;
  RANDOM_BYTES[20] := 076H; RANDOM_BYTES[21] := 0B3H; RANDOM_BYTES[22] := 0C8H; RANDOM_BYTES[23] := 01CH;
  RANDOM_BYTES[24] := 0FDH; RANDOM_BYTES[25] := 020H; RANDOM_BYTES[26] := 060H; RANDOM_BYTES[27] := 0A3H;
  RANDOM_BYTES[28] := 004H; RANDOM_BYTES[29] := 0EBH; RANDOM_BYTES[30] := 038H; RANDOM_BYTES[31] := 05AH;
  RANDOM_BYTES[32] := 096H; RANDOM_BYTES[33] := 0FFH; RANDOM_BYTES[34] := 048H; RANDOM_BYTES[35] := 003H;
  RANDOM_BYTES[36] := 07DH; RANDOM_BYTES[37] := 09BH; RANDOM_BYTES[38] := 0F0H; RANDOM_BYTES[39] := 0A8H;
  RANDOM_BYTES[40] := 0C4H; RANDOM_BYTES[41] := 09CH; RANDOM_BYTES[42] := 0EFH; RANDOM_BYTES[43] := 068H;
  RANDOM_BYTES[44] := 007H; RANDOM_BYTES[45] := 041H; RANDOM_BYTES[46] := 07DH; RANDOM_BYTES[47] := 09CH;
  RANDOM_BYTES[48] := 0D7H; RANDOM_BYTES[49] := 00EH; RANDOM_BYTES[50] := 0CEH; RANDOM_BYTES[51] := 086H;
  RANDOM_BYTES[52] := 025H; RANDOM_BYTES[53] := 06AH; RANDOM_BYTES[54] := 0D4H; RANDOM_BYTES[55] := 061H;
  RANDOM_BYTES[56] := 0CCH; RANDOM_BYTES[57] := 0AAH; RANDOM_BYTES[58] := 083H; RANDOM_BYTES[59] := 0FDH;
  RANDOM_BYTES[60] := 0CAH; RANDOM_BYTES[61] := 055H; RANDOM_BYTES[62] := 06BH; RANDOM_BYTES[63] := 0A6H;
  RANDOM_BYTES[64] := 08FH; RANDOM_BYTES[65] := 089H; RANDOM_BYTES[66] := 031H; RANDOM_BYTES[67] := 00AH;
  RANDOM_BYTES[68] := 01FH; RANDOM_BYTES[69] := 055H; RANDOM_BYTES[70] := 042H; RANDOM_BYTES[71] := 019H;
  RANDOM_BYTES[72] := 06AH; RANDOM_BYTES[73] := 0F4H; RANDOM_BYTES[74] := 05CH; RANDOM_BYTES[75] := 021H;
  RANDOM_BYTES[76] := 0D9H; RANDOM_BYTES[77] := 09DH; RANDOM_BYTES[78] := 099H; RANDOM_BYTES[79] := 048H;
  RANDOM_BYTES[80] := 035H; RANDOM_BYTES[81] := 036H; RANDOM_BYTES[82] := 039H; RANDOM_BYTES[83] := 0C0H;
  RANDOM_BYTES[84] := 0FAH; RANDOM_BYTES[85] := 017H; RANDOM_BYTES[86] := 013H; RANDOM_BYTES[87] := 09DH;
  RANDOM_BYTES[88] := 06BH; RANDOM_BYTES[89] := 0EFH; RANDOM_BYTES[90] := 081H; RANDOM_BYTES[91] := 035H;
  RANDOM_BYTES[92] := 0E9H; RANDOM_BYTES[93] := 05CH; RANDOM_BYTES[94] := 0FEH; RANDOM_BYTES[95] := 0D4H;
  RANDOM_BYTES[96] := 035H; RANDOM_BYTES[97] := 0E4H; RANDOM_BYTES[98] := 0A9H; RANDOM_BYTES[99] := 06EH;
  RANDOM_BYTES[100] := 04FH; RANDOM_BYTES[101] := 053H; RANDOM_BYTES[102] := 0B2H; RANDOM_BYTES[103] := 03BH;
  RANDOM_BYTES[104] := 00AH; RANDOM_BYTES[105] := 095H; RANDOM_BYTES[106] := 0F7H; RANDOM_BYTES[107] := 021H;
  RANDOM_BYTES[108] := 0D7H; RANDOM_BYTES[109] := 092H; RANDOM_BYTES[110] := 007H; RANDOM_BYTES[111] := 0CDH;
  RANDOM_BYTES[112] := 042H; RANDOM_BYTES[113] := 0D5H; RANDOM_BYTES[114] := 07FH; RANDOM_BYTES[115] := 02BH;
  RANDOM_BYTES[116] := 096H; RANDOM_BYTES[117] := 060H; RANDOM_BYTES[118] := 096H; RANDOM_BYTES[119] := 099H;
  RANDOM_BYTES[120] := 004H; RANDOM_BYTES[121] := 039H; RANDOM_BYTES[122] := 034H; RANDOM_BYTES[123] := 007H;
  RANDOM_BYTES[124] := 0A6H; RANDOM_BYTES[125] := 054H; RANDOM_BYTES[126] := 065H; RANDOM_BYTES[127] := 074H;
  RANDOM_BYTES[128] := 0A4H; RANDOM_BYTES[129] := 058H; RANDOM_BYTES[130] := 0A3H; RANDOM_BYTES[131] := 0B4H;
  RANDOM_BYTES[132] := 063H; RANDOM_BYTES[133] := 06AH; RANDOM_BYTES[134] := 01AH; RANDOM_BYTES[135] := 0BEH;
  RANDOM_BYTES[136] := 0CEH; RANDOM_BYTES[137] := 011H; RANDOM_BYTES[138] := 0C8H; RANDOM_BYTES[139] := 063H;
  RANDOM_BYTES[140] := 07DH; RANDOM_BYTES[141] := 00DH; RANDOM_BYTES[142] := 07FH; RANDOM_BYTES[143] := 03CH;
  RANDOM_BYTES[144] := 091H; RANDOM_BYTES[145] := 0B8H; RANDOM_BYTES[146] := 057H; RANDOM_BYTES[147] := 053H;
  RANDOM_BYTES[148] := 054H; RANDOM_BYTES[149] := 0F6H; RANDOM_BYTES[150] := 091H; RANDOM_BYTES[151] := 062H;
  RANDOM_BYTES[152] := 080H; RANDOM_BYTES[153] := 079H; RANDOM_BYTES[154] := 015H; RANDOM_BYTES[155] := 032H;
  RANDOM_BYTES[156] := 0B3H; RANDOM_BYTES[157] := 0EDH; RANDOM_BYTES[158] := 099H; RANDOM_BYTES[159] := 093H;
  RANDOM_BYTES[160] := 0B8H; RANDOM_BYTES[161] := 003H; RANDOM_BYTES[162] := 0CBH; RANDOM_BYTES[163] := 008H;
  RANDOM_BYTES[164] := 042H; RANDOM_BYTES[165] := 05EH; RANDOM_BYTES[166] := 02BH; RANDOM_BYTES[167] := 03CH;
  RANDOM_BYTES[168] := 05CH; RANDOM_BYTES[169] := 0D7H; RANDOM_BYTES[170] := 062H; RANDOM_BYTES[171] := 08FH;
  RANDOM_BYTES[172] := 015H; RANDOM_BYTES[173] := 0BEH; RANDOM_BYTES[174] := 0C1H; RANDOM_BYTES[175] := 01DH;
  RANDOM_BYTES[176] := 08EH; RANDOM_BYTES[177] := 0BAH; RANDOM_BYTES[178] := 0FAH; RANDOM_BYTES[179] := 010H;
  RANDOM_BYTES[180] := 0FAH; RANDOM_BYTES[181] := 067H; RANDOM_BYTES[182] := 0D5H; RANDOM_BYTES[183] := 04DH;
  RANDOM_BYTES[184] := 023H; RANDOM_BYTES[185] := 02AH; RANDOM_BYTES[186] := 057H; RANDOM_BYTES[187] := 0F1H;
  RANDOM_BYTES[188] := 057H; RANDOM_BYTES[189] := 01AH; RANDOM_BYTES[190] := 040H; RANDOM_BYTES[191] := 0B2H;
  RANDOM_BYTES[192] := 044H; RANDOM_BYTES[193] := 0E7H; RANDOM_BYTES[194] := 0CBH; RANDOM_BYTES[195] := 0C2H;
  RANDOM_BYTES[196] := 086H; RANDOM_BYTES[197] := 05BH; RANDOM_BYTES[198] := 01AH; RANDOM_BYTES[199] := 07AH;
  RANDOM_BYTES[200] := 0F6H; RANDOM_BYTES[201] := 0F6H; RANDOM_BYTES[202] := 072H; RANDOM_BYTES[203] := 002H;
  RANDOM_BYTES[204] := 03CH; RANDOM_BYTES[205] := 01CH; RANDOM_BYTES[206] := 0A4H; RANDOM_BYTES[207] := 0AEH;
  RANDOM_BYTES[208] := 05DH; RANDOM_BYTES[209] := 0B6H; RANDOM_BYTES[210] := 000H; RANDOM_BYTES[211] := 0D7H;
  RANDOM_BYTES[212] := 062H; RANDOM_BYTES[213] := 009H; RANDOM_BYTES[214] := 04FH; RANDOM_BYTES[215] := 0C1H;
  RANDOM_BYTES[216] := 0CDH; RANDOM_BYTES[217] := 063H; RANDOM_BYTES[218] := 061H; RANDOM_BYTES[219] := 026H;
  RANDOM_BYTES[220] := 047H; RANDOM_BYTES[221] := 0F7H; RANDOM_BYTES[222] := 060H; RANDOM_BYTES[223] := 072H;
  RANDOM_BYTES[224] := 00FH; RANDOM_BYTES[225] := 01EH; RANDOM_BYTES[226] := 0A2H; RANDOM_BYTES[227] := 0F2H;
  RANDOM_BYTES[228] := 087H; RANDOM_BYTES[229] := 0A3H; RANDOM_BYTES[230] := 087H; RANDOM_BYTES[231] := 008H;
  RANDOM_BYTES[232] := 062H; RANDOM_BYTES[233] := 0DDH; RANDOM_BYTES[234] := 065H; RANDOM_BYTES[235] := 0CBH;
  RANDOM_BYTES[236] := 034H; RANDOM_BYTES[237] := 0CBH; RANDOM_BYTES[238] := 0D3H; RANDOM_BYTES[239] := 0D0H;
  RANDOM_BYTES[240] := 037H; RANDOM_BYTES[241] := 002H; RANDOM_BYTES[242] := 010H; RANDOM_BYTES[243] := 067H;
  RANDOM_BYTES[244] := 0DEH; RANDOM_BYTES[245] := 0D0H; RANDOM_BYTES[246] := 06EH; RANDOM_BYTES[247] := 07FH;
  RANDOM_BYTES[248] := 043H; RANDOM_BYTES[249] := 0F4H; RANDOM_BYTES[250] := 067H; RANDOM_BYTES[251] := 05BH;
  RANDOM_BYTES[252] := 09EH; RANDOM_BYTES[253] := 0CBH; RANDOM_BYTES[254] := 0EEH; RANDOM_BYTES[255] := 0A0H;

  BOXES[0] := 0;
  BOXES[1] := 3;
  BOXES[2] := 6;
  BOXES[3] := 27;
  BOXES[4] := 30;
  BOXES[5] := 33;
  BOXES[6] := 54;
  BOXES[7] := 57;
  BOXES[8] := 60;
END InitTables;

PROCEDURE ValidRowOrColumn(start, stride: INTEGER): BOOLEAN;
  (* Determine if a row (or column only has the digits 1..9.   *)
  (* start is the starting board cell to search. Stride is 1   *)
  (* to search the next cell (row), or 9 for searchng columns. *)
VAR
  used: SET;
  idx, i, b: INTEGER;
BEGIN
  idx := start;
  used := {};
  FOR i := 0 TO 8 DO
    b := board[idx];
    idx := idx + stride;
    IF (b # 0) & (b IN used) THEN
      (* already used, done *)
      RETURN FALSE
    ELSE
      used := used + {b};
    END
  END
  RETURN TRUE
END ValidRowOrColumn;

PROCEDURE ValidBox(start: INTEGER): BOOLEAN;
VAR
  used: SET;
  i, j, b: INTEGER;
BEGIN
  used := {};
  FOR i := 0 TO 2 DO
    FOR j := 0 TO 2 DO
      b := board[start + i*9 + j];
      IF (b # 0) & (b in used) THEN
        RETURN FALSE
      ELSE
        used := used + {b}
      END
    END
  END
  RETURN TRUE
END ValidBox;

PROCEDURE Valid():BOOLEAN;
VAR
  i: INTEGER;
BEGIN
  (* Non local return would be helpful here *)
  FOR i := 0 TO 8 DO
    IF ~ValidRowOrColumn(i*9, 1) THEN RETURN FALSE END;
    IF ~ValidRowOrColumn(i, 9) THEN RETURN FALSE END;
    IF ~ValidBox(BOXES[i]) THEN RETURN FALSE END;
  END;
  RETURN TRUE
END Valid;

PROCEDURE NumberOfOneBits(s: SET): INTEGER;
(* Counts 1 bits in a set. Note that because Sudoku only needs the *)
(* number 1..9, those aree the only ones checked. *)
VAR
  a, i: INTEGER;
BEGIN
  a := 0;
  FOR i := 1 TO 9 DO
    IF i in s THEN INC(a) END
  END
  RETURN a
END NumberOfOneBits;

PROCEDURE RandomInt(max: INTEGER): INTEGER;
  (* return [0, max) *)
VAR
  r: INTEGER;
BEGIN
  REPEAT
    r := RANDOM_BYTES[randomIdx] BITAND 0FH;
    randomIdx := (randomIdx + 1) BITAND 0FFH;
  UNTIL r < max
  RETURN r
END RandomInt;

PROCEDURE NthSetBit(s: SET; n: INTEGER): INTEGER;
(* Returns the index of the nth slement of s that is set. *)
VAR elt: INTEGER;
BEGIN
  elt := -1;
  WHILE n > 0 DO
    INC(elt);
    IF elt in s THEN DEC(n) END;
  END
  RETURN elt
END NthSetBit;

PROCEDURE RandomEltFromCandidates(candidates: SET): INTEGER;
VAR n, r: INTEGER;
BEGIN
  n := NumberOfOneBits(candidates);
  r := RandomInt(n) + 1;
  RETURN NthSetBit(candidates, r)
END RandomEltFromCandidates;

PROCEDURE MakeBoard;
VAR
  i: INTEGER;
  e: INTEGER;
  stk: ARRAY 81 OF SET;
  stkTop: INTEGER;
  candidates: SET;
  c: INTEGER;
BEGIN
  FOR i := 0 TO 80 DO board[i] := 0 END;
  e := 0;
  stkTop := 0;
  candidates := { 1 .. 9 };
  WHILE (e < 81) & (candidates # {}) DO
    c := RandomEltFromCandidates(candidates);
    candidates := candidates - {c};
    board[e] := c;
    IF Valid() THEN
      INC(e);
      IF e < 81 THEN
        stk[stkTop] := candidates;
        INC(stkTop);
        candidates := {1 .. 9}
      END
    END;
    WHILE candidates = {} DO
      (* Backtrack *)
      board[e] := 0;
      DEC(e);
      DEC(stkTop);
      candidates := stk[stkTop]
    END
  END
END MakeBoard;

PROCEDURE PrintBoard;
VAR
  i, j: INTEGER;
BEGIN
  FOR i := 0 TO 8 DO
    FOR j := 0 TO 8 DO
      Out.Int(board[i*9+j]); Out.Char(" ");
      IF (j = 2) OR (j = 5) THEN Out.Str("| ") END;
    END;
    Out.Ln;
    IF (i = 2) OR (i = 5) THEN
      Out.Str("------+-------+-------");
      Out.Ln
    END;
  END
END PrintBoard;

BEGIN
  InitTables;
  MakeBoard;
  PrintBoard;
END Sudoku.

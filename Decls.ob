MODULE Decls;

IMPORT AST, Lex;

CONST
  stateUnresolved = 0;
  stateResolving  = 1;
  stateResolved   = 2;

TYPE
  StringId  = Lex.PoolIndex;
  Forward   = POINTER TO FwdDecl;
  FwdDecl   = RECORD
    t    :AST.Type;
    next :Forward;
  END;

VAR
  nilType*, integerType*, realType*, booleanType*,
    charType*, setType*, stringType* :AST.Type;
  modInitName :StringId;
  scope, globalScope :AST.Decl;
  fwds  :Forward;
  VisitDecl* :PROCEDURE (d :AST.Decl);

PROCEDURE LookupDecl0(name :StringId) :AST.Decl;
VAR
  p :AST.Decl;
BEGIN
  p := scope;
  WHILE (p # NIL) & (p.qname.name # name) DO
    p := p.next;
  END;
  RETURN p
END LookupDecl0;

PROCEDURE LookupDecl*(l :Lex.Lexer; name :StringId) :AST.Decl;
VAR
  p :AST.Decl;
BEGIN
  p := LookupDecl0(name);
  IF p = NIL THEN
    Lex.Error(l, "");
    Lex.OutStr(l, name);
    Lex.PrintLn(" undefined");
  END;
  RETURN p
END LookupDecl;

PROCEDURE LookupImport*(l :Lex.Lexer; moduleName, name :StringId) :AST.Decl;
VAR
  p, d :AST.Decl;
BEGIN
  d := LookupDecl(l, moduleName);
  ASSERT(d.kind = AST.declImport);
  p := d.typ.fields;
  WHILE (p # NIL) & (p.qname.name # name) DO
    p := p.next;
  END;
  IF p = NIL THEN
    Lex.Error(l, "");
    Lex.OutStr(l, moduleName);
    Lex.Str(".");
    Lex.OutStr(l, name);
    Lex.PrintLn(" undefined");
  ELSIF ~p.exported THEN
    Lex.Error(l, "");
    Lex.OutStr(l, moduleName);
    Lex.Str(".");
    Lex.OutStr(l, name);
    Lex.PrintLn(" is not exported");
  END;
  RETURN p
END LookupImport;

PROCEDURE NewDecl(VAR d :AST.Decl; name :StringId);
BEGIN
  NEW(d);
  d.qname.name := name;
  d.qname.moduleName := AST.currentModuleName;
  d.kind := 0;
  d.typ := NIL;
  d.expr := NIL;
  d.body := NIL;
  d.next := NIL;
  d.exported := FALSE;
  d.state := stateUnresolved;
END NewDecl;

PROCEDURE AddDecl*(l :Lex.Lexer; VAR chain :AST.Decl; name :StringId) :AST.Decl;
VAR
  p, d :AST.Decl;
BEGIN
  NewDecl(d, name);
  IF chain = NIL THEN
    NewDecl(chain, 0);
    chain.kind := AST.declEND;
  END;
  IF chain.kind = AST.declEND THEN
    d.next := chain;
    chain := d;
  ELSE
    p := chain;
    WHILE (p.next.kind # AST.declEND) & (p.qname.name # name) DO
      p := p.next;
    END;
    IF p.qname.name = name THEN
      Lex.Error(l, "");
      Lex.OutStr(l, name);
      Lex.PrintLn(" already defined");
    ELSE
      d.next := p.next;
      p.next := d;
    END;
  END;
  RETURN d
END AddDecl;

PROCEDURE AddScopeDecl*(l :Lex.Lexer; name :StringId) :AST.Decl;
BEGIN
  RETURN AddDecl(l, scope, name)
END AddScopeDecl;

PROCEDURE NewType(VAR t :AST.Type; kind :AST.TypeKind);
BEGIN
  NEW(t);
  t.kind := kind;
  t.base := NIL;
  t.fields := NIL;
  t.length := 0;
  t.needTypeInfo := FALSE;
  t.decl := NIL;
  t.reachable := FALSE;
END NewType;

PROCEDURE AddImportDecl*(l :Lex.Lexer; name :StringId; decls :AST.Decl);
VAR
  d :AST.Decl;
BEGIN
  d := AddScopeDecl(l, name);
  d.kind := AST.declImport;
  NewType(d.typ, AST.typeImport);
  d.typ.fields := decls;
END AddImportDecl;

PROCEDURE NewArrayType*(l :Lex.Lexer; length :AST.Expr) :AST.Type;
VAR
  t :AST.Type;
BEGIN
  NewType(t, AST.typeArray);
  IF AST.IsConst(length) & (length.typ.kind = AST.typeInteger) THEN
    t.length := length.iVal;
  ELSE
    Lex.ErrorLn(l, "ARRAY length must be a CONST INTEGER");
  END;
  RETURN t
END NewArrayType;

PROCEDURE NewPointerType*(l :Lex.Lexer; base :AST.Type) :AST.Type;
VAR
  t :AST.Type;
BEGIN
  t := NIL;
  IF (base # NIL) & (base.kind # AST.typeRecord) THEN
    Lex.ErrorLn(l, "Pointer base type must be a RECORD");
  ELSE
    NewType(t, AST.typePointer);
    t.base := base;
  END;
  RETURN t
END NewPointerType;

PROCEDURE NewPointerTypeByName*(l :Lex.Lexer; name :StringId) :AST.Type;
VAR
  d :AST.Decl;
  f :Forward;
  t :AST.Type;
BEGIN
  t := NIL;
  d := LookupDecl0(name);
  IF d = NIL THEN
    (* forward decl *)
    NewType(t, AST.typePointer);
    NewDecl(t.fields, name);
    NEW(f);
    f.t := t;
    f.next := fwds;
    fwds := f;
  ELSE
    IF d.kind # AST.declType THEN
      Lex.Error(l, "");
      Lex.OutStr(l, d.qname.name);
      Lex.PrintLn(" is not a TYPE");
    END;
    t := NewPointerType(l, d.typ);
  END;
  RETURN t
END NewPointerTypeByName;

PROCEDURE NewProcedureType*() :AST.Type;
VAR
  t :AST.Type;
BEGIN
  NewType(t, AST.typeProcedure);
  RETURN t
END NewProcedureType;

PROCEDURE CountProcedureArgs*(t :AST.Type);
VAR
  i :INTEGER;
  p :AST.Decl;
BEGIN
  i := 0;
  p := t.fields;
  WHILE (p # NIL) & (p.kind # AST.declEND) DO
    INC(i);
    p := p.next;
  END;
  t.length := i;
END CountProcedureArgs;

PROCEDURE NewRecordType*(l :Lex.Lexer; base :AST.Type) :AST.Type;
VAR
  t        :AST.Type;
  d, dCopy :AST.Decl;
BEGIN
  NewType(t, AST.typeRecord);
  t.base := base;
  IF base # NIL THEN
    IF base.kind = AST.typeRecord THEN
      (* Copy fields from base *)
      d := base.fields;
      WHILE (d # NIL) & (d.kind # AST.declEND) DO
        dCopy := AddDecl(l, t.fields, d.qname.name);
        dCopy.kind := d.kind;
        dCopy.typ := d.typ;
        dCopy.exported := d.exported;
        d := d.next;
      END;
    ELSE
      Lex.ErrorLn(l, "RECORD base type is not a RECORD");
    END;
  END;
  RETURN t
END NewRecordType;

PROCEDURE NewModuleInitDecl*(body :AST.Stmt);
VAR
  d :AST.Decl;
BEGIN
  NewDecl(d, modInitName);
  d.kind := AST.declProcedure;
  d.typ := NewProcedureType();
  d.body := body;
  d.next := scope;
  scope := d;
END NewModuleInitDecl;

PROCEDURE AddTypeDecl(VAR l :Lex.Lexer; name :StringId; t :AST.Type);
VAR
  d :AST.Decl;
BEGIN
  d := AddDecl(l, scope, name);
  d.kind := AST.declType;
  d.typ := t;
  IF d.typ.decl = NIL THEN d.typ.decl := d END;
END AddTypeDecl;

PROCEDURE AddBuiltin(VAR l :Lex.Lexer; name :StringId; callback :AST.BuiltinResolver);
VAR
  d :AST.Decl;
BEGIN
  d := AddDecl(l, scope, name);
  d.kind := AST.declBuiltin;
  d.typ := nilType;
  d.resolver := callback;
END AddBuiltin;

(* Native procedure declarations. Lowercase names because they are private callbacks *)
PROCEDURE builtinAbs(l :Lex.Lexer; args :AST.Expr) :AST.Expr;
VAR
  e :AST.Expr;
BEGIN
  AST.NewExpr(e, AST.exprBuiltin, nilType);
  IF (args = NIL) OR (args.next # NIL) THEN
    Lex.ErrorLn(l, "ABS expects 1 argument");
  END;
  IF args.typ.kind IN {AST.typeInteger, AST.typeReal} THEN
    e.typ := args.typ;
  ELSE
    Lex.ErrorLn(l, "ABS expects INTEGER or REAL");
  END;
  RETURN e
END builtinAbs;

PROCEDURE builtinInc(l :Lex.Lexer; args :AST.Expr) :AST.Expr;
VAR
  e :AST.Expr;
BEGIN
  AST.NewExpr(e, AST.exprBuiltin, nilType);
  IF (args = NIL) OR ((args.next # NIL) & (args.next.next # NIL)) THEN
    Lex.ErrorLn(l, "INC/DEC expects 1 or 2 arguments");
  END;
  IF ~args.assignable THEN
    Lex.ErrorLn(l, "First argument to INC/DEC must be assignable");
  END;
  IF (args.next # NIL) & (args.next.typ.kind # AST.typeInteger) THEN
    Lex.ErrorLn(l, "Second arg to INC/DEC must be an INTEGER");
  END;
  RETURN e
END builtinInc;

PROCEDURE builtinAssert(l :Lex.Lexer; args :AST.Expr) :AST.Expr;
VAR
  e :AST.Expr;
BEGIN
  AST.NewExpr(e, AST.exprBuiltin, nilType);
  IF (args = NIL) OR (args.next # NIL) THEN
    Lex.ErrorLn(l, "ASSERT expects 1 argument");
  END;
  IF args.typ.kind = AST.typeBoolean THEN
    e.typ := args.typ;
  ELSE
    Lex.ErrorLn(l, "ASSERT expects a BOOLEAN");
  END;
  RETURN e
END builtinAssert;

PROCEDURE builtinOrd(l :Lex.Lexer; args :AST.Expr) :AST.Expr;
VAR
  e :AST.Expr;
BEGIN
  AST.NewExpr(e, AST.exprBuiltin, nilType);
  IF (args = NIL) OR (args.next # NIL) THEN
    Lex.ErrorLn(l, "ORD expects 1 argument");
  END;
  IF (args.typ.kind IN {AST.typeSet, AST.typeChar, AST.typeBoolean}) OR
     ((args.typ.kind = AST.typeString) & Lex.IsOneChar(l, args.iVal)) THEN
    e.typ := integerType;
  ELSE
    Lex.ErrorLn(l, "ORD expects CHAR, BOOLEAN, or SET");
  END;
  RETURN e
END builtinOrd;

PROCEDURE builtinChr(l :Lex.Lexer; args :AST.Expr) :AST.Expr;
VAR
  e :AST.Expr;
BEGIN
  AST.NewExpr(e, AST.exprBuiltin, nilType);
  IF (args = NIL) OR (args.next # NIL) THEN
    Lex.ErrorLn(l, "CHR expects 1 argument");
  END;
  IF args.typ.kind = AST.typeInteger THEN
    e.typ := charType;
  ELSE
    Lex.ErrorLn(l, "CHR expects an INTEGER");
  END;
  RETURN e
END builtinChr;

PROCEDURE builtinFlt(l :Lex.Lexer; args :AST.Expr) :AST.Expr;
VAR
  e :AST.Expr;
BEGIN
  AST.NewExpr(e, AST.exprBuiltin, nilType);
  IF (args = NIL) OR (args.next # NIL) THEN
    Lex.ErrorLn(l, "FLT expects 1 argument");
  END;
  IF args.typ.kind = AST.typeInteger THEN
    e.typ := realType;
  ELSE
    Lex.ErrorLn(l, "FLT expects an INTEGER");
  END;
  RETURN e
END builtinFlt;

PROCEDURE builtinNew(l :Lex.Lexer; args :AST.Expr) :AST.Expr;
VAR
  e :AST.Expr;
BEGIN
  AST.NewExpr(e, AST.exprBuiltin, nilType);
  IF (args = NIL) OR (args.next # NIL) THEN
    Lex.ErrorLn(l, "NEW expects 1 argument");
  END;
  IF ~args.assignable THEN
    Lex.ErrorLn(l, "First argument to NEW must be assignable");
  END;
  IF args.typ.kind = AST.typePointer THEN
    e.typ := args.typ;
  ELSE
    Lex.ErrorLn(l, "NEW expects a POINTER");
  END;
  RETURN e
END builtinNew;

PROCEDURE InitGlobalScope*(VAR l :Lex.Lexer);
BEGIN
  fwds := NIL;
  IF globalScope = NIL THEN
    scope := NIL;
    NewType(nilType, AST.typeNil);
    AddTypeDecl(l, Lex.Intern(l, "NIL"), nilType);
    NewType(integerType, AST.typeInteger);
    AddTypeDecl(l, Lex.Intern(l, "INTEGER"), integerType);
    AddTypeDecl(l, Lex.Intern(l, "BYTE"), integerType);
    NewType(realType, AST.typeReal);
    AddTypeDecl(l, Lex.Intern(l, "REAL"), realType);
    NewType(booleanType, AST.typeBoolean);
    AddTypeDecl(l, Lex.Intern(l, "BOOLEAN"), booleanType);
    NewType(charType, AST.typeChar);
    AddTypeDecl(l, Lex.Intern(l, "CHAR"), charType);
    NewType(setType, AST.typeSet);
    AddTypeDecl(l, Lex.Intern(l, "SET"), setType);
    NewType(stringType, AST.typeString);
    (* Builins *)
    AddBuiltin(l, Lex.Intern(l, "ABS"), builtinAbs);
    AddBuiltin(l, Lex.Intern(l, "INC"), builtinInc);
    AddBuiltin(l, Lex.Intern(l, "DEC"), builtinInc);
    AddBuiltin(l, Lex.Intern(l, "ASSERT"), builtinAssert);
    AddBuiltin(l, Lex.Intern(l, "ORD"), builtinOrd);
    AddBuiltin(l, Lex.Intern(l, "CHR"), builtinChr);
    AddBuiltin(l, Lex.Intern(l, "FLT"), builtinFlt);
    AddBuiltin(l, Lex.Intern(l, "NEW"), builtinNew);
    globalScope := scope;
    (* Special MODULE init function *)
    modInitName := Lex.Intern(l, "_module_init_");
  END;
  scope := globalScope;
END InitGlobalScope;

PROCEDURE ResolveForwards*(l :Lex.Lexer);
VAR
  d :AST.Decl;
BEGIN
  WHILE fwds # NIL DO
    ASSERT(fwds.t.kind = AST.typePointer);
    d := LookupDecl(l, fwds.t.fields.qname.name);
    IF (d # NIL) & (d.kind = AST.declType) & (d.typ.kind = AST.typeRecord) THEN
      fwds.t.base := d.typ;
      fwds.t.fields := NIL;
    ELSE
      Lex.Error(l, "Bad forward declaration ");
      Lex.OutStr(l, fwds.t.fields.qname.name);
      Lex.Ln;
    END;
    fwds := fwds.next;
  END;
END ResolveForwards;

PROCEDURE AddFormalParamsToScope*(l :Lex.Lexer; procDecl :AST.Decl);
VAR
  formal, actual :AST.Decl;
BEGIN
  ASSERT(procDecl.kind = AST.declProcedure);
  ASSERT(procDecl.typ.kind = AST.typeProcedure);
  formal := procDecl.typ.fields;
  WHILE formal # NIL DO
    actual := AddScopeDecl(l, formal.qname.name);
    actual.kind := formal.kind;
    actual.typ := formal.typ;
    formal := formal.next;
  END;
END AddFormalParamsToScope;

PROCEDURE CurrentScope*(): AST.Decl;
BEGIN
  RETURN scope
END CurrentScope;

PROCEDURE OpenScope*() :AST.Decl;
VAR
  d, oldScope :AST.Decl;
BEGIN
  NewDecl(d, 0);
  d.kind := AST.declEND;
  d.next := scope;
  oldScope := scope;
  scope := d;
  RETURN oldScope
END OpenScope;

PROCEDURE CloseScope*(s :AST.Decl);
BEGIN
  scope := s;
END CloseScope;

PROCEDURE VisitType(t :AST.Type);
VAR
  f :AST.Decl;
BEGIN
  IF (t # NIL) & ~t.reachable THEN
    t.reachable := TRUE;
    VisitType(t.base);
    f := t.fields;
    WHILE (f # NIL) & (f.kind # AST.declEND) DO
      VisitType(f.typ);
      f := f.next;
    END;
    IF t.decl # NIL THEN VisitDecl(t.decl); END;
  END;
END VisitType;

PROCEDURE VisitExpr(e :AST.Expr);
BEGIN
  WHILE e # NIL DO
    VisitExpr(e.lhs);
    VisitExpr(e.rhs);
    VisitType(e.typ);
    IF e.decl # NIL THEN VisitDecl(e.decl); END;
    e := e.next;
  END;
END VisitExpr;

PROCEDURE VisitStatement(s :AST.Stmt);
BEGIN
  WHILE s # NIL DO
    VisitExpr(s.cond);
    VisitStatement(s.body);
    VisitStatement(s.elsifs);
    s := s.next;
  END;
END VisitStatement;

PROCEDURE VisitDecl0(d :AST.Decl);
VAR
  i :INTEGER;
  p :AST.Decl;
BEGIN
  IF d.state = stateUnresolved THEN
    d.state := stateResolving;
    IF d.qname.name = modInitName THEN
      (* MODULE inits are a bit special, they are followed by any dels *)
      (* that have been imported by the MODULE. Resolve these first.   *)
      p := d.next;
      WHILE p.kind # AST.declEND DO
        IF p.kind = AST.declImport THEN
          VisitDecl(p.typ.fields);
        END;
        p := p.next;
      END;
    END;
    VisitType(d.typ);
    VisitStatement(d.body);
    d.state := stateResolved;
  ELSIF d.state = stateResolving THEN
    IF d.kind # AST.declProcedure THEN
      (* Circular reference *)
      ASSERT(FALSE);
    END;
  ELSE
    ASSERT(d.state = stateResolved);
  END;
END VisitDecl0;

PROCEDURE TestCleanup*;
BEGIN
  scope := NIL;
  globalScope := NIL;
END TestCleanup;

PROCEDURE TestDecls;
VAR
  l :Lex.Lexer;
  d :AST.Decl;
  t :AST.Type;
BEGIN
  Lex.LexerInitFromString(l, "");
  d := NIL;
  AddDecl(l, d, 10);
  AddDecl(l, d, 20);
  AddDecl(l, d, 30);
  AddDecl(l, d, 40);
  (* Expected error cases *)
  Lex.Mute;
  AddDecl(l, d, 10);
  AddDecl(l, d, 20);
  AddDecl(l, d, 30);
  AddDecl(l, d, 40);
  scope := d;
  ASSERT(LookupDecl(l, 20) # NIL);
  ASSERT(LookupDecl(l, 100) = NIL);
  Lex.Unmute;
  InitGlobalScope(l);
  ASSERT(LookupDecl(l, Lex.Intern(l, "NIL")) # NIL);
  d := LookupDecl(l, Lex.Intern(l, "NIL"));
  ASSERT(d.kind = AST.declType);
  ASSERT(d.typ.kind = AST.typeNil);
  d := LookupDecl(l, Lex.Intern(l, "INTEGER"));
  ASSERT(d.kind = AST.declType);
  t := d.typ;
  d := LookupDecl(l, Lex.Intern(l, "BYTE"));
  ASSERT(t = d.typ);
  TestCleanup;
  Lex.InfoPrintLn("PASS: Decls test");
END TestDecls;

BEGIN
  VisitDecl := VisitDecl0;
  globalScope := NIL;
  TestDecls
END Decls.

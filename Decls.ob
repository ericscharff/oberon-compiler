MODULE Decls;

IMPORT AST, Lex, Out;

TYPE
  StringId  = Lex.PoolIndex;
  Forward   = POINTER TO FwdDecl;
  FwdDecl   = RECORD
    t    :AST.Type;
    next :Forward;
  END;

VAR
  scope, globalScope :AST.Decl;
  fwds  :Forward;

PROCEDURE LookupDecl0(name :StringId) :AST.Decl;
VAR
  p :AST.Decl;
BEGIN
  p := scope;
  WHILE (p # NIL) & (p.name # name) DO
    p := p.next;
  END;
  RETURN p
END LookupDecl0;

PROCEDURE LookupDecl*(l :Lex.Lexer; name :StringId) :AST.Decl;
VAR
  p :AST.Decl;
BEGIN
  p := LookupDecl0(name);
  IF p = NIL THEN
    Lex.Error(l, "");
    Lex.OutStr(l, name);
    Out.PrintLn(" undefined");
  END;
  RETURN p
END LookupDecl;

PROCEDURE LookupImport*(l :Lex.Lexer; moduleName, name :StringId) :AST.Decl;
VAR
  p, d :AST.Decl;
BEGIN
  d := LookupDecl(l, moduleName);
  ASSERT(d.kind = AST.declImport);
  p := d.typ.fields;
  WHILE (p # NIL) & (p.name # name) DO
    p := p.next;
  END;
  IF p = NIL THEN
    Lex.Error(l, "");
    Lex.OutStr(l, moduleName);
    Out.Str(".");
    Lex.OutStr(l, name);
    Out.PrintLn(" undefined");
  ELSIF ~p.exported THEN
    Lex.Error(l, "");
    Lex.OutStr(l, moduleName);
    Out.Str(".");
    Lex.OutStr(l, name);
    Out.PrintLn(" is not exported");
  END;
  RETURN p
END LookupImport;

PROCEDURE AddDecl*(l :Lex.Lexer; VAR chain :AST.Decl; name :StringId) :AST.Decl;
VAR
  p, d :AST.Decl;
BEGIN
  NEW(d);
  d.name := name;
  d.kind := 0;
  d.typ := NIL;
  d.next := NIL;
  d.exported := FALSE;
  IF chain = NIL THEN NEW(chain);
    chain.kind := AST.declEND;
    chain.name := 0;
    chain.next := NIL;
  END;
  IF chain.kind = AST.declEND THEN
    d.next := chain;
    chain := d;
  ELSE
    p := chain;
    WHILE (p.next.kind # AST.declEND) & (p.name # name) DO
      p := p.next;
    END;
    IF p.name = name THEN
      Lex.Error(l, "");
      Lex.OutStr(l, name);
      Out.PrintLn(" already defined");
    ELSE
      d.next := p.next;
      p.next := d;
    END;
  END;
  RETURN d
END AddDecl;

PROCEDURE AddScopeDecl*(l :Lex.Lexer; name :StringId) :AST.Decl;
BEGIN
  RETURN AddDecl(l, scope, name)
END AddScopeDecl;

PROCEDURE NewType(VAR t :AST.Type; kind :AST.TypeKind);
BEGIN
  NEW(t);
  t.kind := kind;
  t.base := NIL;
  t.fields := NIL;
END NewType;

PROCEDURE AddImportDecl*(l :Lex.Lexer; name :StringId; decls :AST.Decl);
VAR
  d :AST.Decl;
BEGIN
  d := AddScopeDecl(l, name);
  d.kind := AST.declImport;
  NewType(d.typ, AST.typeImport);
  d.typ.fields := decls;
END AddImportDecl;

PROCEDURE NewArrayType*(base :AST.Type) :AST.Type;
VAR
  t :AST.Type;
BEGIN
  NewType(t, AST.typeArray);
  t.base := base;
  RETURN t
END NewArrayType;

PROCEDURE NewPointerType*(l :Lex.Lexer; base :AST.Type) :AST.Type;
VAR
  t :AST.Type;
BEGIN
  t := NIL;
  IF (base # NIL) & (base.kind # AST.typeRecord) THEN
    Lex.ErrorLn(l, "Pointer base type must be a RECORD");
  ELSE
    NewType(t, AST.typePointer);
    t.base := base;
  END;
  RETURN t
END NewPointerType;

PROCEDURE NewPointerTypeByName*(l :Lex.Lexer; name :StringId) :AST.Type;
VAR
  d :AST.Decl;
  f :Forward;
  t :AST.Type;
BEGIN
  t := NIL;
  d := LookupDecl0(name);
  IF d = NIL THEN
    (* forward decl *)
    NewType(t, AST.typePointer);
    NEW(t.fields);
    t.fields.name := name;
    t.fields.next := NIL;
    NEW(f);
    f.t := t;
    f.next := fwds;
    fwds := f;
  ELSE
    IF d.kind # AST.declType THEN
      Lex.Error(l, "");
      Lex.OutStr(l, d.name);
      Out.PrintLn(" is not a TYPE");
    END;
    t := NewPointerType(l, d.typ);
  END;
  RETURN t
END NewPointerTypeByName;

PROCEDURE NewProcedureType*() :AST.Type;
VAR
  t :AST.Type;
BEGIN
  NewType(t, AST.typeProcedure);
  RETURN t
END NewProcedureType;

PROCEDURE NewRecordType*(l :Lex.Lexer; base :AST.Type) :AST.Type;
VAR
  t        :AST.Type;
  d, dCopy :AST.Decl;
BEGIN
  NewType(t, AST.typeRecord);
  t.base := base;
  IF base # NIL THEN
    IF base.kind = AST.typeRecord THEN
      (* Copy fields from base *)
      d := base.fields;
      WHILE (d # NIL) & (d.kind # AST.declEND) DO
        dCopy := AddDecl(l, t.fields, d.name);
	dCopy.kind := d.kind;
	dCopy.typ := d.typ;
	dCopy.exported := d.exported;
	d := d.next;
      END;
    ELSE
      Lex.ErrorLn(l, "RECORD base type is not a RECORD");
    END;
  END;
  RETURN t
END NewRecordType;

PROCEDURE AddTypeDecl(VAR l :Lex.Lexer; name :StringId; t :AST.Type);
VAR
  d :AST.Decl;
BEGIN
  d := AddDecl(l, scope, name);
  d.kind := AST.declType;
  d.typ := t;
END AddTypeDecl;

PROCEDURE InitGlobalScope*(VAR l :Lex.Lexer);
VAR
  t :AST.Type;
BEGIN
  fwds := NIL;
  IF globalScope = NIL THEN
    scope := NIL;
    NewType(t, AST.typeNil);
    AddTypeDecl(l, Lex.Intern(l, "NIL"), t);
    NewType(t, AST.typeInteger);
    AddTypeDecl(l, Lex.Intern(l, "INTEGER"), t);
    AddTypeDecl(l, Lex.Intern(l, "BYTE"), t);
    NewType(t, AST.typeReal);
    AddTypeDecl(l, Lex.Intern(l, "REAL"), t);
    NewType(t, AST.typeBoolean);
    AddTypeDecl(l, Lex.Intern(l, "BOOLEAN"), t);
    NewType(t, AST.typeChar);
    AddTypeDecl(l, Lex.Intern(l, "CHAR"), t);
    NewType(t, AST.typeSet);
    AddTypeDecl(l, Lex.Intern(l, "SET"), t);
    (* stuff to fix *)
    AddTypeDecl(l, Lex.Intern(l, "INC"), t);
    AddTypeDecl(l, Lex.Intern(l, "DEC"), t);
    AddTypeDecl(l, Lex.Intern(l, "ASSERT"), t);
    AddTypeDecl(l, Lex.Intern(l, "ORD"), t);
    AddTypeDecl(l, Lex.Intern(l, "CHR"), t);
    AddTypeDecl(l, Lex.Intern(l, "FLT"), t);
    AddTypeDecl(l, Lex.Intern(l, "ABS"), t);
    AddTypeDecl(l, Lex.Intern(l, "NEW"), t);
    globalScope := scope;
  END;
  scope := globalScope;
END InitGlobalScope;

PROCEDURE ResolveForwards*(l :Lex.Lexer);
VAR
  d :AST.Decl;
BEGIN
  WHILE fwds # NIL DO
    ASSERT(fwds.t.kind = AST.typePointer);
    d := LookupDecl(l, fwds.t.fields.name);
    IF (d # NIL) & (d.kind = AST.declType) & (d.typ.kind = AST.typeRecord) THEN
      fwds.t.base := d.typ;
      fwds.t.fields := NIL;
    ELSE
      Lex.Error(l, "Bad forward declaration ");
      Lex.OutStr(l, fwds.t.fields.name);
      Out.Ln;
    END;
    fwds := fwds.next;
  END;
END ResolveForwards;

PROCEDURE AddFormalParamsToScope*(l :Lex.Lexer; procDecl :AST.Decl);
VAR
  formal, actual :AST.Decl;
BEGIN
  ASSERT(procDecl.kind = AST.declProcedure);
  ASSERT(procDecl.typ.kind = AST.typeProcedure);
  formal := procDecl.typ.fields;
  WHILE formal # NIL DO
    actual := AddScopeDecl(l, formal.name);
    actual.kind := formal.kind;
    actual.typ := formal.typ;
    formal := formal.next;
  END;
END AddFormalParamsToScope;

PROCEDURE CurrentScope*(): AST.Decl;
BEGIN
  RETURN scope
END CurrentScope;

PROCEDURE OpenScope*() :AST.Decl;
VAR
  d, oldScope :AST.Decl;
BEGIN
  NEW(d);
  d.kind := AST.declEND;
  d.name := 0;
  d.next := scope;
  oldScope := scope;
  scope := d;
  RETURN oldScope
END OpenScope;

PROCEDURE CloseScope*(s :AST.Decl);
BEGIN
  scope := s;
END CloseScope;

PROCEDURE TestCleanup*;
BEGIN
  scope := NIL;
  globalScope := NIL;
END TestCleanup;

PROCEDURE TestDecls;
VAR
  l :Lex.Lexer;
  d :AST.Decl;
  t :AST.Type;
BEGIN
  Lex.LexerInitFromString(l, "");
  d := NIL;
  AddDecl(l, d, 10);
  AddDecl(l, d, 20);
  AddDecl(l, d, 30);
  AddDecl(l, d, 40);
  (* Expected error cases *)
  Out.Mute;
  AddDecl(l, d, 10);
  AddDecl(l, d, 20);
  AddDecl(l, d, 30);
  AddDecl(l, d, 40);
  scope := d;
  ASSERT(LookupDecl(l, 20) # NIL);
  ASSERT(LookupDecl(l, 100) = NIL);
  Out.Unmute;
  InitGlobalScope(l);
  ASSERT(LookupDecl(l, Lex.Intern(l, "NIL")) # NIL);
  d := LookupDecl(l, Lex.Intern(l, "NIL"));
  ASSERT(d.kind = AST.declType);
  ASSERT(d.typ.kind = AST.typeNil);
  d := LookupDecl(l, Lex.Intern(l, "INTEGER"));
  ASSERT(d.kind = AST.declType);
  t := d.typ;
  d := LookupDecl(l, Lex.Intern(l, "BYTE"));
  ASSERT(t = d.typ);
  TestCleanup;
  Out.PrintLn("PASS: Decls test");
END TestDecls;

BEGIN
  globalScope := NIL;
  TestDecls
END Decls.

MODULE Lex;

IMPORT Out;

CONST
  NumBuckets = 4096;
  PoolSize   = 64 * 1024;
  BufSize    = 64 * 1024;
  KwdSize    = 10;
  (* Token definitions *)
  (* Keywords - Keywords are special because they are included in the string *)
  (* pool in a special way. The ARRAY keyword is inserted first into the     *)
  (* table, and it takes up 10 characters. Thus, ARRAY is at position 0,     *)
  (* BEGIN at position 10, BY at position 20, and so on. This means that the *)
  (* keword is looked up by PoolIndex DIV 10. Adding new keywords thus       *)
  (* requires that they be contiguous with each other, and before the        *)
  (* punctuation tokens, IN order to keep things consistent.                 *)
  tARRAY*       =  0;
  tBEGIN*       =  1;
  tBY*          =  2;
  tCASE*        =  3;
  tCONST*       =  4;
  tDIV*         =  5;
  tDO*          =  6;
  tELSE*        =  7;
  tELSIF*       =  8;
  tEND*         =  9;
  tFALSE*       = 10;
  tFOR*         = 11;
  tIF*          = 12;
  tIMPORT*      = 13;
  tIN*          = 14;
  tIS*          = 15;
  tMOD*         = 16;
  tMODULE*      = 17;
  tNATIVE*      = 18;
  tNIL*         = 19;
  tOF*          = 20;
  tOR*          = 21;
  tPOINTER*     = 22;
  tPROCEDURE*   = 23;
  tRECORD*      = 24;
  tREPEAT*      = 25;
  tRETURN*      = 26;
  tTHEN*        = 27;
  tTO*          = 28;
  tTRUE*        = 29;
  tTYPE*        = 30;
  tUNTIL*       = 31;
  tVAR*         = 32;
  tWHILE*       = 33;
  tXOR*         = 34;
  tLastKwd      = tXOR * KwdSize;

  tIDENT*       = 35;
  tKEYWORD*     = 36;
  tSTRING*      = 37;
  tINT*         = 38;
  tREAL*        = 39;
  tPLUS*        = 40;
  tMINUS*       = 41;
  tSTAR*        = 42;
  tSLASH*       = 43;
  tTILDE*       = 44;
  tAMP*         = 45;
  tDOT*         = 46;
  tCOMMA*       = 47;
  tSEMI*        = 48;
  tVBAR*        = 49;
  tLPAREN*      = 50;
  tRPAREN*      = 51;
  tLBRACK*      = 52;
  tRBRACK*      = 53;
  tLBRACE*      = 54;
  tRBRACE*      = 55;
  tASSIGN*      = 56;
  tCARET*       = 57;
  tEQ*          = 58;
  tPOUND*       = 59;
  tLT*          = 60;
  tGT*          = 61;
  tLTEQ*        = 62;
  tGTEQ*        = 63;
  tDOTDOT*      = 64;
  tCOLON*       = 65;
  tAsSetElt*    = 66;
  tCaseDotDot*  = 67;
  tEOF*         = 68;

TYPE
  PoolIndex   = INTEGER;
  StringPool* = RECORD
    buf     :ARRAY PoolSize OF CHAR;
    last    :PoolIndex;
    buckets :ARRAY NumBuckets OF PoolIndex;
  END;
  Token       = RECORD
    kind :INTEGER;
    pos  :INTEGER;
    sVal :PoolIndex;
    iVal :INTEGER;
    rVal :REAL;
  END;
  Lexer*      = RECORD
    sp       :StringPool;
    buf      :ARRAY BufSize OF CHAR;
    fileName :PoolIndex;
    pos      :INTEGER;
    t        :Token;
  END;

VAR
  TokenNames :ARRAY tEOF+1, KwdSize OF CHAR;

PROCEDURE PoolInit(VAR sp :StringPool);
VAR
  i :INTEGER;
BEGIN
  sp.last := 0;
  FOR i := 0 TO NumBuckets-1 DO
    sp.buckets[i] := -1
  END
END PoolInit;

PROCEDURE StringLen(s :ARRAY OF CHAR) :INTEGER;
VAR
  l :INTEGER;
BEGIN
  l := 0;
  WHILE s[l] # 0X DO INC(l) END
  RETURN l
END StringLen;

PROCEDURE StrEq(a :ARRAY OF CHAR; ai :INTEGER; b :ARRAY OF CHAR; bi :INTEGER; len :INTEGER) :BOOLEAN;
VAR
  same :BOOLEAN;
BEGIN
  WHILE (len > 0) & (a[ai] = b[bi]) DO
    INC(ai);
    INC(bi);
    DEC(len);
  END;
  RETURN len = 0
END StrEq;

PROCEDURE StringInternRange(VAR sp :StringPool; s :ARRAY OF CHAR; offset, length :INTEGER) :PoolIndex;
VAR
  i    :INTEGER;
  hash :INTEGER;
  b    :INTEGER;
BEGIN
  ASSERT(sp.last + length < PoolSize);
  (* Copy and compute hash at the same time *)
  hash := 811C9DC5H;
  i := 0;
  WHILE (i < length) & (s[i] # 0X) DO
    hash := hash XOR ORD(s[offset + i]);
    hash := hash * 16777619;
    sp.buf[sp.last + i] := s[offset + i];
    INC(i)
  END;
  sp.buf[sp.last + i] := 0X;
  hash := hash * 85EBCA6BH;
  hash := hash XOR (hash DIV 65536);
  b := hash MOD NumBuckets;
  WHILE (sp.buckets[b] >= 0) & ~StrEq(sp.buf, sp.buckets[b], s, offset, length) DO
    INC(b);
    IF b = NumBuckets THEN b := 0; END;
  END;
  IF sp.buckets[b] < 0 THEN
    sp.buckets[b] := sp.last;
    INC(sp.last, length+1);
  END;
  RETURN sp.buckets[b]
END StringInternRange;

PROCEDURE StringIntern(VAR sp :StringPool; s :ARRAY OF CHAR) :PoolIndex;
BEGIN
  RETURN StringInternRange(sp, s, 0, StringLen(s))
END StringIntern;

PROCEDURE MakeDummy(i :INTEGER; VAR s :ARRAY OF CHAR);
BEGIN
  s[0] := "i";
  s[4] := CHR((i MOD 10) + 48);
  i := i DIV 10;
  s[3] := CHR((i MOD 10) + 48);
  i := i DIV 10;
  s[2] := CHR((i MOD 10) + 48);
  i := i DIV 10;
  s[1] := CHR((i MOD 10) + 48);
  s[5] := 0X;
END MakeDummy;

PROCEDURE AddKeywords(VAR sp :StringPool);
BEGIN
  StringInternRange(sp, "ARRAY", 0, 9);
  StringInternRange(sp, "BEGIN", 0, 9);
  StringInternRange(sp, "BY", 0, 9);
  StringInternRange(sp, "CASE", 0, 9);
  StringInternRange(sp, "CONST", 0, 9);
  StringInternRange(sp, "DIV", 0, 9);
  StringInternRange(sp, "DO", 0, 9);
  StringInternRange(sp, "ELSE", 0, 9);
  StringInternRange(sp, "ELSIF", 0, 9);
  StringInternRange(sp, "END", 0, 9);
  StringInternRange(sp, "FALSE", 0, 9);
  StringInternRange(sp, "FOR", 0, 9);
  StringInternRange(sp, "IF", 0, 9);
  StringInternRange(sp, "IMPORT", 0, 9);
  StringInternRange(sp, "IN", 0, 9);
  StringInternRange(sp, "IS", 0, 9);
  StringInternRange(sp, "MOD", 0, 9);
  StringInternRange(sp, "MODULE", 0, 9);
  StringInternRange(sp, "NATIVE", 0, 9);
  StringInternRange(sp, "NIL", 0, 9);
  StringInternRange(sp, "OF", 0, 9);
  StringInternRange(sp, "OR", 0, 9);
  StringInternRange(sp, "POINTER", 0, 9);
  StringInternRange(sp, "PROCEDURE", 0, 9);
  StringInternRange(sp, "RECORD", 0, 9);
  StringInternRange(sp, "REPEAT", 0, 9);
  StringInternRange(sp, "RETURN", 0, 9);
  StringInternRange(sp, "THEN", 0, 9);
  StringInternRange(sp, "TO", 0, 9);
  StringInternRange(sp, "TRUE", 0, 9);
  StringInternRange(sp, "TYPE", 0, 9);
  StringInternRange(sp, "UNTIL", 0, 9);
  StringInternRange(sp, "VAR", 0, 9);
  StringInternRange(sp, "WHILE", 0, 9);
  StringInternRange(sp, "XOR", 0, 9);
END AddKeywords;

PROCEDURE Next(VAR l :Lexer; VAR c :CHAR);
BEGIN
  c := l.buf[l.pos];
  INC(l.pos);
END Next;

PROCEDURE ScanIdent(VAR l :Lexer);
VAR
  start   :INTEGER;
  scan    :BOOLEAN;
  idx     :INTEGER;
BEGIN
  start := l.pos;
  scan := TRUE;
  WHILE scan DO
    scan := FALSE;
    CASE l.buf[l.pos] OF
      "A" .. "Z", "a" .. "z", "0" .. "9", "_": scan := TRUE; INC(l.pos);
    END;
  END;
  idx := StringInternRange(l.sp, l.buf, start, l.pos - start);
  IF idx <= tLastKwd THEN
    l.t.kind := idx DIV KwdSize;
  ELSE
    l.t.kind := tSTRING;
    l.t.sVal := idx;
  END;
END ScanIdent;

PROCEDURE ScanNumber(VAR l :Lexer);
VAR
  ch          :CHAR;
  start, base :INTEGER;
  needHorX    :BOOLEAN;
  s           :ARRAY 2 OF CHAR;
BEGIN
  start := l.pos;
  l.t.kind := tINT;
  base := 10;
  needHorX := FALSE;
  Next(l, ch);
  WHILE (ch >= "0") & (ch <= "9") OR
        (ch >= "A") & (ch <= "F") OR
        (ch >= "a") & (ch <= "f") DO
    IF (ch >= "A") & (ch <= "F") OR (ch >= "a") & (ch <= "f") THEN
      needHorX := TRUE;
    END;
    Next(l, ch);;
  END;
  (* Got letters and hex digits. Could be hex, char, or floating point *)
  IF (ch = "X") OR (ch = "x") THEN
    l.t.kind := tSTRING;
    base := 16;
    needHorX := FALSE;
    Next(l, ch);;
  ELSIF (ch = "H") OR (ch = "h") THEN
    base := 16;
    needHorX := FALSE;
    Next(l, ch);;
  ELSIF (ch = ".") & (l.buf[l.pos+1] # ".") THEN
    (* Special case - 10..20 is 10 TOKEN_DOTDOT 20 *)
    Next(l, ch);;
    (* mantissa *)
    WHILE (ch >= "0") & (ch <= "9") DO
      Next(l, ch);;
    END;
    IF (ch = "e") OR (ch = "E") THEN
      Next(l, ch);;
    END;
    IF ch = "-" THEN
      Next(l, ch);;
    END;
    WHILE (ch >= "0") & (ch <= "9") DO
      Next(l, ch);;
    END;
    l.t.kind := tREAL;
    l.t.rVal := 0.0; (* TODO *)
    (* RETURN *)
  ELSIF needHorX THEN
    (* ErrorLn("Hex digit must be followed by H or X"); *)
  END;
  l.t.iVal := 0;
  WHILE start # l.pos DO
    ch := l.buf[start];
    IF (ch >= "0") & (ch <= "9") THEN
      l.t.iVal := l.t.iVal * base + (ORD(ch) - ORD("0"));
    ELSIF (ch >= "A") & (ch <= "F") THEN
      l.t.iVal := l.t.iVal * base + (ORD(ch) - ORD("A") + 10);
    ELSIF (ch >= "a") & (ch <= "f") THEN
      l.t.iVal := l.t.iVal * base + (ORD(ch) - ORD("a") + 10);
    ELSIF (ch = "H") OR (ch <= "h") OR (ch = "X") OR (ch = "x") THEN
    ELSE
      ASSERT(FALSE);
    END;
    INC(start);
  END;
  IF l.t.kind = tSTRING THEN
    IF l.t.iVal > 255 THEN
      (* error("Character constant %d > 255", token.iVal); *)
    ELSE
      s[0] := CHR(l.t.iVal);
      s[1] := 0X;
      l.t.sVal := StringIntern(l.sp, s);
    END;
  END;
END ScanNumber;

PROCEDURE LexerInitFromFile(VAR l :Lexer; fileName :ARRAY OF CHAR);
BEGIN
  PoolInit(l.sp);
  AddKeywords(l.sp);
  l.buf := "TODO"; (* TODO *)
  l.fileName := StringIntern(l.sp, fileName);
  l.pos := 0;
END LexerInitFromFile;

PROCEDURE LexerInitFromString(VAR l :Lexer; s :ARRAY OF CHAR);
BEGIN
  PoolInit(l.sp);
  AddKeywords(l.sp);
  l.buf := s;
  l.fileName := StringIntern(l.sp, "<string>");
  l.pos := 0;
END LexerInitFromString;
  
PROCEDURE InitTokenNames;
BEGIN
  TokenNames[tARRAY]        :=  "ARRAY";
  TokenNames[tBEGIN]        :=  "BEGIN";
  TokenNames[tBY]           :=  "BY";
  TokenNames[tCASE]         :=  "CASE";
  TokenNames[tCONST]        :=  "CONST";
  TokenNames[tDIV]          :=  "DIV";
  TokenNames[tDO]           :=  "DO";
  TokenNames[tELSE]         :=  "ELSE";
  TokenNames[tELSIF]        :=  "ELSIF";
  TokenNames[tEND]          :=  "END";
  TokenNames[tFALSE]        :=  "FALSE";
  TokenNames[tFOR]          :=  "FOR";
  TokenNames[tIF]           :=  "IF";
  TokenNames[tIMPORT]       :=  "IMPORT";
  TokenNames[tIN]           :=  "IN";
  TokenNames[tIS]           :=  "IS";
  TokenNames[tMOD]          :=  "MOD";
  TokenNames[tMODULE]       :=  "MODULE";
  TokenNames[tNATIVE]       :=  "NATIVE";
  TokenNames[tNIL]          :=  "NIL";
  TokenNames[tOF]           :=  "OF";
  TokenNames[tOR]           :=  "OR";
  TokenNames[tPOINTER]      :=  "POINTER";
  TokenNames[tPROCEDURE]    :=  "PROCEDURE";
  TokenNames[tRECORD]       :=  "RECORD";
  TokenNames[tREPEAT]       :=  "REPEAT";
  TokenNames[tRETURN]       :=  "RETURN";
  TokenNames[tTHEN]         :=  "THEN";
  TokenNames[tTO]           :=  "TO";
  TokenNames[tTRUE]         :=  "TRUE";
  TokenNames[tTYPE]         :=  "TYPE";
  TokenNames[tUNTIL]        :=  "UNTIL";
  TokenNames[tVAR]          :=  "VAR";
  TokenNames[tWHILE]        :=  "WHILE";
  TokenNames[tXOR]          :=  "XOR";
  TokenNames[tIDENT]        :=  "IDENT";
  TokenNames[tKEYWORD]      :=  "KEYWORD";
  TokenNames[tSTRING]       :=  "STRING";
  TokenNames[tINT]          :=  "INT";
  TokenNames[tREAL]         :=  "REAL";
  TokenNames[tPLUS]         :=  "PLUS";
  TokenNames[tMINUS]        :=  "MINUS";
  TokenNames[tSTAR]         :=  "STAR";
  TokenNames[tSLASH]        :=  "SLASH";
  TokenNames[tTILDE]        :=  "TILDE";
  TokenNames[tAMP]          :=  "AMP";
  TokenNames[tDOT]          :=  "DOT";
  TokenNames[tCOMMA]        :=  "COMMA";
  TokenNames[tSEMI]         :=  "SEMI";
  TokenNames[tVBAR]         :=  "VBAR";
  TokenNames[tLPAREN]       :=  "LPAREN";
  TokenNames[tRPAREN]       :=  "RPAREN";
  TokenNames[tLBRACK]       :=  "LBRACK";
  TokenNames[tRBRACK]       :=  "RBRACK";
  TokenNames[tLBRACE]       :=  "LBRACE";
  TokenNames[tRBRACE]       :=  "RBRACE";
  TokenNames[tASSIGN]       :=  "ASSIGN";
  TokenNames[tCARET]        :=  "CARET";
  TokenNames[tEQ]           :=  "EQ";
  TokenNames[tPOUND]        :=  "POUND";
  TokenNames[tLT]           :=  "LT";
  TokenNames[tGT]           :=  "GT";
  TokenNames[tLTEQ]         :=  "LTEQ";
  TokenNames[tGTEQ]         :=  "GTEQ";
  TokenNames[tDOTDOT]       :=  "DOTDOT";
  TokenNames[tCOLON]        :=  "COLON";
  TokenNames[tAsSetElt]     :=  "AS_SET";
  TokenNames[tCaseDotDot]   :=  "DOTDOT";
  TokenNames[tEOF]          :=  "EOF";
END InitTokenNames;

PROCEDURE TestPool;
VAR
  sp   :StringPool;
  s    :ARRAY 25 OF CHAR;
  i,j  :PoolIndex;
BEGIN
  PoolInit(sp);
  ASSERT(11 = StringLen("Hello world"));
  s := "Hello world";
  ASSERT(StrEq(s, 0, "Hello world", 0, 11));
  ASSERT(~StrEq(s, 0, "Hello", 0, 11));
  ASSERT(StrEq(s, 1, "Hello world", 1, 10));
  ASSERT(11 = StringLen(s));
  ASSERT(StringIntern(sp, s) = 0);
  s := "Yello world";
  ASSERT(StringIntern(sp, s) = 12);
  i := StringInternRange(sp, "Hellooo", 1, 4);
  ASSERT(i = StringIntern(sp, "ello"));
  j := StringInternRange(sp, s, 0, 0);
  ASSERT(i # j);
  ASSERT(StringIntern(sp, "") = j);
  s[0] := "A";
  s[1] := 0X;
  ASSERT(StringIntern(sp, s) = StringIntern(sp, "A"));
  ASSERT(StringIntern(sp, s) # StringIntern(sp, "B"));

  PoolInit(sp);
  FOR i := 1 TO 4000 DO
    MakeDummy(i, s);
    StringIntern(sp, s);
  END;
  FOR i := 1 TO 4000 DO
    MakeDummy(i, s);
    ASSERT(StringIntern(sp, s) = (i-1)*6);
  END;
  ASSERT(sp.last = 24000);
  PoolInit(sp);
  StringInternRange(sp, "A", 0, 9);
  StringInternRange(sp, "PROCEDURE", 0, 9);
  StringInternRange(sp, "B", 0, 9);
  ASSERT(StringIntern(sp, "A") = 0);
  ASSERT(StringIntern(sp, "PROCEDURE") = 10);
  ASSERT(StringIntern(sp, "B") = 20);
END TestPool;

PROCEDURE TestLexer;
VAR
  l :Lexer;
BEGIN
  LexerInitFromString(l, "0C000H 12345 hello world");
  ScanNumber(l);
  Out.Str("Number is: ");
  Out.Int(l.t.iVal);
  Out.Ln;
END TestLexer;

BEGIN
  InitTokenNames;
  TestPool;
  TestLexer;
END Lex.

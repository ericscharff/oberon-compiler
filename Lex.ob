MODULE Lex;

CONST
  NumBuckets = 4096;
  PoolSize   = 64 * 1024;
  (* Token definitions *)
  (* Keywords - Keywords are special because they are included in the string *)
  (* pool in a special way. The ARRAY keyword is inserted first into the     *)
  (* table, and it takes up 10 characters. Thus, ARRAY is at position 0,     *)
  (* BEGIN at position 10, BY at position 20, and so on. This means that the *)
  (* keword is looked up by PoolIndex DIV 10. Adding new keywords thus       *)
  (* requires that they be contiguous with each other, and before the        *)
  (* punctuation tokens, IN order to keep things consistent.                 *)
  tARRAY*       =  0;
  tBEGIN*       =  1;
  tBY*          =  2;
  tCASE*        =  3;
  tCONST*       =  4;
  tDIV*         =  5;
  tDO*          =  6;
  tELSE*        =  7;
  tELSIF*       =  8;
  tEND*         =  9;
  tFALSE*       = 10;
  tFOR*         = 11;
  tIF*          = 12;
  tIMPORT*      = 13;
  tIN*          = 14;
  tIS*          = 15;
  tMOD*         = 16;
  tMODULE*      = 17;
  tNATIVE*      = 18;
  tNIL*         = 19;
  tOF*          = 20;
  tOR*          = 21;
  tPOINTER*     = 22;
  tPROCEDURE*   = 23;
  tRECORD*      = 24;
  tREPEAT*      = 25;
  tRETURN*      = 26;
  tTHEN*        = 27;
  tTO*          = 28;
  tTRUE*        = 29;
  tTYPE*        = 30;
  tUNTIL*       = 31;
  tVAR*         = 32;
  tWHILE*       = 33;
  tXOR*         = 34;

  tIDENT*       = 35;
  tKEYWORD*     = 36;
  tSTRING*      = 37;
  tINT*         = 38;
  tREAL*        = 39;
  tPLUS*        = 40;
  tMINUS*       = 41;
  tSTAR*        = 42;
  tSLASH*       = 43;
  tTILDE*       = 44;
  tAMP*         = 45;
  tDOT*         = 46;
  tCOMMA*       = 47;
  tSEMI*        = 48;
  tVBAR*        = 49;
  tLPAREN*      = 50;
  tRPAREN*      = 51;
  tLBRACK*      = 52;
  tRBRACK*      = 53;
  tLBRACE*      = 54;
  tRBRACE*      = 55;
  tASSIGN*      = 56;
  tCARET*       = 57;
  tEQ*          = 58;
  tPOUND*       = 59;
  tLT*          = 60;
  tGT*          = 61;
  tLTEQ*        = 62;
  tGTEQ*        = 63;
  tDOTDOT*      = 64;
  tCOLON*       = 65;
  tAS_SET_ELT*  = 66;
  tCASE_DOTDOT* = 67;
  tEOF*         = 68;

TYPE
  PoolIndex   = INTEGER;
  StringPool* = RECORD
    buf     :ARRAY PoolSize OF CHAR;
    last    :PoolIndex;
    buckets :ARRAY NumBuckets OF PoolIndex;
  END;

VAR
  TokenNames :ARRAY tEOF+1, 10 OF CHAR;

PROCEDURE PoolInit(VAR sp :StringPool);
VAR
  i :INTEGER;
BEGIN
  sp.last := 0;
  FOR i := 0 TO NumBuckets-1 DO
    sp.buckets[i] := -1
  END
END PoolInit;

PROCEDURE StringLen(s :ARRAY OF CHAR) :INTEGER;
VAR
  l :INTEGER;
BEGIN
  l := 0;
  WHILE s[l] # 0X DO INC(l) END
  RETURN l
END StringLen;

PROCEDURE StrEq(a :ARRAY OF CHAR; ai :INTEGER; b :ARRAY OF CHAR; bi :INTEGER) :BOOLEAN;
VAR
  same :BOOLEAN;
BEGIN
  WHILE (a[ai] = b[bi]) & ((a[ai] # 0X) & (b[bi] # 0X)) DO
    INC(ai);
    INC(bi);
  END;
  RETURN (a[ai] = 0X) & (b[bi] = 0X)
END StrEq;

PROCEDURE StringInternRange(VAR sp :StringPool; s :ARRAY OF CHAR; offset, length :INTEGER) :PoolIndex;
VAR
  i    :INTEGER;
  hash :INTEGER;
  b    :INTEGER;
BEGIN
  ASSERT(sp.last + length < PoolSize);
  (* Copy and compute hash at the same time *)
  hash := 811C9DC5H;
  i := 0;
  WHILE (i < length) & (s[i] # 0X) DO
    hash := hash XOR ORD(s[offset + i]);
    hash := hash * 16777619;
    sp.buf[sp.last + i] := s[offset + i];
    INC(i)
  END;
  sp.buf[sp.last + i] := 0X;
  hash := hash * 85EBCA6BH;
  hash := hash XOR (hash DIV 65536);
  b := hash MOD NumBuckets;
  WHILE (sp.buckets[b] >= 0) & ~StrEq(sp.buf, sp.buckets[b], s, offset) DO
    INC(b);
    IF b = NumBuckets THEN b := 0; END;
  END;
  IF sp.buckets[b] < 0 THEN
    sp.buckets[b] := sp.last;
    INC(sp.last, length+1);
  END;
  RETURN sp.buckets[b]
END StringInternRange;

PROCEDURE StringIntern(VAR sp :StringPool; s :ARRAY OF CHAR) :PoolIndex;
BEGIN
  RETURN StringInternRange(sp, s, 0, StringLen(s))
END StringIntern;

PROCEDURE MakeDummy(i :INTEGER; VAR s :ARRAY OF CHAR);
BEGIN
  s[0] := "i";
  s[4] := CHR((i MOD 10) + 48);
  i := i DIV 10;
  s[3] := CHR((i MOD 10) + 48);
  i := i DIV 10;
  s[2] := CHR((i MOD 10) + 48);
  i := i DIV 10;
  s[1] := CHR((i MOD 10) + 48);
  s[5] := 0X;
END MakeDummy;

PROCEDURE TestPool;
VAR
  sp   :StringPool;
  s    :ARRAY 25 OF CHAR;
  i,j  :PoolIndex;
BEGIN
  PoolInit(sp);
  ASSERT(11 = StringLen("Hello world"));
  s := "Hello world";
  ASSERT(StrEq(s, 0, "Hello world", 0));
  ASSERT(~StrEq(s, 0, "Hello", 0));
  ASSERT(StrEq(s, 1, "Hello world", 1));
  ASSERT(11 = StringLen(s));
  ASSERT(StringIntern(sp, s) = 0);
  s := "Yello world";
  ASSERT(StringIntern(sp, s) = 12);
  i := StringInternRange(sp, "Hellooo", 1, 4);
  ASSERT(i = StringIntern(sp, "ello"));
  j := StringInternRange(sp, s, 0, 0);
  ASSERT(i # j);
  ASSERT(StringIntern(sp, "") = j);
  s[0] := "A";
  s[1] := 0X;
  ASSERT(StringIntern(sp, s) = StringIntern(sp, "A"));
  ASSERT(StringIntern(sp, s) # StringIntern(sp, "B"));

  PoolInit(sp);
  FOR i := 1 TO 4000 DO
    MakeDummy(i, s);
    StringIntern(sp, s);
  END;
  FOR i := 1 TO 4000 DO
    MakeDummy(i, s);
    ASSERT(StringIntern(sp, s) = (i-1)*6);
  END;
  ASSERT(sp.last = 24000);
  PoolInit(sp);
  StringInternRange(sp, "A", 0, 9);
  StringInternRange(sp, "PROCEDURE", 0, 9);
  StringInternRange(sp, "B", 0, 9);
  ASSERT(StringIntern(sp, "A") = 0);
  ASSERT(StringIntern(sp, "PROCEDURE") = 10);
  ASSERT(StringIntern(sp, "B") = 20);
END TestPool;

PROCEDURE InitTokenNames;

BEGIN
  TokenNames[tARRAY]        :=  "ARRAY";
  TokenNames[tBEGIN]        :=  "BEGIN";
  TokenNames[tBY]           :=  "BY";
  TokenNames[tCASE]         :=  "CASE";
  TokenNames[tCONST]        :=  "CONST";
  TokenNames[tDIV]          :=  "DIV";
  TokenNames[tDO]           :=  "DO";
  TokenNames[tELSE]         :=  "ELSE";
  TokenNames[tELSIF]        :=  "ELSIF";
  TokenNames[tEND]          :=  "END";
  TokenNames[tFALSE]        :=  "FALSE";
  TokenNames[tFOR]          :=  "FOR";
  TokenNames[tIF]           :=  "IF";
  TokenNames[tIMPORT]       :=  "IMPORT";
  TokenNames[tIN]           :=  "IN";
  TokenNames[tIS]           :=  "IS";
  TokenNames[tMOD]          :=  "MOD";
  TokenNames[tMODULE]       :=  "MODULE";
  TokenNames[tNATIVE]       :=  "NATIVE";
  TokenNames[tNIL]          :=  "NIL";
  TokenNames[tOF]           :=  "OF";
  TokenNames[tOR]           :=  "OR";
  TokenNames[tPOINTER]      :=  "POINTER";
  TokenNames[tPROCEDURE]    :=  "PROCEDURE";
  TokenNames[tRECORD]       :=  "RECORD";
  TokenNames[tREPEAT]       :=  "REPEAT";
  TokenNames[tRETURN]       :=  "RETURN";
  TokenNames[tTHEN]         :=  "THEN";
  TokenNames[tTO]           :=  "TO";
  TokenNames[tTRUE]         :=  "TRUE";
  TokenNames[tTYPE]         :=  "TYPE";
  TokenNames[tUNTIL]        :=  "UNTIL";
  TokenNames[tVAR]          :=  "VAR";
  TokenNames[tWHILE]        :=  "WHILE";
  TokenNames[tXOR]          :=  "XOR";
  TokenNames[tIDENT]        :=  "IDENT";
  TokenNames[tKEYWORD]      :=  "KEYWORD";
  TokenNames[tSTRING]       :=  "STRING";
  TokenNames[tINT]          :=  "INT";
  TokenNames[tREAL]         :=  "REAL";
  TokenNames[tPLUS]         :=  "PLUS";
  TokenNames[tMINUS]        :=  "MINUS";
  TokenNames[tSTAR]         :=  "STAR";
  TokenNames[tSLASH]        :=  "SLASH";
  TokenNames[tTILDE]        :=  "TILDE";
  TokenNames[tAMP]          :=  "AMP";
  TokenNames[tDOT]          :=  "DOT";
  TokenNames[tCOMMA]        :=  "COMMA";
  TokenNames[tSEMI]         :=  "SEMI";
  TokenNames[tVBAR]         :=  "VBAR";
  TokenNames[tLPAREN]       :=  "LPAREN";
  TokenNames[tRPAREN]       :=  "RPAREN";
  TokenNames[tLBRACK]       :=  "LBRACK";
  TokenNames[tRBRACK]       :=  "RBRACK";
  TokenNames[tLBRACE]       :=  "LBRACE";
  TokenNames[tRBRACE]       :=  "RBRACE";
  TokenNames[tASSIGN]       :=  "ASSIGN";
  TokenNames[tCARET]        :=  "CARET";
  TokenNames[tEQ]           :=  "EQ";
  TokenNames[tPOUND]        :=  "POUND";
  TokenNames[tLT]           :=  "LT";
  TokenNames[tGT]           :=  "GT";
  TokenNames[tLTEQ]         :=  "LTEQ";
  TokenNames[tGTEQ]         :=  "GTEQ";
  TokenNames[tDOTDOT]       :=  "DOTDOT";
  TokenNames[tCOLON]        :=  "COLON";
  TokenNames[tAS_SET_ELT]   :=  "AS_SET_ELT";
  TokenNames[tCASE_DOTDOT]  :=  "CASE_DOTDOT";
  TokenNames[tEOF]          :=  "EOF";
END InitTokenNames;

BEGIN
  InitTokenNames;
  TestPool
END Lex.

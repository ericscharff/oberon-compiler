MODULE RCodegen;

IMPORT AST, Lex, Out;

CONST
  CACHE_SIZE = 100;
  CODE_BUFFER = 2000; (* Code for the procedure being generated, for fixups. *)

  (* Opcodes *)
  opMOV = 0;  (* ra := rb                      *)
  opADD = 1;  (* ra := rb + rc                 *)
  opSUB = 2;  (* ra := rb - rc                 *)
  opMUL = 3;  (* ra := rb * rc                 *)
  opDIV = 4;  (* ra := rb * rc                 *)
  opLDW = 5;  (* ra := Mem[rb + offset] (word) *)
  opLDB = 6;  (* ra := Mem[rb + offset] (byte) *)
  opSTW = 7;  (* Mem[rb + offset] := ra (word) *)
  opSTB = 8;  (* Mem[rb + offset] := ra (byte) *)
  opJSR = 50; (* Jump to Subr                  *)
  opRTS = 51; (* Subr return                   *)

  opMOVI = 100; (* ra := immediate      *)
  opADDI = 101; (* ra := rb + immediate *)
  opSUBI = 102; (* ra := rb - immediate *)
  opMULI = 103; (* ra := rb * immediate *)
  opDIVI = 104; (* ra := rb / immediate *)

  opHALT = 1000;

  (* Registers *)
  rGB = 13; (* r13 = Global base   *)
  rSP = 14; (* r14 = Stack pointer *)
  rLR = 15; (* r15 = Link register *)

  (* Item kinds *)
  itemReg   = 1; (* Item is in register r                         *)
  itemVar   = 2; (* Item is a variable whose address is r+offset. *)
                 (* r is always SP or GP.                         *)
  itemConst = 3; (* Item value is a constant, stored in offset    *)
  itemRegI  = 4; (* Register indirect address.                    *)
                 (* Item's address is r+offset, this is similar   *)
                 (* to Var, except with Var, r is always SP or    *)
                 (* GB. with RegI, this is an allocated register, *)
                 (* which eventually needs to be released.        *)

TYPE
  OpCode = INTEGER;
  Register = INTEGER;
  ItemKind = INTEGER;
  Instruction = RECORD
    op         :OpCode;
    ra, rb, rc :Register;
    value      :INTEGER;  (* If op is an immediate, e.g., ra := rb + value    *)
                          (* if op is a branch, this is the branch offset     *)
    q          :AST.QName;
  END;
  Item = RECORD
    kind   :ItemKind;
    r      :Register;
    offset :INTEGER;
  END;

VAR
  typeCache    :ARRAY CACHE_SIZE OF AST.Type; (* Already reached types        *)
  typeSizes    :ARRAY CACHE_SIZE OF INTEGER;  (* Map RECORD and ARRAY to size *)
  codeBuffer   :ARRAY CODE_BUFFER OF Instruction;
  globalOffset :INTEGER;                 (* Offset of variable to global base *)
  lastType     :INTEGER;
  pc           :INTEGER; (* (Global) program counter. This is the offset from *)
                         (* the start of code generated. This is measured in  *)
                         (* instructions, not bytes, so it is not a multiple  *)
                         (* of 4.                                             *)
  cp           :INTEGER; (* Code pointer. This is an offset into the code     *)
                         (* buffer, so 0 represents the start of a procedure. *)
                         (* It is measured in instructions, not bytes.        *)
  curReg       :INTEGER; (* Number [0..13] of the next available register     *)

PROCEDURE Emit(op :OpCode; ra, rb, rc :Register; value :INTEGER);
BEGIN
  codeBuffer[cp].op := op;
  codeBuffer[cp].ra := ra;
  codeBuffer[cp].rb := rb;
  codeBuffer[cp].rc := rc;
  codeBuffer[cp].value := value;
  INC(pc);
  INC(cp);
  ASSERT(cp < CODE_BUFFER)
END Emit;

PROCEDURE GenStr(s :ARRAY OF CHAR);
BEGIN
  Out.Str(s);
END GenStr;

PROCEDURE Tab;
BEGIN
  GenStr(9X)
END Tab;

PROCEDURE GenLn;
BEGIN
  Out.Ln
END GenLn;

PROCEDURE GenReg(r :Register);
BEGIN
  IF r < rGB THEN
    Out.Str("R"); Out.Int(r)
  ELSIF r = rGB THEN
    Out.Str("GB")
  ELSIF r = rSP THEN
    Out.Str("SP")
  ELSIF r = rLR THEN
    Out.Str("LR")
  ELSE
    ASSERT(FALSE)
  END
END GenReg;

PROCEDURE Gen2(op :ARRAY OF CHAR; ra, rb :Register; value :INTEGER);
BEGIN
  Out.Str(op);
  Out.Str(" ");
  GenReg(ra);
  Out.Str(", ");
  GenReg(rb);
  Out.Str(", #");
  Out.Int(value)
END Gen2;

PROCEDURE Gen3(op :ARRAY OF CHAR; ra, rb, rc :Register);
BEGIN
  Out.Str(op);
  Out.Str(" ");
  GenReg(ra);
  Out.Str(", ");
  GenReg(rb);
  Out.Str(", ");
  GenReg(rc)
END Gen3;

PROCEDURE GenQName(l :Lex.Lexer; name :AST.QName);
BEGIN
  IF name.moduleName > 0 THEN
    Lex.OutStr(l, name.moduleName);
    GenStr("_");
  END;
  IF name.name > 0 THEN
    Lex.OutStr(l, name.name);
  END;
END GenQName;

PROCEDURE DumpCode(l :Lex.Lexer; delta :INTEGER);
VAR
  i :INTEGER;
BEGIN
  i := 0;
  WHILE i < cp DO
    Out.Int(i + delta); Tab;
    IF codeBuffer[i].op = opMOV THEN
      Out.Str("MOV "); GenReg(codeBuffer[i].ra); GenStr(", "); GenReg(codeBuffer[i].rb);
    ELSIF codeBuffer[i].op = opMOVI THEN
      Out.Str("MOV "); GenReg(codeBuffer[i].ra); GenStr(", #"); Out.Int(codeBuffer[i].value);
    ELSIF codeBuffer[i].op = opADD THEN
      Gen3("ADD", codeBuffer[i].ra, codeBuffer[i].rb, codeBuffer[i].rc)
    ELSIF codeBuffer[i].op = opSUB THEN
      Gen3("SUB", codeBuffer[i].ra, codeBuffer[i].rb, codeBuffer[i].rc)
    ELSIF codeBuffer[i].op = opMUL THEN
      Gen3("MUL", codeBuffer[i].ra, codeBuffer[i].rb, codeBuffer[i].rc)
    ELSIF codeBuffer[i].op = opDIV THEN
      Gen3("DIV", codeBuffer[i].ra, codeBuffer[i].rb, codeBuffer[i].rc)
    ELSIF codeBuffer[i].op = opADDI THEN
      Gen2("ADD", codeBuffer[i].ra, codeBuffer[i].rb, codeBuffer[i].value)
    ELSIF codeBuffer[i].op = opSUBI THEN
      Gen2("SUB", codeBuffer[i].ra, codeBuffer[i].rb, codeBuffer[i].value)
    ELSIF codeBuffer[i].op = opMULI THEN
      Gen2("MUL", codeBuffer[i].ra, codeBuffer[i].rb, codeBuffer[i].value)
    ELSIF codeBuffer[i].op = opDIVI THEN
      Gen2("DIV", codeBuffer[i].ra, codeBuffer[i].rb, codeBuffer[i].value)
    ELSIF codeBuffer[i].op = opLDW THEN
      Gen2("LDW", codeBuffer[i].ra, codeBuffer[i].rb, codeBuffer[i].value)
    ELSIF codeBuffer[i].op = opLDB THEN
      Gen2("LDB", codeBuffer[i].ra, codeBuffer[i].rb, codeBuffer[i].value)
    ELSIF codeBuffer[i].op = opSTW THEN
      Gen2("STW", codeBuffer[i].ra, codeBuffer[i].rb, codeBuffer[i].value)
    ELSIF codeBuffer[i].op = opSTB THEN
      Gen2("STB", codeBuffer[i].ra, codeBuffer[i].rb, codeBuffer[i].value)
    ELSIF codeBuffer[i].op = opJSR THEN
      GenStr("JSR "); Out.Int(codeBuffer[i].value);
      GenStr(" ("); GenQName(l, codeBuffer[i].q);
      GenStr(")")
    ELSIF codeBuffer[i].op = opRTS THEN
      GenStr("RTS")
    ELSIF codeBuffer[i].op = opHALT THEN
      GenStr("HALT")
    ELSE
      ASSERT(FALSE)
    END;
    GenLn;
    INC(i)
  END
END DumpCode;

PROCEDURE FindOrAddType(t :AST.Type) :INTEGER;
VAR
  index :INTEGER;
  found :BOOLEAN;
BEGIN
  index := 0; found := FALSE;
  WHILE (index < lastType) & ~found DO
    IF typeCache[index] = t THEN
      found := TRUE
    ELSE
      INC(index)
    END
  END;
  IF ~found THEN
    ASSERT(index < CACHE_SIZE);
    typeCache[index] := t;
    typeSizes[index] := -1;
    INC(lastType)
  END
  RETURN index
END FindOrAddType;

PROCEDURE CalculateSize(t :AST.Type) :INTEGER;
VAR
  i, s :INTEGER;
  f :AST.Decl;
BEGIN
  IF t.kind IN {AST.typeInteger, AST.typeReal, AST.typeBoolean, AST.typeChar,
                AST.typeSet, AST.typePointer, AST.typeProcedure} THEN
    s := 4
  ELSIF t.kind = AST.typeRecord THEN
    i := FindOrAddType(t);
    s := typeSizes[i];
    IF typeSizes[i] < 0 THEN
      (* Not found yet. Record size is size of fields *)
      s := 0;
      IF t.needTypeInfo THEN s := 4 END;
      f := t.fields;
      WHILE (f # NIL) & (f.kind # AST.declEND) DO
        f.offset := s;
        s := s + CalculateSize(f.typ);
        f := f.next
      END;
      typeSizes[i] := s
    END;
  ELSIF t.kind = AST.typeArray THEN
    i := FindOrAddType(t);
    s := typeSizes[i];
    IF typeSizes[i] < 0 THEN
      (* Not found yet. Array size is length * element size *)
      ASSERT(t.length > 0);
      IF t.base.kind = AST.typeChar THEN
        (* Strings are packed up to a multiple of 4 bytes *)
        s := t.length;
        IF (s MOD 4) # 0 THEN
          s := t.length + 4 - (t.length MOD 4)
        END
      ELSE
        s := t.length * CalculateSize(t.base)
      END;
      typeSizes[i] := s
    END
  ELSE
    ASSERT(FALSE)
  END;
  RETURN s
END CalculateSize;

PROCEDURE IncCurReg;
BEGIN
  INC(curReg);
  IF curReg = rGB THEN
    Out.ErrStr("Out of registers"); Out.ErrLn;
    ASSERT(FALSE)
  END
END IncCurReg;

PROCEDURE DecCurReg;
BEGIN
  DEC(curReg);
  ASSERT(curReg >= 0)
END DecCurReg;

(* Loads a value from an item into a register. *)
PROCEDURE Load(VAR item :Item);
BEGIN
  IF item.kind = itemVar THEN
    Emit(opLDW, curReg, item.r, 0, item.offset);
    item.r := curReg;
    IncCurReg
  ELSIF item.kind = itemRegI THEN
    Emit(opLDW, item.r, item.r, 0, item.offset)
    (* item.r already allocated *)
  ELSIF item.kind = itemConst THEN
    Emit(opMOVI, curReg, 0, 0, item.offset);
    item.r := curReg;
    IncCurReg
  ELSIF item.kind = itemReg THEN
    (* Already in a register, do nothing *)
  ELSE
    ASSERT(FALSE)
  END;
  item.kind := itemReg
END Load;

PROCEDURE AllocateGlobals*(l :Lex.Lexer; d :AST.Decl);
BEGIN
  ASSERT(d.kind = AST.declVar);
  ASSERT(d.nesting = 0);
  ASSERT(d.offset = -1);
  d.offset := globalOffset;
  GenStr("; "); GenQName(l, d.qname); GenStr(" offset "); Out.Int(d.offset); GenLn;
  globalOffset := globalOffset + CalculateSize(d.typ)
END AllocateGlobals;

PROCEDURE GenBinaryOp(op :Lex.TokenKind; VAR lhs, rhs :Item);
BEGIN
  IF op = Lex.tPLUS THEN
    IF lhs.kind = itemConst THEN
      Load(rhs);
      lhs.kind := rhs.kind; lhs.r := rhs.r;
      Emit(opADDI, lhs.r, lhs.r, 0, lhs.offset)
    ELSIF rhs.kind = itemConst THEN
      Load(lhs);
      Emit(opADDI, lhs.r, lhs.r, 0, rhs.offset)
    ELSE
      Load(lhs);
      Load(rhs);
      ASSERT(lhs.kind = itemReg);
      ASSERT(rhs.kind = itemReg);
      Emit(opADD, lhs.r, lhs.r, rhs.r, 0);
      DecCurReg
    END
  ELSIF op = Lex.tSTAR THEN
    IF lhs.kind = itemConst THEN
      Load(rhs);
      lhs.kind := rhs.kind; lhs.r := rhs.r;
      Emit(opMULI, lhs.r, lhs.r, 0, lhs.offset)
    ELSIF rhs.kind = itemConst THEN
      Load(lhs);
      Emit(opMULI, lhs.r, lhs.r, 0, rhs.offset)
    ELSE
      Load(lhs);
      Load(rhs);
      ASSERT(lhs.kind = itemReg);
      ASSERT(rhs.kind = itemReg);
      Emit(opMUL, lhs.r, lhs.r, rhs.r, 0);
      DecCurReg
    END
  ELSE
    ASSERT(FALSE)
  END
END GenBinaryOp;

PROCEDURE GenExpr(e :AST.Expr; VAR item :Item);
VAR
  size :INTEGER;
  rhs  :Item;
BEGIN
  IF e.kind = AST.exprVal THEN
    item.kind := itemConst;
    IF e.typ.kind = AST.typeInteger THEN
      item.offset := e.iVal
    ELSE
      ASSERT(FALSE)
    END
  ELSIF e.kind = AST.exprIdentRef THEN
    ASSERT(e.decl.kind = AST.declVar);
    item.kind := itemVar;
    ASSERT(e.decl.offset # -1);
    item.offset := e.decl.offset;
    IF e.decl.nesting = 0 THEN
      item.r := rGB
    ELSE
      item.r := rSP
    END
  ELSIF e.kind = AST.exprFieldRef THEN
    GenExpr(e.lhs, item);
    ASSERT(item.kind IN {itemVar, itemRegI});
    ASSERT(e.decl.offset >= 0);
    item.offset := item.offset + e.decl.offset
  ELSIF e.kind = AST.exprArrayRef THEN
    (* rhs is array index *)
    GenExpr(e.rhs, rhs);
    (* Check bounds here! *)
    (* lhs is the array *)
    GenExpr(e.lhs, item);
    ASSERT(item.kind IN {itemVar, itemRegI});
    ASSERT(e.lhs.typ.kind = AST.typeArray);
    size := CalculateSize(e.lhs.typ.base);
    ASSERT(size > 0);
    IF rhs.kind = itemConst THEN
      item.offset := item.offset + size*rhs.offset
    ELSE
      Load(rhs);
      ASSERT(rhs.kind = itemReg);
      Emit(opMULI, rhs.r, rhs.r, 0, size);
      IF item.kind = itemVar THEN
        Emit(opADD, rhs.r, item.r, rhs.r, 0);
        item.kind := itemRegI;
        item.r := rhs.r
      ELSIF item.kind = itemRegI THEN
        Emit(opADD, item.r, item.r, rhs.r, 0);
        (* rhs.r no longer needed *)
        DecCurReg
      ELSE
        ASSERT(FALSE)
      END
    END
  ELSIF e.kind = AST.exprBinary THEN
    GenExpr(e.lhs, item);
    GenExpr(e.rhs, rhs);
    GenBinaryOp(e.op, item, rhs)
  ELSE
    ASSERT(FALSE)
  END
END GenExpr;

PROCEDURE GenStatements(s :AST.Stmt);
VAR
  e :AST.Expr;
  lhs, rhs :Item;
BEGIN
  WHILE s # NIL DO
    IF s.kind = AST.stmtAssign THEN
      e := s.cond;
      ASSERT(e.kind = AST.exprAssign);
      ASSERT(e.lhs.typ.kind = AST.typeInteger);
      GenExpr(e.rhs, rhs);
      Load(rhs);
      GenExpr(e.lhs, lhs);
      ASSERT(lhs.kind IN {itemVar, itemRegI});
      Emit(opSTW, rhs.r, lhs.r, 0, lhs.offset);
      IF lhs.kind = itemRegI THEN DecCurReg END;
      DecCurReg
    ELSIF s.kind = AST.stmtEmpty THEN
    ELSE
      ASSERT(FALSE)
    END;
    s := s.next
  END
END GenStatements;

PROCEDURE GenerateProc*(l :Lex.Lexer; d :AST.Decl);
VAR
  fp :INTEGER;
  vars :AST.Decl;
BEGIN
  ASSERT(d.kind = AST.declProcedure);
  cp := 0;
  d.offset := pc;
  GenQName(l, d.qname); GenStr(": code offset: "); Out.Int(d.offset); GenLn;
  fp := 4; (* Leave 4 bytes for return address. Params right below. *)
  vars := d.procVars;
  WHILE (vars # NIL) &
        ((vars.kind = AST.declParam) OR (vars.kind = AST.declVarParam)) DO
    ASSERT(vars.offset < 0);
    vars.offset := fp;
    Tab; GenStr("; "); Lex.OutStr(l, vars.qname.name);
    GenStr(" offset "); Out.Int(fp); GenLn;
    (*
     * All parameters except arrays are 4 bytes, because they are either
     * primitives, records (passed by reference), var parameters (also
     * passed by reference) or pointers.
     *)
    fp := fp + 4;
    IF AST.IsOpenArray(vars.typ) THEN
      Tab; GenStr("; "); Lex.OutStr(l, vars.qname.name); GenStr("__len");
      GenStr(" offset "); Out.Int(fp); GenLn;
      fp := fp + 4
    END;
    vars := vars.next
  END;
  fp := 0;
  WHILE (vars # NIL) & (vars.kind # AST.declEND) DO
    IF vars.kind = AST.declVar THEN
      fp := fp - CalculateSize(vars.typ);
      ASSERT(vars.offset < 0);
      vars.offset := fp;
      Tab; GenStr("; "); Lex.OutStr(l, vars.qname.name); GenStr(" offset "); Out.Int(fp); GenLn
    END;
    vars := vars.next
  END;
  (* Preamble *)
  IF fp < 0 THEN
    Emit(opADDI, rSP, rSP, 0, fp)
  END;
  GenStatements(d.body);
  (* Epilog *)
  IF fp < 0 THEN
    Emit(opADDI, rSP, rSP, 0, -fp);
  END;
  Emit(opRTS, 0, 0, 0, 0);
  DumpCode(l, d.offset)
END GenerateProc;

PROCEDURE GenCall*(proc :AST.Decl);
BEGIN
  Emit(opJSR, 0, 0, 0, proc.offset);
  codeBuffer[cp - 1].q := proc.qname
END GenCall;

PROCEDURE GenStartMain*;
BEGIN
  cp := 0;
  GenStr("__start__:"); GenLn
END GenStartMain;

PROCEDURE GenEndMain*(l :Lex.Lexer);
BEGIN
  Emit(opHALT, 0, 0, 0, 0);
  DumpCode(l, 10000)
END GenEndMain;

BEGIN
  globalOffset := 0;
  lastType := 0;
  pc := 0
END RCodegen.

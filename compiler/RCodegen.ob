MODULE RCodegen;

IMPORT AST, Decls, Lex, Out;

CONST
  CACHE_SIZE = 100;
  CODE_BUFFER = 2000; (* Code for the procedure being generated, for fixups. *)

  (* Traps *)
  NIL_TRAP    = -1;
  BOUNDS_TRAP = -2;
  ASSERT_TRAP = -3;

  LINK = 1; (* If set, branch preceded by link *)

  (* Opcodes *)
  opMOV = 0;  (* ra := rb                      *)
  opADD = 1;  (* ra := rb + rc                 *)
  opSUB = 2;  (* ra := rb - rc                 *)
  opMUL = 3;  (* ra := rb * rc                 *)
  opDIV = 4;  (* ra := rb / rc                 *)
  opMOD = 5;  (* ra := rb % rc                 *)
  opLSL = 6;  (* ra := rb << rc                *)
  opASR = 7;  (* ra := rb >> rc                *)
  opAND = 8;  (* ra := rb & rc                 *)
  opOR  = 9;  (* ra := rb | rc                 *)
  opXOR = 10; (* ra := rb ^ rc                 *)
  opANN = 11; (* ra := rb & ~n                 *)
  opCMP = 12; (* rb - rc, affects conditions   *)
  opLDW = 13; (* ra := Mem[rb + offset] (word) *)
  opLDB = 14; (* ra := Mem[rb + offset] (byte) *)
  opSTW = 15; (* Mem[rb + offset] := ra (word) *)
  opSTB = 16; (* Mem[rb + offset] := ra (byte) *)
  opCJP = 17; (* Case jump (pc offset)         *)
  opBRA = 19; (* PC := value (see below)       *)
  opBL  = 50; (* LR := PC + 1, PC := value     *)
  opBLr = 51; (* LR := PC + 1, PC := rc        *)
  opBrg = 52; (* PC := ra                      *)

  (* Branches have opcode opBRA, and r.c is    *)
  (* the conndition code, given below:         *)
  opBEQ = 1;  (* =  *) opBNE = 9;   (* #  *)
  opBLT = 5;  (* <  *) opBGE = 13;  (* >= *)
  opBLE = 6;  (* <= *) opBGT = 14;  (* >  *)
  opB   = 7;  (* branch always *)
  opBF  = 15; (* branch never, basically NOP *)
  opBHI = 12; (* Branch if high - ~(~C|Z) *)

  opMOVI = 100; (* ra := immediate       *)
  opADDI = 101; (* ra := rb + immediate  *)
  opSUBI = 102; (* ra := rb - immediate  *)
  opMULI = 103; (* ra := rb * immediate  *)
  opDIVI = 104; (* ra := rb / immediate  *)
  opMODI = 105; (* ra := rb % immediate  *)
  opLSLI = 106; (* ra := rb << immediate *)
  opASRI = 107; (* ra := rb >> immediate *)
  opANDI = 108; (* ra := rb & immediate  *)
  opORI  = 109; (* ra := rb | immediate  *)
  opXORI = 110; (* ra := rb ^ immediate  *)
  opANNI = 111; (* ra := rb & ~immediate *)
  opCMPI = 112; (* rb - immediate        *)

  opHALT = 1000;

  (* Registers *)
  rGB = 13; (* r13 = Global base   *)
  rSP = 14; (* r14 = Stack pointer *)
  rLR = 15; (* r15 = Link register *)

  (* Item kinds *)
  itemReg   = 1; (* Item is in register r                         *)
  itemVar   = 2; (* Item is a variable whose address is r+offset. *)
                 (* r is always SP or GP.                         *)
  itemConst = 3; (* Item value is a constant, stored in offset    *)
  itemRegI  = 4; (* Register indirect address.                    *)
                 (* Item's address is r+offset, this is similar   *)
                 (* to Var, except with Var, r is always SP or    *)
                 (* GB. with RegI, this is an allocated register, *)
                 (* which eventually needs to be released.        *)
  itemCond  = 5; (* Item is a condition. The CMP instruction was  *)
                 (* already generated, and this represents the    *)
                 (* condition associated with the relation.       *)

TYPE
  OpCode = INTEGER;
  Register = INTEGER;
  ItemKind = INTEGER;
  Instruction = RECORD
    op         :OpCode;
    ra, rb, rc :Register;
    value      :INTEGER;  (* If op is an immediate, e.g., ra := rb + value    *)
                          (* if op is a branch, this is the branch offset     *)
    q          :AST.QName;
  END;
  Item = RECORD
    kind   :ItemKind;
    r      :Register;
    offset :INTEGER;
    opCond :OpCode;  (* If kind is itemCond, this is the branch type. *)
    isByte :BOOLEAN; (* True for accessing a single byte              *)
  END;

VAR
  GenExpr      :PROCEDURE(l :Lex.Lexer; e :AST.Expr; VAR item :Item;
                          VAR parentTrueChain, parentFalseChain :INTEGER);
  GenCase      :PROCEDURE(l :Lex.Lexer; s :AST.Stmt);
  typeCache    :ARRAY CACHE_SIZE OF AST.Type; (* Already reached types        *)
  typeSizes    :ARRAY CACHE_SIZE OF INTEGER;  (* Map RECORD and ARRAY to size *)
  codeBuffer   :ARRAY CODE_BUFFER OF Instruction;
  globalOffset :INTEGER;                 (* Offset of variable to global base *)
  lastType     :INTEGER;
  pc           :INTEGER; (* (Global) program counter. This is the offset from *)
                         (* the start of code generated. This is measured in  *)
                         (* instructions, not bytes, so it is not a multiple  *)
                         (* of 4.                                             *)
  cp           :INTEGER; (* Code pointer. This is an offset into the code     *)
                         (* buffer, so 0 represents the start of a procedure. *)
                         (* It is measured in instructions, not bytes.        *)
  curReg       :INTEGER; (* Number [0..13] of the next available register     *)
  stackOffset  :INTEGER; (* When there are nested function calls, the         *)
                         (* compiler must save earlier expressions on the     *)
                         (* stack. For example, when compiling f(0, 1, g(x))  *)
                         (* r0 contains 0 and r1 contains 1. Both are saved   *)
                         (* on the stack so that g can be called. This means  *)
                         (* SP+4 doesn't point to the first parameter or the  *)
                         (* local stack frame, temporarily. During lookup of  *)
                         (* x for g, the SP needs to be offset, restored when *)
                         (* the registers are restored.                       *)
  genCode      :BOOLEAN;
  genBoundsCheck :BOOLEAN;
  genNilCheck    :BOOLEAN;
  mainStartPc  :INTEGER;
  strings      :Lex.StringPool;

PROCEDURE Emit(op :OpCode; ra, rb, rc :Register; value :INTEGER);
BEGIN
  codeBuffer[cp].op := op;
  codeBuffer[cp].ra := ra;
  codeBuffer[cp].rb := rb;
  codeBuffer[cp].rc := rc;
  codeBuffer[cp].value := value;
  INC(pc);
  INC(cp);
  ASSERT(cp < CODE_BUFFER)
END Emit;

PROCEDURE GenStr(s :ARRAY OF CHAR);
BEGIN
  Out.Str(s);
END GenStr;

PROCEDURE Tab;
BEGIN
  GenStr(9X)
END Tab;

PROCEDURE GenLn;
BEGIN
  Out.Ln
END GenLn;

PROCEDURE GenReg(r :Register);
BEGIN
  IF r < rGB THEN
    GenStr("R"); Out.Int(r)
  ELSIF r = rGB THEN
    GenStr("GB")
  ELSIF r = rSP THEN
    GenStr("SP")
  ELSIF r = rLR THEN
    GenStr("LR")
  ELSE
    ASSERT(FALSE)
  END
END GenReg;

PROCEDURE Gen2(op :ARRAY OF CHAR; ra, rb :Register; value :INTEGER);
BEGIN
  GenStr(op);
  GenStr(" ");
  IF op # "CMP" THEN
    GenReg(ra);
    GenStr(", ");
  END;
  GenReg(rb);
  GenStr(", #");
  Out.Int(value)
END Gen2;

PROCEDURE Gen3(op :ARRAY OF CHAR; ra, rb, rc :Register);
BEGIN
  GenStr(op);
  GenStr(" ");
  IF op # "CMP" THEN
    GenReg(ra);
    GenStr(", ");
  END;
  GenReg(rb);
  GenStr(", ");
  GenReg(rc)
END Gen3;

PROCEDURE GenQName(l :Lex.Lexer; name :AST.QName);
BEGIN
  IF name.moduleName > 0 THEN
    Lex.OutStr(l, name.moduleName);
    GenStr("_");
  END;
  IF name.name > 0 THEN
    Lex.OutStr(l, name.name);
  END;
END GenQName;

PROCEDURE DumpAssembly(l :Lex.Lexer; delta :INTEGER);
VAR
  i  :INTEGER;
  op :OpCode;
BEGIN
  i := 0;
  WHILE i < cp DO
    op := codeBuffer[i].op;
    Out.Int(i + delta); Tab;
    IF op = opMOV THEN
      GenStr("MOV "); GenReg(codeBuffer[i].ra); GenStr(", "); GenReg(codeBuffer[i].rb);
    ELSIF op = opMOVI THEN
      GenStr("MOV "); GenReg(codeBuffer[i].ra); GenStr(", #"); Out.Int(codeBuffer[i].value);
    ELSIF op = opADD THEN
      Gen3("ADD", codeBuffer[i].ra, codeBuffer[i].rb, codeBuffer[i].rc)
    ELSIF op = opSUB THEN
      Gen3("SUB", codeBuffer[i].ra, codeBuffer[i].rb, codeBuffer[i].rc)
    ELSIF op = opMUL THEN
      Gen3("MUL", codeBuffer[i].ra, codeBuffer[i].rb, codeBuffer[i].rc)
    ELSIF op = opDIV THEN
      Gen3("DIV", codeBuffer[i].ra, codeBuffer[i].rb, codeBuffer[i].rc)
    ELSIF op = opMOD THEN
      Gen3("MOD", codeBuffer[i].ra, codeBuffer[i].rb, codeBuffer[i].rc)
    ELSIF op = opLSL THEN
      Gen3("LSL", codeBuffer[i].ra, codeBuffer[i].rb, codeBuffer[i].rc)
    ELSIF op = opASR THEN
      Gen3("ASR", codeBuffer[i].ra, codeBuffer[i].rb, codeBuffer[i].rc)
    ELSIF op = opAND THEN
      Gen3("AND", codeBuffer[i].ra, codeBuffer[i].rb, codeBuffer[i].rc)
    ELSIF op = opOR THEN
      Gen3("OR", codeBuffer[i].ra, codeBuffer[i].rb, codeBuffer[i].rc)
    ELSIF op = opXOR THEN
      Gen3("XOR", codeBuffer[i].ra, codeBuffer[i].rb, codeBuffer[i].rc)
    ELSIF op = opANN THEN
      Gen3("ANN", codeBuffer[i].ra, codeBuffer[i].rb, codeBuffer[i].rc)
    ELSIF op = opCMP THEN
      Gen3("CMP", codeBuffer[i].ra, codeBuffer[i].rb, codeBuffer[i].rc)
    ELSIF op = opADDI THEN
      Gen2("ADD", codeBuffer[i].ra, codeBuffer[i].rb, codeBuffer[i].value)
    ELSIF op = opSUBI THEN
      Gen2("SUB", codeBuffer[i].ra, codeBuffer[i].rb, codeBuffer[i].value)
    ELSIF op = opMULI THEN
      Gen2("MUL", codeBuffer[i].ra, codeBuffer[i].rb, codeBuffer[i].value)
    ELSIF op = opDIVI THEN
      Gen2("DIV", codeBuffer[i].ra, codeBuffer[i].rb, codeBuffer[i].value)
    ELSIF op = opMODI THEN
      Gen2("MOD", codeBuffer[i].ra, codeBuffer[i].rb, codeBuffer[i].value)
    ELSIF op = opLSLI THEN
      Gen2("LSL", codeBuffer[i].ra, codeBuffer[i].rb, codeBuffer[i].value)
    ELSIF op = opASRI THEN
      Gen2("ASR", codeBuffer[i].ra, codeBuffer[i].rb, codeBuffer[i].value)
    ELSIF op = opANDI THEN
      Gen2("AND", codeBuffer[i].ra, codeBuffer[i].rb, codeBuffer[i].value)
    ELSIF op = opORI THEN
      Gen2("OR", codeBuffer[i].ra, codeBuffer[i].rb, codeBuffer[i].value)
    ELSIF op = opXORI THEN
      Gen2("XOR", codeBuffer[i].ra, codeBuffer[i].rb, codeBuffer[i].value)
    ELSIF op = opANNI THEN
      Gen2("ANN", codeBuffer[i].ra, codeBuffer[i].rb, codeBuffer[i].value)
    ELSIF op = opCMPI THEN
      Gen2("CMP", codeBuffer[i].ra, codeBuffer[i].rb, codeBuffer[i].value)
    ELSIF op = opLDW THEN
      Gen2("LDW", codeBuffer[i].ra, codeBuffer[i].rb, codeBuffer[i].value)
    ELSIF op = opLDB THEN
      Gen2("LDB", codeBuffer[i].ra, codeBuffer[i].rb, codeBuffer[i].value)
    ELSIF op = opSTW THEN
      Gen2("STW", codeBuffer[i].ra, codeBuffer[i].rb, codeBuffer[i].value)
    ELSIF op = opSTB THEN
      Gen2("STB", codeBuffer[i].ra, codeBuffer[i].rb, codeBuffer[i].value)
    ELSIF op = opCJP THEN
      GenStr("CASE "); Out.Int(codeBuffer[i].value)
    ELSIF op = opBRA THEN
      CASE codeBuffer[i].rc OF
        opBEQ: GenStr("BEQ ")
        | opBNE: GenStr("BNE ")
        | opBLT: GenStr("BLT ")
        | opBGT: GenStr("BGT ")
        | opBGE: GenStr("BGE ")
        | opBLE: GenStr("BLE ")
        | opB: GenStr("B ");
        | opBF: GenStr("BF ");
        | opBHI: GenStr("BHI ");
      END;
      IF codeBuffer[i].value >= 0 THEN
        Out.Int(codeBuffer[i].value + delta)
      ELSE
        Out.Int(codeBuffer[i].value)
      END
    ELSIF op = opBL THEN
      GenStr("BL "); Out.Int(codeBuffer[i].value);
      GenStr(" ("); GenQName(l, codeBuffer[i].q);
      GenStr(")")
    ELSIF op = opBLr THEN
      GenStr("BL "); GenReg(codeBuffer[i].rc)
    ELSIF op = opBrg THEN
      GenStr("B "); GenReg(codeBuffer[i].ra)
    ELSIF op = opHALT THEN
      GenStr("HALT")
    ELSE
      ASSERT(FALSE)
    END;
    GenLn;
    INC(i)
  END
END DumpAssembly;

PROCEDURE DumpCode(delta :INTEGER);
VAR
  i, offset :INTEGER;
  op :OpCode;
BEGIN
  i := 0;
  WHILE i < cp DO
    offset := codeBuffer[i].value;
    op := codeBuffer[i].op;
    GenStr("{");
    IF op = opMOV THEN
      GenStr("MOV");
    ELSIF op = opADD THEN
      GenStr("ADD");
    ELSIF op = opSUB THEN
      GenStr("SUB");
    ELSIF op = opMUL THEN
      GenStr("MUL");
    ELSIF op = opDIV THEN
      GenStr("DIV");
    ELSIF op = opMOD THEN
      GenStr("MOD");
    ELSIF op = opLSL THEN
      GenStr("LSL");
    ELSIF op = opASR THEN
      GenStr("ASR");
    ELSIF op = opAND THEN
      GenStr("AND");
    ELSIF op = opOR THEN
      GenStr("OR");
    ELSIF op = opXOR THEN
      GenStr("XOR");
    ELSIF op = opANN THEN
      GenStr("ANN");
    ELSIF op = opCMP THEN
      GenStr("CMP");
    ELSIF op = opMOVI THEN
      GenStr("MOVI");
    ELSIF op = opADDI THEN
      GenStr("ADDI");
    ELSIF op = opSUBI THEN
      GenStr("SUBI");
    ELSIF op = opMULI THEN
      GenStr("MULI");
    ELSIF op = opDIVI THEN
      GenStr("DIVI");
    ELSIF op = opMODI THEN
      GenStr("MODI");
    ELSIF op = opLSLI THEN
      GenStr("LSLI");
    ELSIF op = opASRI THEN
      GenStr("ASRI");
    ELSIF op = opANDI THEN
      GenStr("ANDI");
    ELSIF op = opORI THEN
      GenStr("ORI");
    ELSIF op = opXORI THEN
      GenStr("XORI");
    ELSIF op = opANNI THEN
      GenStr("ANNI");
    ELSIF op = opCMPI THEN
      GenStr("CMPI");
    ELSIF op = opLDW THEN
      GenStr("LDW");
    ELSIF op = opLDB THEN
      GenStr("LDB");
    ELSIF op = opSTW THEN
      GenStr("STW");
    ELSIF op = opSTB THEN
      GenStr("STB");
    ELSIF op = opCJP THEN
      GenStr("CJP");
    ELSIF op = opBRA THEN
      IF offset >= 0 THEN
        INC(offset, delta);
      END;
      CASE codeBuffer[i].rc OF
        opBEQ: GenStr("BEQ ")
        | opBNE: GenStr("BNE ")
        | opBLT: GenStr("BLT ")
        | opBGT: GenStr("BGT ")
        | opBGE: GenStr("BGE ")
        | opBLE: GenStr("BLE ")
        | opB: GenStr("B ");
        | opBF: GenStr("BF ");
        | opBHI: GenStr("BHI ");
      END;
    ELSIF op = opBL THEN
      GenStr("BL");
    ELSIF op = opBLr THEN
      GenStr("BLr");
    ELSIF op = opBrg THEN
      GenStr("Br");
    ELSIF op = opHALT THEN
      GenStr("HALT");
    ELSE
      ASSERT(FALSE);
    END;
    GenStr(", ");
    GenReg(codeBuffer[i].ra);
    GenStr(", ");
    GenReg(codeBuffer[i].rb);
    GenStr(", ");
    GenReg(codeBuffer[i].rc);
    GenStr(", ");
    Out.Int(offset);
    GenStr("},");
    GenLn;
    INC(i)
  END
END DumpCode;

PROCEDURE FindOrAddType(t :AST.Type) :INTEGER;
VAR
  index :INTEGER;
  found :BOOLEAN;
BEGIN
  index := 0; found := FALSE;
  WHILE (index < lastType) & ~found DO
    IF typeCache[index] = t THEN
      found := TRUE
    ELSE
      INC(index)
    END
  END;
  IF ~found THEN
    ASSERT(index < CACHE_SIZE);
    typeCache[index] := t;
    typeSizes[index] := -1;
    INC(lastType)
  END
  RETURN index
END FindOrAddType;

PROCEDURE CalculateSize(t :AST.Type) :INTEGER;
VAR
  i, s :INTEGER;
  f :AST.Decl;
BEGIN
  IF t.kind IN {AST.typeInteger, AST.typeReal, AST.typeBoolean, AST.typeChar,
                AST.typeSet, AST.typePointer, AST.typeProcedure} THEN
    s := 4
  ELSIF t.kind = AST.typeRecord THEN
    i := FindOrAddType(t);
    s := typeSizes[i];
    IF typeSizes[i] < 0 THEN
      (* Not found yet. Record size is size of fields *)
      s := 0;
      IF t.needTypeInfo THEN s := 4 END;
      f := t.fields;
      WHILE (f # NIL) & (f.kind # AST.declEND) DO
        f.offset := s;
        s := s + CalculateSize(f.typ);
        f := f.next
      END;
      typeSizes[i] := s
    END;
  ELSIF AST.IsOpenArray(t) THEN
    s := 4;
  ELSIF t.kind = AST.typeArray THEN
    i := FindOrAddType(t);
    s := typeSizes[i];
    IF typeSizes[i] < 0 THEN
      (* Not found yet. Array size is length * element size *)
      ASSERT(t.length > 0);
      IF t.base.kind = AST.typeChar THEN
        (* Strings are packed up to a multiple of 4 bytes *)
        s := t.length;
        IF (s MOD 4) # 0 THEN
          s := t.length + 4 - (t.length MOD 4)
        END
      ELSE
        s := t.length * CalculateSize(t.base)
      END;
      typeSizes[i] := s
    END
  ELSE
    ASSERT(FALSE)
  END;
  RETURN s
END CalculateSize;

PROCEDURE IncCurReg;
BEGIN
  INC(curReg);
  IF curReg = rGB THEN
    Out.ErrStr("Out of registers"); Out.ErrLn;
    ASSERT(FALSE)
  END
END IncCurReg;

PROCEDURE DecCurReg;
BEGIN
  DEC(curReg);
  ASSERT(curReg >= 0)
END DecCurReg;

PROCEDURE AddToChain(VAR chain :INTEGER);
(* This is called after a branch has been emitted. It updates the previous  *)
(* instruction in the buffer to add it to the "chain" and chain points to   *)
(* this updated instruction. The end result is a linked list of instruction *)
(* addresses, starting at "chain", and ending at 0. This is later fixed up  *)
(* using the FixupChain procedure.                                          *)
BEGIN
  codeBuffer[cp-1].value := chain;
  chain := cp - 1
END AddToChain;

PROCEDURE FixChain(chain, fix :INTEGER);
VAR
  next :INTEGER;
BEGIN
  WHILE chain # 0 DO
    next := codeBuffer[chain].value;
    codeBuffer[chain].value:= fix;
    chain := next
  END
END FixChain;

(* Loads a value from an item into a register. *)
PROCEDURE Load(VAR item :Item);
BEGIN
  IF item.kind = itemVar THEN
    IF item.isByte THEN
      Emit(opLDB, curReg, item.r, 0, item.offset)
    ELSE
      Emit(opLDW, curReg, item.r, 0, item.offset)
    END;
    item.r := curReg;
    IncCurReg
  ELSIF item.kind = itemRegI THEN
    IF item.isByte THEN
      Emit(opLDB, item.r, item.r, 0, item.offset)
    ELSE
      Emit(opLDW, item.r, item.r, 0, item.offset)
    END
    (* item.r already allocated *)
  ELSIF item.kind = itemConst THEN
    Emit(opMOVI, curReg, 0, 0, item.offset);
    item.r := curReg;
    IncCurReg
  ELSIF item.kind = itemReg THEN
    (* Already in a register, do nothing *)
  ELSE
    ASSERT(FALSE)
  END;
  item.kind := itemReg
END Load;

(* If a value isn't a condition code, load and transform into a condition. *)
PROCEDURE LoadCond(VAR item :Item);
BEGIN
  IF item.kind # itemCond THEN
    IF item.kind = itemConst THEN
      IF item.offset = 1 THEN
        item.opCond := opB
      ELSE
        item.opCond := opBF
      END
    ELSE
      Load(item);
      ASSERT(item.r = 0);
      Emit(opCMPI, item.r, item.r, 0, 0);
      (* Anything nonzero is true, although item.r really should be 0 or 1 *)
      item.opCond := opBNE;
      (* Boolean value no longer needed *)
      DecCurReg
    END;
    item.kind := itemCond
  END
END LoadCond;

(* Loads any value, including conditions, into a register. *)
PROCEDURE LoadValue(VAR item :Item; trueChain, falseChain :INTEGER);
BEGIN
  IF item.kind = itemCond THEN
    Emit(opBRA, 0, 0, item.opCond, cp+3);
    (* This is the false for cond, so falseChain ends here *)
    FixChain(falseChain, cp);
    Emit(opMOVI, curReg, 0, 0, 0);
    Emit(opBRA, 0, 0, opB, cp+2);
    (* This is the true for cond, so trueChain ends here *)
    FixChain(trueChain, cp);
    Emit(opMOVI, curReg, 0, 0, 1);
    item.r := curReg;
    item.kind := itemReg;
    IncCurReg
  ELSE
    Load(item)
  END
END LoadValue;

(* Loads the address of a variable into a register.                          *)
(* If this is already in a register (e.g., RegI) no new register is reserve. *)
(* However, for a varialble (relative to SP or GB) a new register allocated. *)
PROCEDURE LoadAddress(VAR item :Item);
BEGIN
  IF item.kind = itemVar THEN
    (* Reg is SP, so reserve a new register *)
    Emit(opADDI, curReg, item.r, 0, item.offset);
    item.offset := 0;
    item.r := curReg;
    item.kind := itemRegI;
    IncCurReg
  ELSIF item.kind = itemRegI THEN
    IF item.offset > 0 THEN
      Emit(opADDI, item.r, item.r, 0, item.offset)
    END
  ELSE
    ASSERT(FALSE)
  END
END LoadAddress;

PROCEDURE AllocateGlobals*(l :Lex.Lexer; d :AST.Decl);
BEGIN
  ASSERT(d.kind = AST.declVar);
  ASSERT(d.nesting = 0);
  ASSERT(d.offset = -1);
  d.offset := globalOffset;
  IF ~genCode THEN
    GenStr("; "); GenQName(l, d.qname); GenStr(" offset "); Out.Int(d.offset); GenLn;
  END;
  globalOffset := globalOffset + CalculateSize(d.typ)
END AllocateGlobals;

PROCEDURE SaveRegisters;
VAR
  i, r :INTEGER;
BEGIN
  IF curReg > 0 THEN
    Emit(opSUBI, rSP, rSP, 0, curReg * 4)
  END;
  stackOffset := stackOffset + curReg * 4;
  i := 0;
  r := 0;
  WHILE r < curReg DO
    Emit(opSTW, r, rSP, 0, i);
    i := i + 4;
    INC(r)
  END
END SaveRegisters;

PROCEDURE RestoreRegisters;
VAR
  i, r :INTEGER;
BEGIN
  i := 0;
  r := 0;
  WHILE r < curReg DO
    Emit(opLDW, r, rSP, 0, i);
    i := i + 4;
    INC(r)
  END;
  stackOffset := stackOffset - curReg * 4;
  IF curReg > 0 THEN
    Emit(opADDI, rSP, rSP, 0, curReg * 4)
  END;
END RestoreRegisters;

PROCEDURE GenCompare(VAR lhs, rhs:Item; op :OpCode);
BEGIN
  IF rhs.kind = itemConst THEN
    Load(lhs);
    Emit(opCMPI, lhs.r, lhs.r, 0, rhs.offset)
  ELSE
    Load(lhs);
    Load(rhs);
    Emit(opCMP, lhs.r, lhs.r, rhs.r, 0);
    DecCurReg
  END;
  lhs.kind := itemCond;
  lhs.opCond := op;
  (* We don't need or want the result of the lhs, which is always loaded *)
  DecCurReg
END GenCompare;

PROCEDURE NegateCond(cond :OpCode) :OpCode;
BEGIN
  IF cond < 8 THEN cond := cond + 8 ELSE cond := cond - 8 END
  RETURN cond
END NegateCond;

PROCEDURE GenIntegerOp(op :Lex.TokenKind; VAR lhs, rhs :Item);
BEGIN
  IF op = Lex.tPLUS THEN
    IF lhs.kind = itemConst THEN
      Load(rhs);
      lhs.kind := rhs.kind; lhs.r := rhs.r;
      Emit(opADDI, lhs.r, lhs.r, 0, lhs.offset)
    ELSIF rhs.kind = itemConst THEN
      Load(lhs);
      Emit(opADDI, lhs.r, lhs.r, 0, rhs.offset)
    ELSE
      Load(lhs);
      Load(rhs);
      Emit(opADD, lhs.r, lhs.r, rhs.r, 0);
      DecCurReg
    END
  ELSIF op = Lex.tMINUS THEN
    IF rhs.kind = itemConst THEN
      Load(lhs);
      Emit(opSUBI, lhs.r, lhs.r, 0, rhs.offset)
    ELSE
      Load(lhs);
      Load(rhs);
      Emit(opSUB, lhs.r, lhs.r, rhs.r, 0);
      DecCurReg
    END
  ELSIF op = Lex.tSTAR THEN
    IF lhs.kind = itemConst THEN
      Load(rhs);
      lhs.kind := rhs.kind; lhs.r := rhs.r;
      Emit(opMULI, lhs.r, lhs.r, 0, lhs.offset)
    ELSIF rhs.kind = itemConst THEN
      Load(lhs);
      Emit(opMULI, lhs.r, lhs.r, 0, rhs.offset)
    ELSE
      Load(lhs);
      Load(rhs);
      Emit(opMUL, lhs.r, lhs.r, rhs.r, 0);
      DecCurReg
    END
  ELSIF op = Lex.tDIV THEN
    IF rhs.kind = itemConst THEN
      Load(lhs);
      Emit(opDIVI, lhs.r, lhs.r, 0, rhs.offset)
    ELSE
      Load(lhs);
      Load(rhs);
      Emit(opDIV, lhs.r, lhs.r, rhs.r, 0);
      DecCurReg
    END
  ELSIF op = Lex.tMOD THEN
    IF rhs.kind = itemConst THEN
      Load(lhs);
      Emit(opMODI, lhs.r, lhs.r, 0, rhs.offset)
    ELSE
      Load(lhs);
      Load(rhs);
      Emit(opMOD, lhs.r, lhs.r, rhs.r, 0);
      DecCurReg
    END
  ELSIF op = Lex.tBITAND THEN
    IF rhs.kind = itemConst THEN
      Load(lhs);
      Emit(opANDI, lhs.r, lhs.r, 0, rhs.offset)
    ELSE
      Load(lhs);
      Load(rhs);
      Emit(opAND, lhs.r, lhs.r, rhs.r, 0);
      DecCurReg
    END
  ELSIF op = Lex.tBITXOR THEN
    IF rhs.kind = itemConst THEN
      Load(lhs);
      Emit(opXORI, lhs.r, lhs.r, 0, rhs.offset)
    ELSE
      Load(lhs);
      Load(rhs);
      Emit(opXOR, lhs.r, lhs.r, rhs.r, 0);
      DecCurReg
    END
  ELSIF op = Lex.tDOTDOT THEN
    Load(lhs);
    Load(rhs);
    (* {m .. n}, m is lhs, n is rhs *)
    (* conceptually, this is {0 .. n} - {0 .. m-1} *)

    (* Start with one zero, FFFFFFFE, and shift left to get n zeros, *)
    (* then invert to get n ones.                                    *)
    (* If rhs is a constant, this could be precomputed and optimized *)
    Emit(opMOVI, curReg, 0, 0, -2);
    Emit(opLSL, rhs.r, curReg, rhs.r, 0);
    Emit(opXORI, rhs.r, rhs.r, 0, -1);

    (* Start with one zero, FFFFFFFF, and shift left to get m-1      *)
    (* zeros, then invert to get m-1 ones.                           *)
    (* If lhs is a constant, this could be precomputed and optimized *)
    Emit(opMOVI, curReg, 0, 0, -1);
    Emit(opLSL, lhs.r, curReg, lhs.r, 0);
    Emit(opXORI, lhs.r, lhs.r, 0, -1);

    Emit(opANN, lhs.r, rhs.r, lhs.r, 0);
    DecCurReg
  ELSIF op = Lex.tEQ THEN
    GenCompare(lhs, rhs, opBEQ)
  ELSIF op = Lex.tPOUND THEN
    GenCompare(lhs, rhs, opBNE)
  ELSIF op = Lex.tLT THEN
    GenCompare(lhs, rhs, opBLT)
  ELSIF op = Lex.tGT THEN
    GenCompare(lhs, rhs, opBGT)
  ELSIF op = Lex.tLTEQ THEN
    GenCompare(lhs, rhs, opBLE)
  ELSIF op = Lex.tGTEQ THEN
    GenCompare(lhs, rhs, opBGE)
  ELSE
    ASSERT(FALSE)
  END
END GenIntegerOp;

PROCEDURE GenSetOp(op :Lex.TokenKind; VAR lhs, rhs :Item);
BEGIN
  IF op = Lex.tPLUS THEN
    IF lhs.kind = itemConst THEN
      Load(rhs);
      lhs.kind := rhs.kind; lhs.r := rhs.r;
      Emit(opORI, lhs.r, lhs.r, 0, lhs.offset)
    ELSIF rhs.kind = itemConst THEN
      Load(lhs);
      Emit(opORI, lhs.r, lhs.r, 0, rhs.offset)
    ELSE
      Load(lhs);
      Load(rhs);
      Emit(opOR, lhs.r, lhs.r, rhs.r, 0);
      DecCurReg
    END
  ELSIF op = Lex.tMINUS THEN
    IF rhs.kind = itemConst THEN
      Load(lhs);
      Emit(opANNI, lhs.r, lhs.r, 0, rhs.offset)
    ELSE
      Load(lhs);
      Load(rhs);
      Emit(opANN, lhs.r, lhs.r, rhs.r, 0);
      DecCurReg
    END
  ELSIF op = Lex.tSTAR THEN
    IF lhs.kind = itemConst THEN
      Load(rhs);
      lhs.kind := rhs.kind; lhs.r := rhs.r;
      Emit(opANDI, lhs.r, lhs.r, 0, lhs.offset)
    ELSIF rhs.kind = itemConst THEN
      Load(lhs);
      Emit(opANDI, lhs.r, lhs.r, 0, rhs.offset)
    ELSE
      Load(lhs);
      Load(rhs);
      Emit(opAND, lhs.r, lhs.r, rhs.r, 0);
      DecCurReg
    END
  ELSIF op = Lex.tSLASH THEN
    IF rhs.kind = itemConst THEN
      Load(lhs);
      Emit(opXORI, lhs.r, lhs.r, 0, rhs.offset)
    ELSE
      Load(lhs);
      Load(rhs);
      Emit(opXOR, lhs.r, lhs.r, rhs.r, 0);
      DecCurReg
    END
  ELSIF op = Lex.tEQ THEN
    GenCompare(lhs, rhs, opBEQ)
  ELSIF op = Lex.tPOUND THEN
    GenCompare(lhs, rhs, opBNE)
  ELSIF op = Lex.tIN THEN
    Load(lhs);
    Emit(opMOVI, curReg, 0, 0, 1);
    Emit(opLSL, lhs.r, curReg, lhs.r, 0);
    IF rhs.kind = itemConst THEN
      Emit(opANDI, lhs.r, lhs.r, 0, rhs.offset)
    ELSE
      Load(rhs);
      Emit(opAND, lhs.r, lhs.r, rhs.r, 0);
      DecCurReg
    END;
    lhs.kind := itemCond;
    lhs.opCond := opBNE;
    (* We don't need or want the result of the lhs, which is always loaded *)
    DecCurReg
  ELSE
    ASSERT(FALSE)
  END
END GenSetOp;

PROCEDURE GenLengthof(l :Lex.Lexer; VAR item :Item; e :AST.Expr);
BEGIN
  IF e.typ.kind = AST.typeString THEN
    item.kind := itemConst;
    item.offset := Lex.StringLenI(l, e.iVal) + 1;
    Load(item);
  ELSIF e.typ.length > 0 THEN
    item.kind := itemConst;
    item.offset := e.typ.length;
    Load(item);
  ELSIF e.typ.kind = AST.typeBuffer THEN
    (* TODO: buffer support *)
    ASSERT(FALSE);
  ELSE
    ASSERT(e.kind = AST.exprIdentRef);
    ASSERT(e.decl # NIL);
    ASSERT((e.decl.kind = AST.declVarParam) OR (e.decl.kind = AST.declParam));
    ASSERT(e.decl.offset # -1);
    item.kind := itemVar;
    item.isByte := FALSE;
    item.r := rSP;
    item.offset := stackOffset + e.decl.offset + 4; (* The extra param for length *)
    Load(item);
  END;
END GenLengthof;

PROCEDURE GenVal(l :Lex.Lexer; e :AST.Expr; VAR item :Item);
BEGIN
  item.kind := itemConst;
  IF e.typ.kind IN {AST.typeInteger, AST.typeBoolean, AST.typeChar} THEN
    item.offset := e.iVal
  ELSIF e.typ.kind = AST.typeSet THEN
    item.offset := ORD(e.setVal)
  ELSIF e.typ.kind = AST.typeNil THEN
    item.offset := 0
  ELSIF e.typ.kind = AST.typeString THEN
    item.kind := itemVar;
    item.offset := Lex.CopyLexToPool(l, e.iVal, strings) + globalOffset;
    Lex.PadStringPool(strings);
    item.r := rGB;
  ELSE
    ASSERT(FALSE)
  END
END GenVal;

PROCEDURE GenIdentRef(e :AST.Expr; VAR item :Item);
BEGIN
  IF (e.decl.kind = AST.declVar) OR
     ((e.decl.kind = AST.declParam) &
      ~(e.typ.kind IN {AST.typeArray, AST.typeRecord})) THEN
    (* Vars and params (except arrays and records) are values *)
    item.kind := itemVar;
    ASSERT(e.decl.offset # -1);
    item.offset := e.decl.offset;
    IF (e.decl.kind = AST.declVar) & (e.decl.nesting = 0) THEN
      item.r := rGB
    ELSE
      item.r := rSP;
      item.offset := item.offset + stackOffset
    END
  ELSIF (e.decl.kind = AST.declVarParam) OR
     ((e.decl.kind = AST.declParam) &
      (e.typ.kind IN {AST.typeArray, AST.typeRecord})) THEN
    CalculateSize(e.typ);
    (* Var params, arrays, and records are passed by reference *)
    ASSERT(e.decl.offset # -1);
    Emit(opLDW, curReg, rSP, 0, e.decl.offset + stackOffset);
    item.kind := itemRegI;
    item.r := curReg;
    item.offset := 0;
    IncCurReg
  ELSIF e.decl.kind = AST.declProcedure THEN
    ASSERT((e.decl.offset >= 0) OR (e.decl.offset <= -10));
    item.kind := itemConst;
    item.offset := e.decl.offset
  ELSE
    ASSERT(FALSE)
  END
END GenIdentRef;

(* Copy structs or arrays *)
PROCEDURE CopyStructure(l :Lex.Lexer; e :AST.Expr; VAR item, rhs :Item);
VAR
  i, structSize :INTEGER;
  lengthItem    :Item;
BEGIN
  structSize := CalculateSize(e.lhs.typ);
  IF (structSize > 30) OR
     AST.IsOpenArray(e.rhs.typ) OR
     (e.rhs.typ.kind = AST.typeString) THEN
    (* Loop based copy *)
    LoadAddress(item);
    ASSERT(item.offset = 0);
    LoadAddress(rhs);
    IF AST.IsOpenArray(e.rhs.typ) OR (e.rhs.typ.kind = AST.typeString) THEN
      ASSERT(e.lhs.typ.base.kind = AST.typeChar);
      GenLengthof(l, lengthItem, e.rhs);
      Emit(opCMPI, lengthItem.r, lengthItem.r, 0, structSize);
      Emit(opBRA, LINK, 0, opBGT, BOUNDS_TRAP);
    ELSE
      Emit(opMOVI, curReg, 0, 0, structSize);
      IncCurReg;
    END;
    Emit(opLDW, curReg, rhs.r, 0, rhs.offset);
    Emit(opSTW, curReg, item.r, 0, item.offset);
    Emit(opADDI, item.r, item.r, 0, 4);
    Emit(opADDI, rhs.r, rhs.r, 0, 4);
    Emit(opSUBI, curReg-1, curReg-1, 0, 4);
    Emit(opBRA, 0, 0, opBGT, cp-5);
    DecCurReg; DecCurReg; DecCurReg
  ELSE
    (* Unrolled copy from dst to src *)
    i := 0;
    WHILE i < structSize DO
      Emit(opLDW, curReg, rhs.r, 0, rhs.offset + i);
      Emit(opSTW, curReg, item.r, 0, item.offset + i);
      i := i + 4
    END;
    IF rhs.kind = itemRegI THEN DecCurReg END;
    IF item.kind = itemRegI THEN DecCurReg END;
  END
END CopyStructure;

PROCEDURE GenAssign(l :Lex.Lexer; e :AST.Expr; VAR item :Item;
                    VAR parentTrueChain, parentFalseChain :INTEGER);
VAR
  rhs                             :Item;
  localTrueChain, localFalseChain :INTEGER;
BEGIN
  GenExpr(l, e.lhs, item, parentTrueChain, parentFalseChain);
  localTrueChain := 0; localFalseChain := 0;
  GenExpr(l, e.rhs, rhs, localTrueChain, localFalseChain);

  IF e.lhs.typ.kind IN {AST.typeRecord, AST.typeArray} THEN
    CopyStructure(l, e, item, rhs)
  ELSE
    LoadValue(rhs, localTrueChain, localFalseChain);
    ASSERT(item.kind IN {itemVar, itemRegI});
    IF item.isByte THEN
      Emit(opSTB, rhs.r, item.r, 0, item.offset);
    ELSE
      Emit(opSTW, rhs.r, item.r, 0, item.offset)
    END;
    IF item.kind = itemRegI THEN DecCurReg END;
    DecCurReg
  END
END GenAssign;

PROCEDURE GenFieldRef(l :Lex.Lexer; e :AST.Expr; VAR item :Item;
                      VAR parentTrueChain, parentFalseChain :INTEGER);
BEGIN
  GenExpr(l, e.lhs, item, parentTrueChain, parentFalseChain);
  ASSERT(item.kind IN {itemVar, itemRegI});
  ASSERT(e.decl.offset >= 0);
  item.offset := item.offset + e.decl.offset
END GenFieldRef;

PROCEDURE GenPointerDeref(l :Lex.Lexer; e :AST.Expr; VAR item :Item;
                          VAR parentTrueChain, parentFalseChain :INTEGER);
BEGIN
  GenExpr(l, e.lhs, item, parentTrueChain, parentFalseChain);
  ASSERT(e.lhs.typ.kind = AST.typePointer);
  (* While the pointer has been visited, the type pointed to *)
  (* may not have been yet.                                  *)
  CalculateSize(e.lhs.typ.base);
  Load(item);
  IF genNilCheck THEN
    Emit(opCMPI, item.r, item.r, 0, 0);
    Emit(opBRA, LINK, 0, opBEQ, NIL_TRAP);
  END;
  (* The value in a register is now a pointer *)
  item.kind := itemRegI;
  item.offset := 0
END GenPointerDeref;

PROCEDURE GenArrayRef(l :Lex.Lexer; e :AST.Expr; VAR item :Item;
                      VAR parentTrueChain, parentFalseChain :INTEGER);
VAR
  size           :INTEGER;
  arrayItem, rhs :Item;
BEGIN
  (* rhs is array index *)
  GenExpr(l, e.rhs, rhs, parentTrueChain, parentFalseChain);
  (* lhs is the array *)
  GenExpr(l, e.lhs, item, parentTrueChain, parentFalseChain);
  ASSERT(item.kind IN {itemVar, itemRegI});
  ASSERT(e.lhs.typ.kind = AST.typeArray);
  size := CalculateSize(e.lhs.typ.base);
  ASSERT(size > 0);
  IF e.lhs.typ.base.kind = AST.typeChar THEN
    size := 1;
    item.isByte := TRUE;
  ELSE
    item.isByte := FALSE;
  END;
  IF rhs.kind = itemConst THEN
    item.offset := item.offset + size*rhs.offset
  ELSE
    Load(rhs);
    IF genBoundsCheck THEN
      GenLengthof(l, arrayItem, e.lhs);
      Emit(opCMP, arrayItem.r, arrayItem.r, rhs.r, 0);
      Emit(opBRA, LINK, 0, opBHI, BOUNDS_TRAP);
      DecCurReg;
    END;
    IF size > 1 THEN
      Emit(opMULI, rhs.r, rhs.r, 0, size)
    END;
    IF item.kind = itemVar THEN
      Emit(opADD, rhs.r, item.r, rhs.r, 0);
      item.kind := itemRegI;
      item.r := rhs.r
    ELSIF item.kind = itemRegI THEN
      IF item.r > rhs.r THEN
        Emit(opADD, rhs.r, item.r, rhs.r, 0);
        item.r := rhs.r
      ELSE
        Emit(opADD, item.r, item.r, rhs.r, 0);
      END;
      (* rhs.r no longer needed *)
      DecCurReg
    ELSE
      ASSERT(FALSE)
    END
  END
END GenArrayRef;

PROCEDURE GenUnaryOp(l :Lex.Lexer; e :AST.Expr; VAR item :Item;
                     VAR parentTrueChain, parentFalseChain :INTEGER);
BEGIN
  IF e.lhs.typ.kind = AST.typeInteger THEN
    IF e.op = Lex.tPLUS THEN
      GenExpr(l, e.lhs, item, parentTrueChain, parentFalseChain);
    ELSIF e.op = Lex.tMINUS THEN
      GenExpr(l, e.lhs, item, parentTrueChain, parentFalseChain);
      Load(item);
      Emit(opMOVI, curReg, 0, 0, 0);
      Emit(opSUB, item.r, curReg, item.r, 0)
    ELSIF e.op = Lex.tAsSetElt THEN
      GenExpr(l, e.lhs, item, parentTrueChain, parentFalseChain);
      Load(item);
      Emit(opMOVI, curReg, 0, 0, 1);
      Emit(opLSL, item.r, curReg, item.r, 0);
    ELSE
      ASSERT(FALSE)
    END
  ELSIF e.lhs.typ.kind = AST.typeSet THEN
    IF e.op = Lex.tMINUS THEN
      GenExpr(l, e.lhs, item, parentTrueChain, parentFalseChain);
      Load(item);
      Emit(opXORI, item.r, item.r, 0, -1)
    ELSE
      ASSERT(FALSE)
    END
  ELSIF e.lhs.typ.kind = AST.typeBoolean THEN
    IF e.op = Lex.tTILDE THEN
      GenExpr(l, e.lhs, item, parentFalseChain, parentTrueChain);
      LoadCond(item);
      ASSERT(item.kind = itemCond);
      item.opCond := NegateCond(item.opCond);
    ELSE
      ASSERT(FALSE);
    END
  ELSE
    ASSERT(FALSE)
  END
END GenUnaryOp;

PROCEDURE GenBinaryOp(l :Lex.Lexer; e :AST.Expr; VAR item :Item;
                      VAR parentTrueChain, parentFalseChain :INTEGER);
VAR
  rhs                             :Item;
  localTrueChain, localFalseChain :INTEGER;
BEGIN
  IF e.op = Lex.tAMP THEN
    (* op is short circuit boolean AND. If lhs is false, don't execute rhs. *)
    (* also, if lhs short circuits to true, run rhs.                        *)
    localTrueChain := 0;
    GenExpr(l, e.lhs, item, localTrueChain, parentFalseChain);
    LoadCond(item);
    ASSERT(item.kind = itemCond);
    Emit(opBRA, 0, 0, NegateCond(item.opCond), 0);
    AddToChain(parentFalseChain);
    (* lhs was true, so run rhs *)
    FixChain(localTrueChain, cp);
    GenExpr(l, e.rhs, item, parentTrueChain, parentFalseChain);
  ELSIF e.op = Lex.tOR THEN
    (* op is short circuit boolean OR. If lhs is true, don't execute rhs. *)
    (* also, if lhs short circuits to false, run rhs.                     *)
    localFalseChain := 0;
    GenExpr(l, e.lhs, item, parentTrueChain, localFalseChain);
    LoadCond(item);
    ASSERT(item.kind = itemCond);
    Emit(opBRA, 0, 0, item.opCond, 0);
    AddToChain(parentTrueChain);
    (* lhs was false, so run rhs *)
    FixChain(localFalseChain, cp);
    GenExpr(l, e.rhs, item, parentTrueChain, parentFalseChain);
  ELSE
    GenExpr(l, e.lhs, item, parentTrueChain, parentFalseChain);
    IF item.kind # itemConst THEN Load(item) END;
    GenExpr(l, e.rhs, rhs, parentTrueChain, parentFalseChain);
    IF e.rhs.typ.kind = AST.typeSet THEN
      GenSetOp(e.op, item, rhs)
    ELSE
      GenIntegerOp(e.op, item, rhs)
    END
  END
END GenBinaryOp;

PROCEDURE GenProcCall(l :Lex.Lexer; e :AST.Expr; VAR item :Item);
VAR
  size :INTEGER;
  actualParam :AST.Expr;
  formalParam :AST.Decl;
  savedRegister :Register;
  localTrueChain, localFalseChain :INTEGER;
BEGIN
  ASSERT(e.lhs.typ.kind = AST.typeProcedure);
  savedRegister := curReg;
  SaveRegisters;
  curReg := 0;
  actualParam := e.rhs;
  formalParam := e.lhs.typ.fields;
  size := e.lhs.typ.length;
  WHILE size > 0 DO
    ASSERT(formalParam # NIL);
    ASSERT(actualParam # NIL);
    IF (formalParam.kind = AST.declParam) &
       ~(formalParam.typ.kind IN {AST.typeArray, AST.typeRecord}) THEN
      (* Normal params passed by value *)
      localTrueChain := 0; localFalseChain := 0;
      GenExpr(l, actualParam, item, localTrueChain, localFalseChain);
      LoadValue(item, localTrueChain, localFalseChain);
    ELSIF (formalParam.kind = AST.declVarParam) OR
           ((formalParam.kind = AST.declParam) &
            (formalParam.typ.kind IN {AST.typeArray, AST.typeRecord})) THEN
      (* VAR params, arrays, and records passed by reference *)
      localTrueChain := 0; localFalseChain := 0;
      GenExpr(l, actualParam, item, localTrueChain, localFalseChain);
      LoadAddress(item);
      IF AST.IsOpenArray(formalParam.typ) THEN
        (* Open arrays must also pass their length *)
        GenLengthof(l, item, actualParam);
      END;
    ELSE
      ASSERT(FALSE)
    END;
    DEC(size);
    actualParam := actualParam.next;
    formalParam := formalParam.next
  END;
  localTrueChain := 0; localFalseChain := 0;
  GenExpr(l, e.lhs, item, localTrueChain, localFalseChain);
  IF item.kind = itemConst THEN
    (* Procedure call to PC relative address *)
    ASSERT(e.lhs.decl.offset = item.offset);
    Emit(opBL, 0, 0, 0, item.offset);
    codeBuffer[cp - 1].q := e.lhs.decl.qname;
  ELSE
    (* Procedure call to pointer to procedure *)
    LoadValue(item, localTrueChain, localFalseChain);
    Emit(opBLr, 0, 0, item.r, 0);
    DecCurReg
  END;
  item.kind := itemReg; item.r := 0;
  IF (savedRegister > 0) & (e.lhs.typ.base.kind # AST.typeNil) THEN
    (* Procedure has a return value in r0 *)
    Emit(opMOV, savedRegister, 0, 0, 0);
    item.r := savedRegister
  END;
  curReg := savedRegister;
  RestoreRegisters;
  IF e.lhs.typ.base.kind # AST.typeNil THEN
    INC(curReg)
  END
END GenProcCall;

PROCEDURE GenBuiltin(l :Lex.Lexer; e :AST.Expr; VAR item :Item);
VAR
  actualParam :AST.Expr;
  localTrueChain, localFalseChain :INTEGER;
BEGIN
  IF e.iVal = AST.builtinReadInt THEN
    localTrueChain := 0; localFalseChain := 0;
    GenExpr(l, e.rhs, item, localTrueChain, localFalseChain);
    Emit(opMOVI, curReg, 0, 0, 0);
    Emit(opLDW, curReg, curReg, 0, -1);
    Emit(opSTW, curReg, item.r, 0, item.offset);
  ELSIF e.iVal = AST.builtinWriteInt THEN
    localTrueChain := 0; localFalseChain := 0;
    GenExpr(l, e.rhs, item, localTrueChain, localFalseChain);
    LoadValue(item, localTrueChain, localFalseChain);
    ASSERT(curReg = 1);
    Emit(opMOVI, curReg, 0, 0, 0);
    Emit(opSTW, item.r, curReg, 0, -1);
    DecCurReg;
  ELSIF e.iVal = AST.builtinWriteChar THEN
    localTrueChain := 0; localFalseChain := 0;
    GenExpr(l, e.rhs, item, localTrueChain, localFalseChain);
    LoadValue(item, localTrueChain, localFalseChain);
    ASSERT(curReg = 1);
    Emit(opMOVI, curReg, 0, 0, 0);
    Emit(opSTW, item.r, curReg, 0, -2);
    DecCurReg;
  ELSIF e.iVal = AST.builtinWriteLn THEN
    ASSERT(curReg = 0);
    Emit(opMOVI, curReg, 0, 0, 0);
    Emit(opSTW, curReg, curReg, 0, -3);
  ELSIF (e.iVal = AST.builtinChr) OR (e.iVal = AST.builtinOrd) THEN
    localTrueChain := 0; localFalseChain := 0;
    GenExpr(l, e.rhs, item, localTrueChain, localFalseChain);
    LoadValue(item, localTrueChain, localFalseChain);
  ELSIF e.iVal = AST.builtinLen THEN
    GenLengthof(l, item, e.rhs);
  ELSIF e.iVal = AST.builtinInc THEN
    IF e.rhs.next = NIL THEN
      e.rhs.next := AST.NewExprInteger(1, Decls.integerType);
    END;
    (* use actualParam to make e.rhs := e.rhs + e.rhs.next, *)
    (* that is, x := x + 1.                                 *)
    actualParam := AST.NewExprBinary(l, Lex.tPLUS, e.rhs, e.rhs.next, NIL);
    actualParam := AST.NewExprAssign(l, e.rhs, actualParam);
    localTrueChain := 0; localFalseChain := 0;
    GenExpr(l, actualParam, item, localTrueChain, localFalseChain);
  ELSIF e.iVal = AST.builtinDec THEN
    IF e.rhs.next = NIL THEN
      e.rhs.next := AST.NewExprInteger(1, Decls.integerType);
    END;
    (* use actualParam to make e.rhs := e.rhs - e.rhs.next, *)
    (* that is, x := x - 1.                                 *)
    actualParam := AST.NewExprBinary(l, Lex.tMINUS, e.rhs, e.rhs.next, NIL);
    actualParam := AST.NewExprAssign(l, e.rhs, actualParam);
    localTrueChain := 0; localFalseChain := 0;
    GenExpr(l, actualParam, item, localTrueChain, localFalseChain);
  ELSIF e.iVal = AST.builtinAssert THEN
    localTrueChain := 0; localFalseChain := 0;
    GenExpr(l, e.rhs, item, localFalseChain, localTrueChain);
    LoadCond(item);
    Emit(opBRA, 0, 0, item.opCond, pc + 2);
    AddToChain(localFalseChain);
    FixChain(localTrueChain, cp);
    Emit(opBL, LINK, 0, 0, ASSERT_TRAP);
    FixChain(localFalseChain, cp);
  ELSE
    ASSERT(FALSE);
  END
END GenBuiltin;

PROCEDURE GenExpr0(l :Lex.Lexer; e :AST.Expr; VAR item :Item;
                   VAR parentTrueChain, parentFalseChain :INTEGER);
BEGIN
  item.isByte := (e.typ # NIL) & (e.typ.kind = AST.typeChar);
  IF e.kind = AST.exprVal THEN
    GenVal(l, e, item)
  ELSIF e.kind = AST.exprIdentRef THEN
    GenIdentRef(e, item)
  ELSIF e.kind = AST.exprAssign THEN
    GenAssign(l, e, item, parentTrueChain, parentFalseChain)
  ELSIF e.kind = AST.exprFieldRef THEN
    GenFieldRef(l, e, item, parentTrueChain, parentFalseChain)
  ELSIF e.kind = AST.exprPointerDeref THEN
    GenPointerDeref(l, e, item, parentTrueChain, parentFalseChain)
  ELSIF e.kind = AST.exprArrayRef THEN
    GenArrayRef(l, e, item, parentTrueChain, parentFalseChain)
  ELSIF e.kind = AST.exprUnary THEN
    GenUnaryOp(l, e, item, parentTrueChain, parentFalseChain)
  ELSIF e.kind = AST.exprBinary THEN
    GenBinaryOp(l, e, item, parentTrueChain, parentFalseChain)
  ELSIF e.kind = AST.exprProcCall THEN
    GenProcCall(l, e, item)
  ELSIF e.kind = AST.exprBuiltin THEN
    GenBuiltin(l, e, item)
  ELSE
    ASSERT(FALSE)
  END
END GenExpr0;

PROCEDURE GenReturn(l :Lex.Lexer; e :AST.Expr);
VAR
  trueChain, falseChain :INTEGER;
  item :Item;
BEGIN
  ASSERT(curReg = 0);
  trueChain := 0; falseChain := 0;
  GenExpr(l, e, item, trueChain, falseChain);
  LoadValue(item, trueChain, falseChain);
  ASSERT(curReg = 1);
  ASSERT(item.kind = itemReg);
  ASSERT(item.r = 0);
  DecCurReg
END GenReturn;

PROCEDURE GenStatements(l :Lex.Lexer; s :AST.Stmt);
VAR
  e :AST.Expr;
  item :Item;
  elses :AST.Stmt;
  (* code pointers *)
  loopStart :INTEGER;
  after :INTEGER;
  trueChain, falseChain :INTEGER;
BEGIN
  WHILE s # NIL DO
    ASSERT(curReg = 0);
    IF s.kind = AST.stmtAssign THEN
      e := s.cond;
      ASSERT(e.kind = AST.exprAssign);
      trueChain := 0; falseChain := 0;
      GenExpr(l, e, item, trueChain, falseChain);
    ELSIF s.kind = AST.stmtProcCall THEN
      GenExpr(l, s.cond, item, trueChain, falseChain);
      ASSERT(curReg <= 1);
      IF curReg = 1 THEN
        (* ProcCall was a function that returned a value that can be ignored *)
        DecCurReg
      END
    ELSIF s.kind = AST.stmtIf THEN
      after := 0;
      trueChain := 0; falseChain := 0;
      GenExpr(l, s.cond, item, trueChain, falseChain);
      LoadCond(item);
      ASSERT(item.kind = itemCond);
      Emit(opBRA, 0, 0, NegateCond(item.opCond), 0);
      AddToChain(falseChain);
      FixChain(trueChain, cp);
      GenStatements(l, s.body);
      elses := s.elsifs;
      WHILE elses # NIL DO
        Emit(opBRA, 0, 0, opB, 0);
        AddToChain(after);
        FixChain(falseChain, cp);
        trueChain := 0; falseChain := 0;
        IF elses.kind = AST.stmtElsIf THEN
          GenExpr(l, elses.cond, item, trueChain, falseChain);
          LoadCond(item);
          ASSERT(item.kind = itemCond);
          Emit(opBRA, 0, 0, NegateCond(item.opCond), 0);
          AddToChain(falseChain);
          ASSERT(item.kind = itemCond);
        ELSE
          ASSERT(elses.kind = AST.stmtElse)
        END;
        FixChain(trueChain, cp);
        GenStatements(l, elses.body);
        elses := elses.elsifs
      END;
      FixChain(falseChain, cp);
      FixChain(after, cp)
    ELSIF s.kind = AST.stmtWhile THEN
      ASSERT(s.elsifs = NIL);
      after := cp;
      Emit(opBRA, 0, 0, opB, 0);
      loopStart := cp;
      GenStatements(l, s.body);
      codeBuffer[after].value := cp; (* fix first branch to point to compare *)
      trueChain := 0; falseChain := 0;
      GenExpr(l, s.cond, item, trueChain, falseChain);
      (* True chain immediatly returns to loopStart *)
      FixChain(trueChain, loopStart);
      LoadCond(item);
      ASSERT(item.kind = itemCond);
      Emit(opBRA, 0, 0, item.opCond, loopStart);
      (* Loop done, so the false chain links here *)
      FixChain(falseChain, cp)
    ELSIF s.kind = AST.stmtRepeat THEN
      loopStart := cp;
      trueChain := 0; falseChain := 0;
      GenStatements(l, s.body);
      GenExpr(l, s.cond, item, trueChain, falseChain);
      (* False chain immediatly returns to loopStart *)
      FixChain(falseChain, loopStart);
      LoadCond(item);
      ASSERT(item.kind = itemCond);
      Emit(opBRA, 0, 0, NegateCond(item.opCond), loopStart);
      (* Loop done, so the true chain links here *)
      FixChain(trueChain, cp)
    ELSIF s.kind = AST.stmtFor THEN
      (* s.cond is an assign, so s.cond.lhs is the LCV            *)
      (* s.cond.next is the value that represents the end         *)
      (* s.cond.next.next is the inc/dec, if present, otherwise 1 *)
      IF s.cond.next.next = NIL THEN
        s.cond.next.next := AST.NewExprInteger(1, Decls.integerType);
      END;
      trueChain := 0; falseChain := 0;
      GenExpr(l, s.cond, item, trueChain, falseChain);
      after := cp;
      Emit(opBRA, 0, 0, opB, 0);
      loopStart := cp;
      GenStatements(l, s.body);
      (* Make LCV := LCV + next (next might be negative) *)
      e := AST.NewExprBinary(l, Lex.tPLUS, s.cond.lhs, s.cond.next.next, NIL);
      e := AST.NewExprAssign(l, s.cond.lhs, e);
      trueChain := 0; falseChain := 0;
      GenExpr(l, e, item, trueChain, falseChain);
      codeBuffer[after].value := cp; (* fix first branch to point to compare *)
      IF (s.cond.next.next.kind = AST.exprVal) & (s.cond.next.next.iVal > 0) THEN
        (* cond is LCV <= last *)
        e := AST.NewExprBinary(l, Lex.tLTEQ, s.cond.lhs, s.cond.next, Decls.booleanType);
      ELSE
        (* cond is LCV >= last *)
        e := AST.NewExprBinary(l, Lex.tGTEQ, s.cond.lhs, s.cond.next, Decls.booleanType);
      END;
      GenExpr(l, e, item, trueChain, falseChain);
      (* True chain immediatly returns to loopStart *)
      FixChain(trueChain, loopStart);
      LoadCond(item);
      ASSERT(item.kind = itemCond);
      Emit(opBRA, 0, 0, item.opCond, loopStart);
      (* Loop done, so the false chain links here *)
      FixChain(falseChain, cp)
    ELSIF s.kind = AST.stmtCase THEN
      GenCase(l, s)
    ELSIF s.kind = AST.stmtEmpty THEN
    ELSE
      ASSERT(FALSE)
    END;
    ASSERT(curReg = 0);
    s := s.next
  END
END GenStatements;

PROCEDURE GenCase0(l :Lex.Lexer; s :AST.Stmt);
VAR
  i, j, smallest, largest, caseTableStart :INTEGER;
  t :AST.Stmt;
  e :AST.Expr;
  item :Item;
  after, localTrueChain, localFalseChain :INTEGER;
BEGIN
  after := 0;
  smallest := 2147483647;
  largest := -2147483648;
  (* First, figure out the range of labels *)
  t := s.elsifs;
  WHILE t # NIL DO
    ASSERT(t.kind = AST.stmtCaseItem);
    ASSERT(t.next = NIL);
    ASSERT(t.cond.kind = AST.exprBinary);
    (* Case items have a special cond, which has possibly more than one *)
    (* expr. The expr is either an equal (where the lhs is the case,    *)
    (* which can be ignored), or a CaseDotDot operator, which should be *)
    (* expanded here since the cases must be constant.                  *)
    e := t.cond;
    WHILE e # NIL DO
      IF e.op = Lex.tEQ THEN
        ASSERT(AST.IsConst(e.rhs));
        IF e.rhs.iVal < smallest THEN smallest := e.rhs.iVal END;
        IF e.rhs.iVal > largest THEN largest := e.rhs.iVal END;
      ELSIF e.op = Lex.tCaseDotDot THEN
        ASSERT(AST.IsConst(e.lhs.rhs));
        ASSERT(AST.IsConst(e.rhs.rhs));
        IF e.lhs.rhs.iVal < smallest THEN smallest := e.lhs.rhs.iVal END;
        IF e.lhs.rhs.iVal > largest THEN largest := e.lhs.rhs.iVal END;
        IF e.rhs.rhs.iVal < smallest THEN smallest := e.rhs.rhs.iVal END;
        IF e.rhs.rhs.iVal > largest THEN largest := e.rhs.rhs.iVal END;
      ELSE
        ASSERT(FALSE)
      END;
      e := e.next
    END;
    t := t.elsifs
  END;
  (* case condition *)
  GenExpr(l, s.cond, item, localTrueChain, localFalseChain);
  LoadValue(item, localTrueChain, localFalseChain);
  (* upper bound *)
  Emit(opCMPI, item.r, item.r, 0, largest);
  Emit(opBRA, 0, 0, opBGT, 0);
  AddToChain(after);
  (* lower bound *)
  Emit(opCMPI, item.r, item.r, 0, smallest);
  Emit(opBRA, 0, 0, opBLT, 0);
  AddToChain(after);
  DecCurReg;
  (* Jump using jump table *)
  IF smallest # 0 THEN
    Emit(opSUBI, item.r, item.r, 0, smallest)
  END;
  Emit(opADDI, item.r, item.r, 0, pc+2); (* offset to jump table *)
  Emit(opBrg, item.r, 0, 0, 0);
  caseTableStart := cp;
  FOR i := smallest TO largest DO
    Emit(opCJP, 0, 0, 0, 0)
  END;
  (* For each case, update jump table and generate code *)
  t := s.elsifs;
  WHILE t # NIL DO
    i := pc; (* i = destination of case label *)
    e := t.cond;
    WHILE e # NIL DO
      IF e.op = Lex.tEQ THEN
        codeBuffer[caseTableStart + e.rhs.iVal - smallest].value := i;
      ELSIF e.op = Lex.tCaseDotDot THEN
        FOR j := e.lhs.rhs.iVal TO e.rhs.rhs.iVal DO
          codeBuffer[caseTableStart + j - smallest].value := i;
        END;
      END;
      e := e.next
    END;
    GenStatements(l, t.body);
    Emit(opBRA, 0, 0, opB, 0);
    AddToChain(after);
    t := t.elsifs
  END;
  (* Fix any gaps in the case table *)
  FOR i := smallest TO largest DO
    IF codeBuffer[caseTableStart + i].value = 0 THEN
      codeBuffer[caseTableStart + i].value := pc
    END
  END;
  FixChain(after, cp)
END GenCase0;

PROCEDURE GenerateProc*(l :Lex.Lexer; d :AST.Decl);
VAR
  fp :INTEGER;
  vars :AST.Decl;
  i, registersInUse :INTEGER;
BEGIN
  ASSERT(d.kind = AST.declProcedure);
  cp := 0;
  registersInUse := 0;
  d.offset := pc;
  IF ~genCode THEN
    GenQName(l, d.qname); GenStr(": code offset: "); Out.Int(d.offset); GenLn;
  END;
  fp := 4; (* Leave 4 bytes for return address. Params right below. *)
  vars := d.procVars;
  WHILE (vars # NIL) &
        ((vars.kind = AST.declParam) OR (vars.kind = AST.declVarParam)) DO
    ASSERT(vars.offset < 0);
    vars.offset := fp;
    IF ~genCode THEN
      Tab; GenStr("; "); Lex.OutStr(l, vars.qname.name);
      GenStr(" offset "); Out.Int(fp); GenLn;
    END;
    (*
     * All parameters except arrays are 4 bytes, because they are either
     * primitives, records (passed by reference), var parameters (also
     * passed by reference) or pointers.
     *)
    INC(registersInUse);
    fp := fp + 4;
    IF AST.IsOpenArray(vars.typ) THEN
      IF ~genCode THEN
        Tab; GenStr("; "); Lex.OutStr(l, vars.qname.name); GenStr("__len");
        GenStr(" offset "); Out.Int(fp); GenLn;
      END;
      INC(registersInUse);
      fp := fp + 4
    END;
    vars := vars.next
  END;
  WHILE (vars # NIL) & (vars.kind # AST.declEND) DO
    IF vars.kind = AST.declVar THEN
      vars.offset := fp;
      IF ~genCode THEN
        Tab; GenStr("; "); Lex.OutStr(l, vars.qname.name); GenStr(" offset "); Out.Int(fp); GenLn;
      END;
      fp := fp + CalculateSize(vars.typ);
    END;
    vars := vars.next
  END;
  (* Preamble *)
  Emit(opSUBI, rSP, rSP, 0, fp);
  Emit(opSTW, rLR, rSP, 0, 0);
  i := 4;
  WHILE registersInUse > 0 DO
    Emit(opSTW, (i DIV 4)-1, rSP, 0, i);
    INC(i, 4);
    DEC(registersInUse)
  END;
  GenStatements(l, d.body);
  IF d.expr # NIL THEN GenReturn(l, d.expr) END;
  (* Epilog *)
  Emit(opLDW, rLR, rSP, 0, 0);
  Emit(opADDI, rSP, rSP, 0, fp);
  Emit(opBrg, rLR, 0, 0, 0);
  IF genCode THEN
    DumpCode(d.offset)
  ELSE
    DumpAssembly(l, d.offset)
  END
END GenerateProc;

PROCEDURE GenCall*(proc :AST.Decl);
BEGIN
  Emit(opBL, 0, 0, 0, proc.offset);
  codeBuffer[cp - 1].q := proc.qname
END GenCall;

PROCEDURE GenStartMain*;
BEGIN
  cp := 0;
  mainStartPc := pc;
  IF ~genCode THEN
    GenStr("__start__: "); Out.Int(pc); GenLn
  END
END GenStartMain;

PROCEDURE GenStringPool;
BEGIN
  GenStr("const uint8_t STRING_POOL[] = {"); GenLn;
  Lex.OutPool(strings);
  GenStr("};"); GenLn;
END GenStringPool;

PROCEDURE GenEndMain*(l :Lex.Lexer);
BEGIN
  Emit(opHALT, 0, 0, 0, 0);
  IF genCode THEN
    DumpCode(mainStartPc);
    GenStr("};"); GenLn;
    GenStr("#define START_PC ");
    Out.Int(mainStartPc); GenLn;
    GenStr("#define STRING_POOL_START ");
    Out.Int(globalOffset); GenLn;
    GenStringPool
  ELSE
    DumpAssembly(l, mainStartPc)
  END
END GenEndMain;

PROCEDURE EnableDumpCode*;
BEGIN
  GenStr("const Instruction PROGRAM[] = {"); GenLn;
  genCode := TRUE
END EnableDumpCode;

BEGIN
  GenExpr := GenExpr0;
  GenCase := GenCase0;
  globalOffset := 0;
  stackOffset := 0;
  lastType := 0;
  mainStartPc := 0;
  genCode := FALSE;
  genBoundsCheck := TRUE;
  genNilCheck := TRUE;
  pc := 0;
  Lex.PoolInit(strings)
END RCodegen.

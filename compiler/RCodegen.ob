MODULE RCodegen;

IMPORT AST, Lex, Out;

CONST
  CACHE_SIZE = 100;
  CODE_BUFFER = 2000; (* Code for the procedure being generated, for fixups. *)

  (* Opcodes *)
  opMOV = 0;  (* ra := rb                      *)
  opADD = 1;  (* ra := rb + rc                 *)
  opSUB = 2;  (* ra := rb - rc                 *)
  opMUL = 3;  (* ra := rb * rc                 *)
  opDIV = 4;  (* ra := rb * rc                 *)
  opCMP = 5;  (* rb - rc, affects conditions   *)
  opLDW = 6;  (* ra := Mem[rb + offset] (word) *)
  opLDB = 7;  (* ra := Mem[rb + offset] (byte) *)
  opSTW = 8;  (* Mem[rb + offset] := ra (word) *)
  opSTB = 9;  (* Mem[rb + offset] := ra (byte) *)
  opBRA = 10; (* PC := value (see below)       *)
  opJSR = 50; (* Jump to Subr                  *)
  opRTS = 51; (* Subr return                   *)
  opCONDt = 52; (* Condition placeholder       *)
  opCONDf = 53; (* Condition placeholder       *)

  (* Branches have opcode opBRA, and r.c is    *)
  (* the conndition code, given below:         *)
  opBEQ = 1;  (* =  *) opBNE = 9;   (* #  *)
  opBLT = 5;  (* <  *) opBGE = 13;  (* >= *)
  opBLE = 6;  (* <= *) opBGT = 14;  (* >  *)
  opB   = 7;  (* branch always *)
  opBF  = 15; (* branch never, basically NOP *)

  opMOVI = 100; (* ra := immediate      *)
  opADDI = 101; (* ra := rb + immediate *)
  opSUBI = 102; (* ra := rb - immediate *)
  opMULI = 103; (* ra := rb * immediate *)
  opDIVI = 104; (* ra := rb / immediate *)
  opCMPI = 105; (* rb - immediate       *)

  opHALT = 1000;

  (* Registers *)
  rGB = 13; (* r13 = Global base   *)
  rSP = 14; (* r14 = Stack pointer *)
  rLR = 15; (* r15 = Link register *)

  (* Item kinds *)
  itemReg   = 1; (* Item is in register r                         *)
  itemVar   = 2; (* Item is a variable whose address is r+offset. *)
                 (* r is always SP or GP.                         *)
  itemConst = 3; (* Item value is a constant, stored in offset    *)
  itemRegI  = 4; (* Register indirect address.                    *)
                 (* Item's address is r+offset, this is similar   *)
                 (* to Var, except with Var, r is always SP or    *)
                 (* GB. with RegI, this is an allocated register, *)
                 (* which eventually needs to be released.        *)
  itemCond  = 5; (* Item is a condition. The CMP instruction was  *)
                 (* already generated, and this represents the    *)
                 (* condition associated with the relation.       *)

TYPE
  OpCode = INTEGER;
  Register = INTEGER;
  ItemKind = INTEGER;
  Instruction = RECORD
    op         :OpCode;
    ra, rb, rc :Register;
    value      :INTEGER;  (* If op is an immediate, e.g., ra := rb + value    *)
                          (* if op is a branch, this is the branch offset     *)
    q          :AST.QName;
  END;
  Item = RECORD
    kind   :ItemKind;
    r      :Register;
    offset :INTEGER;
    opCond :OpCode;  (* If kind is itemCond, this is the branch type. *)
  END;

VAR
  typeCache    :ARRAY CACHE_SIZE OF AST.Type; (* Already reached types        *)
  typeSizes    :ARRAY CACHE_SIZE OF INTEGER;  (* Map RECORD and ARRAY to size *)
  codeBuffer   :ARRAY CODE_BUFFER OF Instruction;
  globalOffset :INTEGER;                 (* Offset of variable to global base *)
  lastType     :INTEGER;
  pc           :INTEGER; (* (Global) program counter. This is the offset from *)
                         (* the start of code generated. This is measured in  *)
                         (* instructions, not bytes, so it is not a multiple  *)
                         (* of 4.                                             *)
  cp           :INTEGER; (* Code pointer. This is an offset into the code     *)
                         (* buffer, so 0 represents the start of a procedure. *)
                         (* It is measured in instructions, not bytes.        *)
  curReg       :INTEGER; (* Number [0..13] of the next available register     *)

PROCEDURE Emit(op :OpCode; ra, rb, rc :Register; value :INTEGER);
BEGIN
  codeBuffer[cp].op := op;
  codeBuffer[cp].ra := ra;
  codeBuffer[cp].rb := rb;
  codeBuffer[cp].rc := rc;
  codeBuffer[cp].value := value;
  INC(pc);
  INC(cp);
  ASSERT(cp < CODE_BUFFER)
END Emit;

PROCEDURE GenStr(s :ARRAY OF CHAR);
BEGIN
  Out.Str(s);
END GenStr;

PROCEDURE Tab;
BEGIN
  GenStr(9X)
END Tab;

PROCEDURE GenLn;
BEGIN
  Out.Ln
END GenLn;

PROCEDURE GenReg(r :Register);
BEGIN
  IF r < rGB THEN
    GenStr("R"); Out.Int(r)
  ELSIF r = rGB THEN
    GenStr("GB")
  ELSIF r = rSP THEN
    GenStr("SP")
  ELSIF r = rLR THEN
    GenStr("LR")
  ELSE
    ASSERT(FALSE)
  END
END GenReg;

PROCEDURE Gen2(op :ARRAY OF CHAR; ra, rb :Register; value :INTEGER);
BEGIN
  GenStr(op);
  GenStr(" ");
  IF op # "CMP" THEN
    GenReg(ra);
    GenStr(", ");
  END;
  GenReg(rb);
  GenStr(", #");
  Out.Int(value)
END Gen2;

PROCEDURE Gen3(op :ARRAY OF CHAR; ra, rb, rc :Register);
BEGIN
  GenStr(op);
  GenStr(" ");
  IF op # "CMP" THEN
    GenReg(ra);
    GenStr(", ");
  END;
  GenReg(rb);
  GenStr(", ");
  GenReg(rc)
END Gen3;

PROCEDURE GenQName(l :Lex.Lexer; name :AST.QName);
BEGIN
  IF name.moduleName > 0 THEN
    Lex.OutStr(l, name.moduleName);
    GenStr("_");
  END;
  IF name.name > 0 THEN
    Lex.OutStr(l, name.name);
  END;
END GenQName;

PROCEDURE DumpCode(l :Lex.Lexer; delta :INTEGER);
VAR
  i :INTEGER;
BEGIN
  i := 0;
  WHILE i < cp DO
    Out.Int(i + delta); Tab;
    IF codeBuffer[i].op = opMOV THEN
      GenStr("MOV "); GenReg(codeBuffer[i].ra); GenStr(", "); GenReg(codeBuffer[i].rb);
    ELSIF codeBuffer[i].op = opMOVI THEN
      GenStr("MOV "); GenReg(codeBuffer[i].ra); GenStr(", #"); Out.Int(codeBuffer[i].value);
    ELSIF codeBuffer[i].op = opADD THEN
      Gen3("ADD", codeBuffer[i].ra, codeBuffer[i].rb, codeBuffer[i].rc)
    ELSIF codeBuffer[i].op = opSUB THEN
      Gen3("SUB", codeBuffer[i].ra, codeBuffer[i].rb, codeBuffer[i].rc)
    ELSIF codeBuffer[i].op = opMUL THEN
      Gen3("MUL", codeBuffer[i].ra, codeBuffer[i].rb, codeBuffer[i].rc)
    ELSIF codeBuffer[i].op = opDIV THEN
      Gen3("DIV", codeBuffer[i].ra, codeBuffer[i].rb, codeBuffer[i].rc)
    ELSIF codeBuffer[i].op = opCMP THEN
      Gen3("CMP", codeBuffer[i].ra, codeBuffer[i].rb, codeBuffer[i].rc)
    ELSIF codeBuffer[i].op = opADDI THEN
      Gen2("ADD", codeBuffer[i].ra, codeBuffer[i].rb, codeBuffer[i].value)
    ELSIF codeBuffer[i].op = opSUBI THEN
      Gen2("SUB", codeBuffer[i].ra, codeBuffer[i].rb, codeBuffer[i].value)
    ELSIF codeBuffer[i].op = opMULI THEN
      Gen2("MUL", codeBuffer[i].ra, codeBuffer[i].rb, codeBuffer[i].value)
    ELSIF codeBuffer[i].op = opDIVI THEN
      Gen2("DIV", codeBuffer[i].ra, codeBuffer[i].rb, codeBuffer[i].value)
    ELSIF codeBuffer[i].op = opCMPI THEN
      Gen2("CMP", codeBuffer[i].ra, codeBuffer[i].rb, codeBuffer[i].value)
    ELSIF codeBuffer[i].op = opLDW THEN
      Gen2("LDW", codeBuffer[i].ra, codeBuffer[i].rb, codeBuffer[i].value)
    ELSIF codeBuffer[i].op = opLDB THEN
      Gen2("LDB", codeBuffer[i].ra, codeBuffer[i].rb, codeBuffer[i].value)
    ELSIF codeBuffer[i].op = opSTW THEN
      Gen2("STW", codeBuffer[i].ra, codeBuffer[i].rb, codeBuffer[i].value)
    ELSIF codeBuffer[i].op = opSTB THEN
      Gen2("STB", codeBuffer[i].ra, codeBuffer[i].rb, codeBuffer[i].value)
    ELSIF codeBuffer[i].op = opBRA THEN
      CASE codeBuffer[i].rc OF
        opBEQ: GenStr("BEQ ")
        | opBNE: GenStr("BNE ")
        | opBLT: GenStr("BLT ")
        | opBGT: GenStr("BGT ")
        | opBGE: GenStr("BGE ")
        | opBLE: GenStr("BLE ")
        | opB: GenStr("B ");
        | opBF: GenStr("BF ");
      END;
      Out.Int(codeBuffer[i].value + delta)
    ELSIF codeBuffer[i].op = opCONDt THEN
      GenStr("COND True branch: "); Out.Int(codeBuffer[i].value)
    ELSIF codeBuffer[i].op = opCONDf THEN
      GenStr("COND False branch: "); Out.Int(codeBuffer[i].value)
    ELSIF codeBuffer[i].op = opJSR THEN
      GenStr("JSR "); Out.Int(codeBuffer[i].value);
      GenStr(" ("); GenQName(l, codeBuffer[i].q);
      GenStr(")")
    ELSIF codeBuffer[i].op = opRTS THEN
      GenStr("RTS")
    ELSIF codeBuffer[i].op = opHALT THEN
      GenStr("HALT")
    ELSE
      ASSERT(FALSE)
    END;
    GenLn;
    INC(i)
  END
END DumpCode;

PROCEDURE FindOrAddType(t :AST.Type) :INTEGER;
VAR
  index :INTEGER;
  found :BOOLEAN;
BEGIN
  index := 0; found := FALSE;
  WHILE (index < lastType) & ~found DO
    IF typeCache[index] = t THEN
      found := TRUE
    ELSE
      INC(index)
    END
  END;
  IF ~found THEN
    ASSERT(index < CACHE_SIZE);
    typeCache[index] := t;
    typeSizes[index] := -1;
    INC(lastType)
  END
  RETURN index
END FindOrAddType;

PROCEDURE CalculateSize(t :AST.Type) :INTEGER;
VAR
  i, s :INTEGER;
  f :AST.Decl;
BEGIN
  IF t.kind IN {AST.typeInteger, AST.typeReal, AST.typeBoolean, AST.typeChar,
                AST.typeSet, AST.typePointer, AST.typeProcedure} THEN
    s := 4
  ELSIF t.kind = AST.typeRecord THEN
    i := FindOrAddType(t);
    s := typeSizes[i];
    IF typeSizes[i] < 0 THEN
      (* Not found yet. Record size is size of fields *)
      s := 0;
      IF t.needTypeInfo THEN s := 4 END;
      f := t.fields;
      WHILE (f # NIL) & (f.kind # AST.declEND) DO
        f.offset := s;
        s := s + CalculateSize(f.typ);
        f := f.next
      END;
      typeSizes[i] := s
    END;
  ELSIF t.kind = AST.typeArray THEN
    i := FindOrAddType(t);
    s := typeSizes[i];
    IF typeSizes[i] < 0 THEN
      (* Not found yet. Array size is length * element size *)
      ASSERT(t.length > 0);
      IF t.base.kind = AST.typeChar THEN
        (* Strings are packed up to a multiple of 4 bytes *)
        s := t.length;
        IF (s MOD 4) # 0 THEN
          s := t.length + 4 - (t.length MOD 4)
        END
      ELSE
        s := t.length * CalculateSize(t.base)
      END;
      typeSizes[i] := s
    END
  ELSE
    ASSERT(FALSE)
  END;
  RETURN s
END CalculateSize;

PROCEDURE IncCurReg;
BEGIN
  INC(curReg);
  IF curReg = rGB THEN
    Out.ErrStr("Out of registers"); Out.ErrLn;
    ASSERT(FALSE)
  END
END IncCurReg;

PROCEDURE DecCurReg;
BEGIN
  DEC(curReg);
  ASSERT(curReg >= 0)
END DecCurReg;

PROCEDURE AddToChain(VAR chain :INTEGER);
(* This is called after a branch has been emitted. It updates the previous  *)
(* instruction in the buffer to add it to the "chain" and chain points to   *)
(* this updated instruction. The end result is a linked list of instruction *)
(* addresses, starting at "chain", and ending at 0. This is later fixed up  *)
(* using the FixupChain procedure.                                          *)
BEGIN
  codeBuffer[cp-1].value := chain;
  chain := cp - 1
END AddToChain;

PROCEDURE FixChain(chain, fix :INTEGER);
VAR
  next :INTEGER;
BEGIN
  WHILE chain # 0 DO
    next := codeBuffer[chain].value;
    codeBuffer[chain].value:= fix;
    chain := next
  END
END FixChain;

(* Loads a value from an item into a register. *)
PROCEDURE Load(VAR item :Item);
BEGIN
  IF item.kind = itemVar THEN
    Emit(opLDW, curReg, item.r, 0, item.offset);
    item.r := curReg;
    IncCurReg
  ELSIF item.kind = itemRegI THEN
    Emit(opLDW, item.r, item.r, 0, item.offset)
    (* item.r already allocated *)
  ELSIF item.kind = itemConst THEN
    Emit(opMOVI, curReg, 0, 0, item.offset);
    item.r := curReg;
    IncCurReg
  ELSIF item.kind = itemReg THEN
    (* Already in a register, do nothing *)
  ELSE
    ASSERT(FALSE)
  END;
  item.kind := itemReg
END Load;

(* If a value isn't a condition code, load and transform into a condition. *)
PROCEDURE LoadCond(VAR item :Item);
BEGIN
  IF item.kind # itemCond THEN
    IF item.kind = itemConst THEN
      IF item.offset = 1 THEN
        item.opCond := opB
      ELSE
        item.opCond := opBF
      END
    ELSE
      Load(item);
      Emit(opCMPI, item.r, item.r, 0, 0);
      (* Anything nonzero is true, although item.r really should be 0 or 1 *)
      item.opCond := opBNE;
      (* Boolean value no longer needed *)
      DecCurReg
    END;
    item.kind := itemCond
  END
END LoadCond;

(* Loads any value, including conditions, into a register. *)
PROCEDURE LoadValue(VAR item :Item; trueChain, falseChain :INTEGER);
BEGIN
  IF item.kind = itemCond THEN
    Emit(opBRA, 0, 0, item.opCond, cp+3);
    (* This is the false for cond, so falseChain ends here *)
    FixChain(falseChain, cp);
    Emit(opMOVI, curReg, 0, 0, 0);
    Emit(opBRA, 0, 0, opB, cp+2);
    (* This is the true for cond, so trueChain ends here *)
    FixChain(trueChain, cp);
    Emit(opMOVI, curReg, 0, 0, 1);
    item.r := curReg;
    item.kind := itemReg;
    IncCurReg
  ELSE
    Load(item)
  END
END LoadValue;

PROCEDURE AllocateGlobals*(l :Lex.Lexer; d :AST.Decl);
BEGIN
  ASSERT(d.kind = AST.declVar);
  ASSERT(d.nesting = 0);
  ASSERT(d.offset = -1);
  d.offset := globalOffset;
  GenStr("; "); GenQName(l, d.qname); GenStr(" offset "); Out.Int(d.offset); GenLn;
  globalOffset := globalOffset + CalculateSize(d.typ)
END AllocateGlobals;

PROCEDURE GenCompare(VAR lhs, rhs:Item; op :OpCode);
BEGIN
  IF rhs.kind = itemConst THEN
    Load(lhs);
    Emit(opCMPI, lhs.r, lhs.r, 0, rhs.offset)
  ELSE
    Load(lhs);
    Load(rhs);
    Emit(opCMP, lhs.r, lhs.r, rhs.r, 0);
    DecCurReg
  END;
  lhs.kind := itemCond;
  lhs.opCond := op;
  (* We don't need or want the result of the lhs, which is always loaded *)
  DecCurReg
END GenCompare;

PROCEDURE NegateCond(cond :OpCode) :OpCode;
BEGIN
  IF cond < 8 THEN cond := cond + 8 ELSE cond := cond - 8 END
  RETURN cond
END NegateCond;

PROCEDURE GenBinaryOp(op :Lex.TokenKind; VAR lhs, rhs :Item);
BEGIN
  IF op = Lex.tPLUS THEN
    IF lhs.kind = itemConst THEN
      Load(rhs);
      lhs.kind := rhs.kind; lhs.r := rhs.r;
      Emit(opADDI, lhs.r, lhs.r, 0, lhs.offset)
    ELSIF rhs.kind = itemConst THEN
      Load(lhs);
      Emit(opADDI, lhs.r, lhs.r, 0, rhs.offset)
    ELSE
      Load(lhs);
      Load(rhs);
      Emit(opADD, lhs.r, lhs.r, rhs.r, 0);
      DecCurReg
    END
  ELSIF op = Lex.tMINUS THEN
    IF rhs.kind = itemConst THEN
      Load(lhs);
      Emit(opSUBI, lhs.r, lhs.r, 0, rhs.offset)
    ELSE
      Load(lhs);
      Load(rhs);
      Emit(opSUB, lhs.r, lhs.r, rhs.r, 0);
      DecCurReg
    END
  ELSIF op = Lex.tSTAR THEN
    IF lhs.kind = itemConst THEN
      Load(rhs);
      lhs.kind := rhs.kind; lhs.r := rhs.r;
      Emit(opMULI, lhs.r, lhs.r, 0, lhs.offset)
    ELSIF rhs.kind = itemConst THEN
      Load(lhs);
      Emit(opMULI, lhs.r, lhs.r, 0, rhs.offset)
    ELSE
      Load(lhs);
      Load(rhs);
      Emit(opMUL, lhs.r, lhs.r, rhs.r, 0);
      DecCurReg
    END
  ELSIF op = Lex.tEQ THEN
    GenCompare(lhs, rhs, opBEQ)
  ELSIF op = Lex.tPOUND THEN
    GenCompare(lhs, rhs, opBNE)
  ELSIF op = Lex.tLT THEN
    GenCompare(lhs, rhs, opBLT)
  ELSIF op = Lex.tGT THEN
    GenCompare(lhs, rhs, opBGT)
  ELSIF op = Lex.tLTEQ THEN
    GenCompare(lhs, rhs, opBLE)
  ELSIF op = Lex.tGTEQ THEN
    GenCompare(lhs, rhs, opBGE)
  ELSE
    ASSERT(FALSE)
  END
END GenBinaryOp;

PROCEDURE GenExpr(e :AST.Expr; VAR item :Item;
                  VAR parentTrueChain, parentFalseChain :INTEGER);
VAR
  size :INTEGER;
  rhs  :Item;
  localTrueChain, localFalseChain :INTEGER;
BEGIN
  IF e.kind = AST.exprVal THEN
    item.kind := itemConst;
    IF e.typ.kind IN {AST.typeInteger, AST.typeBoolean} THEN
      item.offset := e.iVal
    ELSE
      ASSERT(FALSE)
    END
  ELSIF e.kind = AST.exprIdentRef THEN
    ASSERT(e.decl.kind = AST.declVar);
    item.kind := itemVar;
    ASSERT(e.decl.offset # -1);
    item.offset := e.decl.offset;
    IF e.decl.nesting = 0 THEN
      item.r := rGB
    ELSE
      item.r := rSP
    END
  ELSIF e.kind = AST.exprFieldRef THEN
    GenExpr(e.lhs, item, parentTrueChain, parentFalseChain);
    ASSERT(item.kind IN {itemVar, itemRegI});
    ASSERT(e.decl.offset >= 0);
    item.offset := item.offset + e.decl.offset
  ELSIF e.kind = AST.exprPointerDeref THEN
    GenExpr(e.lhs, item, parentTrueChain, parentFalseChain);
    ASSERT(e.lhs.typ.kind = AST.typePointer);
    (* While the pointer has been visited, the type pointed to *)
    (* may not have been yet.                                  *)
    CalculateSize(e.lhs.typ.base);
    Load(item);
    (* The value in a register is now a pointer *)
    item.kind := itemRegI;
    item.offset := 0
  ELSIF e.kind = AST.exprArrayRef THEN
    (* rhs is array index *)
    GenExpr(e.rhs, rhs, parentTrueChain, parentFalseChain);
    (* Check bounds here! *)
    (* lhs is the array *)
    GenExpr(e.lhs, item, parentTrueChain, parentFalseChain);
    ASSERT(item.kind IN {itemVar, itemRegI});
    ASSERT(e.lhs.typ.kind = AST.typeArray);
    size := CalculateSize(e.lhs.typ.base);
    ASSERT(size > 0);
    IF rhs.kind = itemConst THEN
      item.offset := item.offset + size*rhs.offset
    ELSE
      Load(rhs);
      Emit(opMULI, rhs.r, rhs.r, 0, size);
      IF item.kind = itemVar THEN
        Emit(opADD, rhs.r, item.r, rhs.r, 0);
        item.kind := itemRegI;
        item.r := rhs.r
      ELSIF item.kind = itemRegI THEN
        Emit(opADD, item.r, item.r, rhs.r, 0);
        (* rhs.r no longer needed *)
        DecCurReg
      ELSE
        ASSERT(FALSE)
      END
    END
  ELSIF e.kind = AST.exprBinary THEN
    IF e.op = Lex.tAMP THEN
      (* op is short circuit boolean AND. If lhs is false, don't execute rhs. *)
      (* also, if lhs short circuits to true, run rhs.                        *)
      localTrueChain := 0;
      GenExpr(e.lhs, item, localTrueChain, parentFalseChain);
      LoadCond(item);
      ASSERT(item.kind = itemCond);
      Emit(opBRA, 0, 0, NegateCond(item.opCond), 0);
      AddToChain(parentFalseChain);
      (* lhs was true, so run rhs *)
      FixChain(localTrueChain, cp);
      GenExpr(e.rhs, item, parentTrueChain, parentFalseChain);
    ELSIF e.op = Lex.tOR THEN
      (* op is short circuit boolean OR. If lhs is true, don't execute rhs. *)
      (* also, if lhs short circuits to false, run rhs.                     *)
      localFalseChain := 0;
      GenExpr(e.lhs, item, parentTrueChain, localFalseChain);
      LoadCond(item);
      ASSERT(item.kind = itemCond);
      Emit(opBRA, 0, 0, item.opCond, 0);
      AddToChain(parentTrueChain);
      (* lhs was false, so run rhs *)
      FixChain(localFalseChain, cp);
      GenExpr(e.rhs, item, parentTrueChain, parentFalseChain);
    ELSE
      GenExpr(e.lhs, item, parentTrueChain, parentFalseChain);
      GenExpr(e.rhs, rhs, parentTrueChain, parentFalseChain);
      GenBinaryOp(e.op, item, rhs)
    END
  ELSE
    ASSERT(FALSE)
  END
END GenExpr;

PROCEDURE GenStatements(s :AST.Stmt);
VAR
  e :AST.Expr;
  lhs, rhs :Item;
  elses :AST.Stmt;
  (* code pointers *)
  loopStart :INTEGER;
  after :INTEGER;
  trueChain, falseChain :INTEGER;
BEGIN
  WHILE s # NIL DO
    ASSERT(curReg = 0);
    IF s.kind = AST.stmtAssign THEN
      e := s.cond;
      ASSERT(e.kind = AST.exprAssign);
      ASSERT(e.lhs.typ.kind # AST.typeRecord);
      GenExpr(e.lhs, lhs, trueChain, falseChain);
      trueChain := 0; falseChain := 0;
      GenExpr(e.rhs, rhs, trueChain, falseChain);
      LoadValue(rhs, trueChain, falseChain);
      ASSERT(lhs.kind IN {itemVar, itemRegI});
      Emit(opSTW, rhs.r, lhs.r, 0, lhs.offset);
      IF lhs.kind = itemRegI THEN DecCurReg END;
      DecCurReg
    ELSIF s.kind = AST.stmtIf THEN
      after := 0;
      trueChain := 0; falseChain := 0;
      GenExpr(s.cond, lhs, trueChain, falseChain);
      LoadCond(lhs);
      ASSERT(lhs.kind = itemCond);
      Emit(opBRA, 0, 0, NegateCond(lhs.opCond), 0);
      AddToChain(falseChain);
      FixChain(trueChain, cp);
      GenStatements(s.body);
      elses := s.elsifs;
      WHILE elses # NIL DO
        Emit(opBRA, 0, 0, opB, 0);
        AddToChain(after);
        FixChain(falseChain, cp);
        trueChain := 0; falseChain := 0;
        IF elses.kind = AST.stmtElsIf THEN
          GenExpr(elses.cond, lhs, trueChain, falseChain);
          LoadCond(lhs);
          ASSERT(lhs.kind = itemCond);
          Emit(opBRA, 0, 0, NegateCond(lhs.opCond), 0);
          AddToChain(falseChain);
          ASSERT(lhs.kind = itemCond);
        ELSE
          ASSERT(elses.kind = AST.stmtElse)
        END;
        FixChain(trueChain, cp);
        GenStatements(elses.body);
        elses := elses.elsifs
      END;
      FixChain(falseChain, cp);
      FixChain(after, cp)
    ELSIF s.kind = AST.stmtRepeat THEN
      loopStart := cp;
      trueChain := 0; falseChain := 0;
      GenStatements(s.body);
      GenExpr(s.cond, lhs, trueChain, falseChain);
      (* False chain immediatly returns to loopStart *)
      FixChain(falseChain, loopStart);
      LoadCond(lhs);
      ASSERT(lhs.kind = itemCond);
      Emit(opBRA, 0, 0, NegateCond(lhs.opCond), loopStart);
      (* Loop done, so the true chain links here *)
      FixChain(trueChain, cp)
    ELSIF s.kind = AST.stmtWhile THEN
      ASSERT(s.elsifs = NIL);
      after := cp;
      Emit(opBRA, 0, 0, opB, 0);
      loopStart := cp;
      GenStatements(s.body);
      codeBuffer[after].value := cp; (* fix first branch to point to compare *)
      trueChain := 0; falseChain := 0;
      GenExpr(s.cond, lhs, trueChain, falseChain);
      (* True chain immediatly returns to loopStart *)
      FixChain(trueChain, loopStart);
      LoadCond(lhs);
      ASSERT(lhs.kind = itemCond);
      Emit(opBRA, 0, 0, lhs.opCond, loopStart);
      (* Loop done, so the false chain links here *)
      FixChain(falseChain, cp)
    ELSIF s.kind = AST.stmtProcCall THEN
      (* Temporary code that only generates procedure calls with 0 args *)
      ASSERT(s.cond.rhs = NIL);
      ASSERT(s.cond.lhs # NIL);
      ASSERT(s.cond.lhs.decl # NIL);
      Emit(opJSR, 0, 0, 0, s.cond.lhs.decl.offset);
      codeBuffer[cp - 1].q := s.cond.lhs.decl.qname;
    ELSIF s.kind = AST.stmtEmpty THEN
    ELSE
      ASSERT(FALSE)
    END;
    ASSERT(curReg = 0);
    s := s.next
  END
END GenStatements;

PROCEDURE GenerateProc*(l :Lex.Lexer; d :AST.Decl);
VAR
  fp :INTEGER;
  vars :AST.Decl;
BEGIN
  ASSERT(d.kind = AST.declProcedure);
  cp := 0;
  d.offset := pc;
  GenQName(l, d.qname); GenStr(": code offset: "); Out.Int(d.offset); GenLn;
  fp := 4; (* Leave 4 bytes for return address. Params right below. *)
  vars := d.procVars;
  WHILE (vars # NIL) &
        ((vars.kind = AST.declParam) OR (vars.kind = AST.declVarParam)) DO
    ASSERT(vars.offset < 0);
    vars.offset := fp;
    Tab; GenStr("; "); Lex.OutStr(l, vars.qname.name);
    GenStr(" offset "); Out.Int(fp); GenLn;
    (*
     * All parameters except arrays are 4 bytes, because they are either
     * primitives, records (passed by reference), var parameters (also
     * passed by reference) or pointers.
     *)
    fp := fp + 4;
    IF AST.IsOpenArray(vars.typ) THEN
      Tab; GenStr("; "); Lex.OutStr(l, vars.qname.name); GenStr("__len");
      GenStr(" offset "); Out.Int(fp); GenLn;
      fp := fp + 4
    END;
    vars := vars.next
  END;
  WHILE (vars # NIL) & (vars.kind # AST.declEND) DO
    IF vars.kind = AST.declVar THEN
      vars.offset := fp;
      Tab; GenStr("; "); Lex.OutStr(l, vars.qname.name); GenStr(" offset "); Out.Int(fp); GenLn;
      fp := fp + CalculateSize(vars.typ);
    END;
    vars := vars.next
  END;
  (* Preamble *)
  Emit(opSUBI, rSP, rSP, 0, fp);
  GenStatements(d.body);
  (* Epilog *)
  Emit(opADDI, rSP, rSP, 0, fp);
  Emit(opRTS, 0, 0, 0, 0);
  DumpCode(l, d.offset)
END GenerateProc;

PROCEDURE GenCall*(proc :AST.Decl);
BEGIN
  Emit(opJSR, 0, 0, 0, proc.offset);
  codeBuffer[cp - 1].q := proc.qname
END GenCall;

PROCEDURE GenStartMain*;
BEGIN
  cp := 0;
  GenStr("__start__:"); GenLn
END GenStartMain;

PROCEDURE GenEndMain*(l :Lex.Lexer);
BEGIN
  Emit(opHALT, 0, 0, 0, 0);
  DumpCode(l, 10000)
END GenEndMain;

BEGIN
  globalOffset := 0;
  lastType := 0;
  pc := 0
END RCodegen.

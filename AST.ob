MODULE AST;

IMPORT Lex, Out;

CONST
  typeNil*       = 1;
  typeInteger*   = 2;
  typeReal*      = 3;
  typeBoolean*   = 4;
  typeChar*      = 5;
  typeSet*       = 6;
  typeString*    = 7;
  typePointer*   = 8;
  typeArray*     = 9;
  typeRecord*    = 10;
  typeProcedure* = 11;
  typeImport*    = 12;

  declImport*    = 1;
  declConst*     = 2;
  declType*      = 3;
  declVar*       = 4;
  declProcedure* = 5;
  declParam*     = 6;
  declVarParam*  = 7;
  declField*     = 8;
  declEND* = 1001;

  exprVal*         = 1; (* CONST value *)
  exprUnary*       = 2;
  exprBinary*      = 3;
  expridentRef     = 4;
  exprProcCall     = 5;
  exprFieldRef     = 6;
  exprPointerDeref = 7;
  exprArrayRef     = 8;
  exprTypeguard    = 9;

TYPE
  StringId  = Lex.PoolIndex;
  TypeKind* = INTEGER;
  Type*     = POINTER TO TypeDesc;
  Decl*     = POINTER TO DeclDesc;
  TypeDesc  = RECORD
    kind*   :TypeKind;
    base*   :Type; (* POINTER type, ARRAY element, RECORD base, PROCEDURE return type *)
    fields* :Decl; (* RECORD fields / PROCEDURE formal parameters / IMPORT decls / name of forward decl *)
  END;
  DeclKind  = INTEGER;
  DeclDesc  = RECORD
    kind*     :DeclKind;
    next*     :Decl;
    name*     :StringId;
    typ*      :Type;
    exported* :BOOLEAN;
  END;
  Expr*     = POINTER TO ExprDesc;
  ExprKind  = INTEGER;
  (*
  A call to a PROCEDURE, e.g., MyProc(arg1, Proc2(a, b), arr[i], 4) looks like
  Expr:
    kind  --> exprProcCall
    lhs   --> Expr:
                kind --> exprIdentDef
                decl --> Decl FOR MyProc
    rhs   --> Expr:
                kind --> exprIdentDef
                decl --> Decl FOR arg1
                next --> Expr:
                           kind --> exprProcCall
                           lhs  --> Expr:
                                      kind --> exprIdentRef
                                      decl --> decl for Proc2
                           rhs  --> Expr:
                                      kind --> exprIdentRef
                                      decl --> decl for a
                                      next --> Expr:
                                                 kind -> exprIdentRef
                                                 decl -> decl for b
                                                 next -> NIL
                           next --> Expr:
                                      kind --> exprArrayRef
                                      lhs -> Expr (identRef FOR arr)
                                      rhs -> Expr (identRef FOR i)
                                      next -> Expr:
                                                kind --> exprVal
                                                iVal --> 4
                                                typ  --> typeInteger
                                                next --> NIL
  In other words, a proc call's lhs is the PROCEDURE's definition,
  the rhs is the first arg, and then follows the next chain OF those args.
  *)
  ExprDesc  = RECORD
    kind  :ExprKind;
    typ   :Type;
    op    :Lex.TokenKind; (* for unary, binary                            *)
    lhs   :Expr;          (* for unary, binary, the base expr for         *)
                          (* arrayRef, pointerDeref, fieldRef, typeGuard, *)
                          (* PROCEDURE call designator                    *)
    rhs   :Expr;          (* for binary, also first arg PROCEDURE call    *)
                          (* for arrayRef, expr OF ARRAY index            *)
    next  :Expr;          (* for PROCEDURE call,next arg in list          *)
    decl  :Decl;          (* for identRef and typeguard                   *)
    iVal  :INTEGER;       (* for INTEGER, SET, BOOLEAN, STRING (StringId) *)
                          (* for fieldref, StringId OF field name         *)
    rVal  :REAL;
  END;

PROCEDURE NewExpr(VAR e :Expr; kind :ExprKind; typ :Type);
BEGIN
  NEW(e);
  e.kind := kind;
  e.typ := typ;
END NewExpr;

PROCEDURE NewExprInteger*(iVal :INTEGER; typ :Type) :Expr;
VAR
  e :Expr;
BEGIN
  NewExpr(e, exprVal, typ);
  e.iVal := iVal;
  RETURN e
END NewExprInteger;

PROCEDURE NewExprReal*(rVal :REAL; typ :Type) :Expr;
VAR
  e :Expr;
BEGIN
  NewExpr(e, exprVal, typ);
  e.rVal := rVal;
  RETURN e
END NewExprReal;

PROCEDURE NewExprString*(sVal :StringId; typ :Type) :Expr;
VAR
  e :Expr;
BEGIN
  NewExpr(e, exprVal, typ);
  e.iVal := sVal;
  RETURN e
END NewExprString;

PROCEDURE NewExprNil*(typ :Type) :Expr;
VAR
  e :Expr;
BEGIN
  NewExpr(e, exprVal, typ);
  e.iVal := 0;
  RETURN e
END NewExprNil;

PROCEDURE NewExprBoolean*(bVal :INTEGER; typ :Type) :Expr;
VAR
  e :Expr;
BEGIN
  NewExpr(e, exprVal, typ);
  e.iVal := bVal;
  RETURN e
END NewExprBoolean;

END AST.

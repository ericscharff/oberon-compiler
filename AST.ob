MODULE AST;

IMPORT Lex;

CONST
  typeNil*       = 1;
  typeInteger*   = 2;
  typeReal*      = 3;
  typeBoolean*   = 4;
  typeChar*      = 5;
  typeSet*       = 6;
  typeString*    = 7;
  typePointer*   = 8;
  typeArray*     = 9;
  typeRecord*    = 10;
  typeProcedure* = 11;
  typeImport*    = 12;
  typeEND        = 13;

  declImport*    = 1;
  declConst*     = 2;
  declType*      = 3;
  declVar*       = 4;
  declProcedure* = 5;
  declParam*     = 6;
  declVarParam*  = 7;
  declField*     = 8;
  declBuiltin*   = 9;
  declEND* = 1001;

  exprVal*         = 1; (* CONST value *)
  exprUnary*       = 2;
  exprBinary*      = 3;
  exprIdentRef*    = 4;
  exprProcCall     = 5;
  exprFieldRef     = 6;
  exprPointerDeref = 7;
  exprArrayRef     = 8;
  exprTypeGuard    = 9;
  exprBuiltin*     = 10;

TYPE
  StringId         = Lex.PoolIndex;
  QName            = RECORD moduleName*, name* :StringId END;
  TypeKind*        = INTEGER;
  Type*            = POINTER TO TypeDesc;
  Decl*            = POINTER TO DeclDesc;
  Expr*            = POINTER TO ExprDesc;
  TypeDesc         = RECORD
    kind*         :TypeKind;
    base*         :Type;    (* POINTER type,                             *)
                            (* ARRAY element,                            *)
                            (* RECORD base,                              *)
                            (* PROCEDURE return type                     *)
    fields*       :Decl;    (* RECORD fields                             *)
                            (* PROCEDURE formal parameters               *)
                            (* IMPORT decls                              *)
                            (* Name of forward decl                      *)
    length*       :INTEGER; (* ARRAY length                              *)
                            (* PROCEDURE number of parameters            *)
    needTypeInfo* :BOOLEAN; (* Type uses IS or typeguard, and thus needs *)
                            (* runtime info                              *)
  END;
  BuiltinResolver* = PROCEDURE (l :Lex.Lexer; args :Expr) :Expr;
  DeclKind         = INTEGER;
  DeclDesc         = RECORD
    kind*     :DeclKind;
    next*     :Decl;
    qname*    :QName;
    typ*      :Type;
    expr*     :Expr;             (* for CONST declarations *)
    exported* :BOOLEAN;
    resolver* :BuiltinResolver;  (* Handles native procedure calls *)
  END;
  ExprKind         = INTEGER;
  (*
  A call to a PROCEDURE, e.g., MyProc(arg1, Proc2(a, b), arr[i], 4) looks like
  Expr:
    kind  --> exprProcCall
    iVal  --> 4
    lhs   --> Expr:
                kind --> exprIdentDef
                decl --> Decl FOR MyProc
    rhs   --> Expr:
                kind --> exprIdentDef
                decl --> Decl FOR arg1
                next --> Expr:
                           kind --> exprProcCall
                           iVal --> 2
                           lhs  --> Expr:
                                      kind --> exprIdentRef
                                      decl --> decl for Proc2
                           rhs  --> Expr:
                                      kind --> exprIdentRef
                                      decl --> decl for a
                                      next --> Expr:
                                                 kind -> exprIdentRef
                                                 decl -> decl for b
                                                 next -> NIL
                           next --> Expr:
                                      kind --> exprArrayRef
                                      lhs -> Expr (identRef FOR arr)
                                      rhs -> Expr (identRef FOR i)
                                      next -> Expr:
                                                kind --> exprVal
                                                iVal --> 4
                                                typ  --> typeInteger
                                                next --> NIL
  In other words, a proc call's lhs is the PROCEDURE's definition,
  the rhs is the first arg, and then follows the next chain OF those args.
  *)
  ExprDesc  = RECORD
    kind*  :ExprKind;
    typ*   :Type;
    op     :Lex.TokenKind; (* for unary, binary                            *)
    lhs    :Expr;          (* for unary, binary, the base expr for         *)
                           (* arrayRef, pointerDeref, fieldRef, typeGuard, *)
                           (* PROCEDURE call designator                    *)
    rhs    :Expr;          (* for binary, also first arg PROCEDURE call    *)
                           (* for arrayRef, expr OF ARRAY index            *)
    next*  :Expr;          (* for PROCEDURE call,next arg in list          *)
    decl*  :Decl;          (* for identRef and typeguard                   *)
    iVal*  :INTEGER;       (* for INTEGER, BOOLEAN, STRING (StringId)      *)
                           (* for fieldref, StringId OF field name         *)
                           (* for PROCEDURE call, number OF actual params  *)
                           (* for builtin procedure, unique identifier     *)
    rVal   :REAL;
    setVal :SET;
    assignable* :BOOLEAN;
  END;

VAR
  currentModuleName* :StringId;
  TypeKindNames :ARRAY typeEND, 10 OF CHAR;
  DumpExpr* :PROCEDURE (l :Lex.Lexer; e :Expr);

PROCEDURE SetModuleName*(name :StringId) :StringId;
VAR
  oldModuleName :StringId;
BEGIN
  oldModuleName := currentModuleName;
  currentModuleName := name;
  RETURN oldModuleName
END SetModuleName;

PROCEDURE IsImported(d :Decl) :BOOLEAN;
BEGIN
  ASSERT(d # NIL);
  WHILE (d # NIL) & (d.kind # declEND) DO
    d := d.next;
  END;
  ASSERT(d # NIL);
  ASSERT(d.kind = declEND);
  RETURN d.qname.moduleName # currentModuleName
END IsImported;

PROCEDURE ExpectType(l :Lex.Lexer; e :Expr; kind :TypeKind);
BEGIN
  ASSERT(e # NIL);
  ASSERT(e.typ # NIL);
  IF e.typ.kind # kind THEN
    Lex.Error(l, "Expected ");
    Lex.Str(TypeKindNames[kind]);
    Lex.Str(", got ");
    Lex.PrintLn(TypeKindNames[e.typ.kind]);
  END;
END ExpectType;

PROCEDURE IsStringType(t :Type) :BOOLEAN;
BEGIN
  RETURN (t.kind = typeString) OR ((t.kind = typeArray) & (t.base.kind = typeChar))
END IsStringType;

(* does a extend b *)
PROCEDURE Extends(a, b :Type) :BOOLEAN;
BEGIN
  IF (a # NIL) & (b # NIL) & (a.kind = typeRecord) & (b.kind = typeRecord) THEN
    WHILE (a # NIL) & (a # b) DO
      a := a.base;
    END;
  END;
  RETURN (a # NIL) & (b # NIL) & (a = b)
END Extends;

PROCEDURE IsOpenArray(t :Type) :BOOLEAN;
BEGIN
  RETURN (t.kind = typeArray) & (t.length = 0)
END IsOpenArray;

(* Is b := a legal? Note that this is not symmetric, for example, *)
(* b := "hello"; is legal if b is an array of char, but           *)
(* "hello" := b would not be legal. When doing comparasons (e.g., *)
(* for boolean =, it is necessar to comapre a to b OR b to a      *)
PROCEDURE AssignmentCompatable(l :Lex.Lexer; a, b :Type; aSval, bSval :StringId) :BOOLEAN;
BEGIN
  RETURN
    (a = b) OR
    ((a.kind = typeString) & (b.kind = typeString)) OR
    ((a.kind = typeChar) & (b.kind = typeString) & Lex.IsOneChar(l, bSval)) OR
    ((b.kind = typeChar) & (a.kind = typeString) & Lex.IsOneChar(l, aSval)) OR
    ((a.kind = typeNil) & (b.kind = typePointer)) OR
    ((a.kind = typeNil) & (b.kind = typeProcedure)) OR
    ((a.kind = typePointer) & (b.kind = typePointer) & Extends(a.base, b.base)) OR
    ((a.kind = typeRecord) & (b.kind = typeRecord) & Extends(a, b)) OR
    ((a.kind = typeString) & (b.kind = typeArray) & (b.base.kind = typeChar))
    (* Strictly speaking, that last case is not true in Oberon. You cannot  *)
    (* assign one array to another, except for strings. However, this is    *)
    (* meant to be used for parameter checking, where the formal is an open *)
    (* array, and the actual is an array of that type. This test passes to  *)
    (* support argument passing, but should fail elsewhere (e.g., arrays    *)
    (* cannot be assigned to because is_assignable is FALSE, and arrays     *)
END AssignmentCompatable;

PROCEDURE ExprCompatable(l :Lex.Lexer; op :Lex.TokenKind; lhs, rhs :Expr) :BOOLEAN;
VAR
  good :BOOLEAN;
BEGIN
  IF AssignmentCompatable(l, lhs.typ, rhs.typ, lhs.iVal, rhs.iVal) OR
     AssignmentCompatable(l, rhs.typ, lhs.typ, rhs.iVal, lhs.iVal) THEN
    good := TRUE;
  ELSE
    good := FALSE;
    Lex.Error(l, "Type mismatch for op [");
    Lex.Str(Lex.TokenNames[op]);
    Lex.Str("] got ");
    Lex.Str(TypeKindNames[lhs.typ.kind]);
    Lex.Str(" and ");
    Lex.PrintLn(TypeKindNames[rhs.typ.kind]);
  END;
  RETURN good
END ExprCompatable;


PROCEDURE IsConst*(e :Expr) :BOOLEAN;
BEGIN
  RETURN e.kind = exprVal
END IsConst;

PROCEDURE NewExpr*(VAR e :Expr; kind :ExprKind; typ :Type);
BEGIN
  NEW(e);
  e.kind := kind;
  e.typ := typ;
  e.next := NIL;
  e.assignable := FALSE;
END NewExpr;

PROCEDURE NewExprIdentRef*(d :Decl) :Expr;
VAR
  e :Expr;
BEGIN
  ASSERT(d # NIL);
  ASSERT(d.typ # NIL);
  NewExpr(e, exprIdentRef, d.typ);
  e.decl := d;
  IF ((d.kind = declVar) & ~IsImported(d)) OR
     ((d.kind = declParam) & ~(d.typ.kind IN {typeArray, typeRecord})) OR
     (d.kind = declVarParam) THEN
    e.assignable := TRUE;
  ELSE
    e.assignable := FALSE;
  END;
  IF d.kind = declConst THEN
    ASSERT(d.typ = d.expr.typ);
    ASSERT(d.expr.kind = exprVal);
    e.kind := exprVal;
    e.iVal := d.expr.iVal;
    e.rVal := d.expr.rVal;
    e.setVal := d.expr.setVal;
  END;
  RETURN e
END NewExprIdentRef;

PROCEDURE NewExprPointerDeref*(l :Lex.Lexer; base :Expr) :Expr;
VAR
  e :Expr;
BEGIN
  NewExpr(e, exprPointerDeref, base.typ);
  e.lhs := base;
  e.assignable := base.assignable;
  IF base.typ.kind = typePointer THEN
    e.typ := base.typ.base;
  ELSE
    Lex.ErrorLn(l, "not a POINTER");
  END;
  RETURN e
END NewExprPointerDeref;

PROCEDURE NewExprFieldRef*(l :Lex.Lexer; base :Expr; name :StringId) :Expr;
VAR
  e :Expr;
  d :Decl;
BEGIN
  e := base;
  IF base.typ.kind = typePointer THEN
    base := NewExprPointerDeref(l, base);
  END;
  IF base.typ.kind = typeRecord THEN
    d := base.typ.fields;
    WHILE (d # NIL) & (d.kind # declEND) & (d.qname.name # name) DO
      d := d.next;
    END;
    IF d.qname.name = name THEN
      IF IsImported(d) & ~d.exported THEN
        Lex.Error(l, "Field ");
        Lex.OutStr(l, name);
        Lex.PrintLn(" is private");
      END;
      NewExpr(e, exprFieldRef, d.typ);
      e.lhs := base;
      e.iVal := name;
      e.assignable := base.assignable;
    ELSE
      Lex.Error(l, "Field ");
      Lex.OutStr(l, name);
      Lex.PrintLn(" not found");
    END;
  ELSE
    Lex.ErrorLn(l, "Not a RECORD");
  END;
  RETURN e
END NewExprFieldRef;

PROCEDURE NewExprArrayRef*(l :Lex.Lexer; base, index :Expr) :Expr;
VAR
  e :Expr;
  d :Decl;
BEGIN
  e := base;
  IF base.typ.kind = typeArray THEN
    IF index.typ.kind = typeInteger THEN
      IF (index.kind = exprVal) & (base.typ.length > 0) &
         ((index.iVal < 0) OR (index.iVal >= base.typ.length)) THEN
        Lex.Error(l, "Array index ");
        Lex.Int(index.iVal);
        Lex.Str(" out OF range for ARRAY OF length ");
        Lex.Int(base.typ.length);
        Lex.Ln;
      ELSE
        NewExpr(e, exprArrayRef, base.typ.base);
        e.lhs := base;
        e.rhs := index;
        e.assignable := base.assignable;
      END;
    ELSE
      Lex.Error(l, "ARRAY index must be an INTEGER, got ");
      Lex.PrintLn(TypeKindNames[index.typ.kind]);
    END;
  ELSE
    Lex.ErrorLn(l, "Not an ARRAY");
  END;
  RETURN e
END NewExprArrayRef;

PROCEDURE SetGenTypeInfo(t :Type);
BEGIN
  IF t.kind = typePointer THEN
    t := t.base;
  END;
  WHILE t # NIL DO
    t.needTypeInfo := TRUE;
    t := t.base;
  END;
END SetGenTypeInfo;

PROCEDURE NewExprTypeGuard*(l :Lex.Lexer; base :Expr; newType :Decl) :Expr;
VAR
  e :Expr;
BEGIN
  e := base;
  IF (newType.kind = declType) & (newType.typ.kind IN {typeRecord, typePointer}) THEN
    IF ((base.typ.kind = typePointer) & (newType.typ.kind = typePointer) & Extends(newType.typ.base, base.typ.base)) OR
       ((base.typ.kind = typeRecord) & (newType.typ.kind = typeRecord) & Extends(newType.typ, base.typ)) THEN
      NewExpr(e, exprTypeGuard, newType.typ);
      e.lhs := base;
      e.decl := newType;
      e.assignable := base.assignable;
      SetGenTypeInfo(newType.typ);
    ELSE
      Lex.ErrorLn(l, "Guarded and base type are unrelated");
    END;
  ELSE
    Lex.Error(l, "Declaration ");
    Lex.OutStr(l, newType.qname.name);
    Lex.PrintLn(" must be a POINTER or RECORD type");
  END;
  RETURN e
END NewExprTypeGuard;

PROCEDURE NewExprInteger*(iVal :INTEGER; typ :Type) :Expr;
VAR
  e :Expr;
BEGIN
  NewExpr(e, exprVal, typ);
  e.iVal := iVal;
  RETURN e
END NewExprInteger;

PROCEDURE NewExprReal*(rVal :REAL; typ :Type) :Expr;
VAR
  e :Expr;
BEGIN
  NewExpr(e, exprVal, typ);
  e.rVal := rVal;
  RETURN e
END NewExprReal;

PROCEDURE NewExprString*(sVal :StringId; typ :Type) :Expr;
VAR
  e :Expr;
BEGIN
  NewExpr(e, exprVal, typ);
  e.iVal := sVal;
  RETURN e
END NewExprString;

PROCEDURE NewExprNil*(typ :Type) :Expr;
VAR
  e :Expr;
BEGIN
  NewExpr(e, exprVal, typ);
  e.iVal := 0;
  RETURN e
END NewExprNil;

PROCEDURE NewExprBoolean*(bVal :INTEGER; typ :Type) :Expr;
VAR
  e :Expr;
BEGIN
  NewExpr(e, exprVal, typ);
  e.iVal := bVal;
  RETURN e
END NewExprBoolean;

PROCEDURE NewExprSet*(typ :Type) :Expr;
VAR
  e :Expr;
BEGIN
  NewExpr(e, exprVal, typ);
  e.setVal := {};
  RETURN e
END NewExprSet;

PROCEDURE NewExprSetUnion*(l :Lex.Lexer; lhs, rhs :Expr) :Expr;
VAR
  e :Expr;
BEGIN
  ExpectType(l, lhs, typeSet);
  ExpectType(l, rhs, typeSet);
  IF IsConst(lhs) & IsConst(rhs) THEN
    e := NewExprSet(lhs.typ);
    e.setVal := lhs.setVal + rhs.setVal;
  ELSE
    NewExpr(e, exprBinary, lhs.typ);
    e.op := Lex.tPLUS;
    e.lhs := lhs;
    e.rhs := rhs;
  END;
  RETURN e
END NewExprSetUnion;

PROCEDURE NewExprSetElement*(l :Lex.Lexer; elt :Expr; setType :Type) :Expr;
VAR
  e :Expr;
BEGIN
  e := NewExprSet(setType);
  e.setVal := {};
  ExpectType(l, elt, typeInteger);
  IF IsConst(elt) THEN
    IF (elt.iVal < 0) OR (elt.iVal > 31) THEN
      Lex.Error(l, "Value ");
      Lex.Int(elt.iVal);
      Lex.PrintLn(" out OF range of SET 0..31");
    ELSE
      e := NewExprSet(setType);
      e.setVal := {elt.iVal};
    END;
  ELSE
    NewExpr(e, exprUnary, setType);
    e.op := Lex.tAsSetElt;
    e.lhs := elt;
  END;
  RETURN e
END NewExprSetElement;

PROCEDURE NewExprSetRange*(l :Lex.Lexer; lhs, rhs :Expr; setType :Type) :Expr;
VAR
  e :Expr;
BEGIN
  ExpectType(l, lhs, typeInteger);
  ExpectType(l, rhs, typeInteger);
  IF IsConst(lhs) & IsConst(rhs) THEN
    e := NewExprSet(setType);
    e.setVal := {lhs.iVal .. rhs.iVal};
  ELSE
    NewExpr(e, exprBinary, setType);
    e.op := Lex.tDOTDOT;
    e.lhs := lhs;
    e.rhs := rhs;
  END;
  RETURN e
END NewExprSetRange;

PROCEDURE NewExprUnary*(l :Lex.Lexer; op :Lex.TokenKind; lhs :Expr) :Expr;
VAR
  e :Expr;
BEGIN
  NewExpr(e, exprUnary, lhs.typ);
  e.op := op;
  e.lhs := lhs;
  CASE op OF
      Lex.tPLUS:
      IF lhs.typ.kind IN {typeInteger, typeReal, typeSet} THEN
        e := lhs;
      ELSE
        Lex.ErrorLn(l, "Expected INTEGER, REAL, or SET");
      END;
    | Lex.tMINUS:
      IF lhs.typ.kind IN {typeInteger, typeReal, typeSet} THEN
        IF IsConst(lhs) THEN
          e.kind := exprVal;
          (* we do every operation, even if some are invalid, because one will be right *)
          e.iVal := -lhs.iVal;
          e.rVal := -lhs.rVal;
          e.setVal := -lhs.setVal;
        END;
      ELSE
        Lex.ErrorLn(l, "Expected INTEGER, REAL, or SET");
      END;
    | Lex.tTILDE:
      IF lhs.typ.kind = typeBoolean THEN
        IF IsConst(lhs) THEN
          (* evaluate *)
        END;
      ELSE
        Lex.ErrorLn(l, "Expected BOOLEAN");
      END;
  END;
  RETURN e
END NewExprUnary;

PROCEDURE NewExprBinary*(l :Lex.Lexer; op :Lex.TokenKind; lhs, rhs :Expr; booleanType :Type) :Expr;
VAR
  e :Expr;
BEGIN
  NewExpr(e, exprBinary, lhs.typ);
  e.op := op;
  e.lhs := lhs;
  e.rhs := rhs;
  CASE op OF
      Lex.tPLUS, Lex.tMINUS, Lex.tSTAR, Lex.tSLASH:
      IF ExprCompatable(l, op, lhs, rhs) &
         (lhs.typ.kind IN {typeInteger, typeReal, typeSet}) THEN
        IF IsConst(lhs) & IsConst(rhs) THEN
          e.kind := exprVal;
          (* we do every operation, even if some are invalid, because one will be right *)
          IF op = Lex.tPLUS THEN
            e.iVal := lhs.iVal + rhs.iVal;
            e.rVal := lhs.rVal + rhs.rVal;
            e.setVal := lhs.setVal + rhs.setVal;
          ELSIF op = Lex.tMINUS THEN
            e.iVal := lhs.iVal - rhs.iVal;
            e.rVal := lhs.rVal - rhs.rVal;
            e.setVal := lhs.setVal - rhs.setVal;
          ELSIF op = Lex.tSTAR THEN
            e.iVal := lhs.iVal * rhs.iVal;
            e.rVal := lhs.rVal * rhs.rVal;
            e.setVal := lhs.setVal * rhs.setVal;
          ELSIF op = Lex.tSLASH THEN
            (* avoid division by zero by instead returning a wrong answer *)
            IF rhs.iVal = 0 THEN e.iVal := 0 ELSE e.iVal := lhs.iVal / rhs.iVal END;
            IF rhs.rVal = 0.0 THEN e.rVal := 0.0 ELSE e.rVal := lhs.rVal / rhs.rVal END;
            e.setVal := lhs.setVal / rhs.setVal;
          END;
        END;
      ELSE
        Lex.ErrorLn(l, "Expected INTEGER, REAL, or SET");
      END;
    | Lex.tDIV, Lex.tMOD, Lex.tXOR:
      IF ExprCompatable(l, op, lhs, rhs) &
         (lhs.typ.kind = typeInteger) THEN
        IF IsConst(lhs) & IsConst(rhs) THEN
          e.kind := exprVal;
          IF op = Lex.tDIV THEN
            e.iVal := lhs.iVal DIV rhs.iVal;
          ELSIF op = Lex.tMOD THEN
            e.iVal := lhs.iVal MOD rhs.iVal;
          ELSIF op = Lex.tXOR THEN
            e.iVal := lhs.iVal XOR rhs.iVal;
          END;
        END;
      ELSE
        Lex.ErrorLn(l, "Expected INTEGER");
      END;
    | Lex.tAMP, Lex.tOR:
      IF ExprCompatable(l, op, lhs, rhs) &
         (lhs.typ.kind = typeBoolean) THEN
        IF IsConst(lhs) & IsConst(rhs) THEN
          (* evaluate *)
        END;
      ELSE
        Lex.ErrorLn(l, "Expected BOOLEAN");
      END;
    | Lex.tLT, Lex.tGT, Lex.tLTEQ, Lex.tGTEQ:
      e.typ := booleanType;
      IF ExprCompatable(l, op, lhs, rhs) &
         (IsStringType(lhs.typ) OR
          (lhs.typ.kind IN {typeInteger, typeReal, typeSet, typeString, typeChar})) THEN
        IF IsConst(lhs) & IsConst(rhs) THEN
          (* evaluate *)
        END;
      ELSE
        Lex.ErrorLn(l, "Expected INTEGER, REAL, SET, STRING, or CHAR");
      END;
    | Lex.tEQ, Lex.tPOUND:
      e.typ := booleanType;
      IF ExprCompatable(l, op, lhs, rhs) &
         (IsStringType(lhs.typ) OR
          (lhs.typ.kind IN {typeInteger, typeReal, typeSet, typeString, typeChar, typePointer, typeProcedure})) THEN
        IF IsConst(lhs) & IsConst(rhs) THEN
          (* evaluate *)
        END;
      ELSE
        Lex.ErrorLn(l, "Expected INTEGER, REAL, SET, STRING, CHAR, POINTER, or PROCEDURE");
      END;
    | Lex.tIN:
      e.typ := booleanType;
      IF (lhs.typ.kind = typeInteger) & (rhs.typ.kind = typeSet) THEN
        IF IsConst(lhs) & IsConst(rhs) THEN
          (* evaluate *)
        END;
      ELSE
        Lex.ErrorLn(l, "Expected INTEGER and SET expected");
      END;
    | Lex.tIS:
      e.typ := booleanType;
      IF ~(lhs.typ.kind IN {typeRecord, typePointer}) THEN
        Lex.ErrorLn(l, "LHS must be a POINTER or RECORD");
      END;
      IF ~(rhs.typ.kind IN {typeRecord, typePointer}) THEN
        Lex.ErrorLn(l, "RHS must be a POINTER or RECORD");
      END;
      IF lhs.typ.kind # rhs.typ.kind THEN
        Lex.ErrorLn(l, "LHS and RHS types must match");
      END;
      IF (lhs.kind = typeRecord) & ((lhs.kind # exprIdentRef) OR (lhs.decl.kind # declVarParam)) THEN
        Lex.ErrorLn(l, "LHS must be a VAR parameter");
      END;
      IF (rhs.kind # exprIdentRef) OR (rhs.decl.kind # declType) THEN
        Lex.ErrorLn(l, "RHS must be a type declaration");
      END;
      IF Extends(rhs.typ, lhs.typ) OR Extends(rhs.typ.base, lhs.typ.base) THEN
        SetGenTypeInfo(rhs.typ);
      ELSE
        Lex.ErrorLn(l, "LHS and RHS types are unrelated");
      END;
  END;
  RETURN e
END NewExprBinary;

PROCEDURE ExpectArgMatch(l :Lex.Lexer; arg :INTEGER; actual :Expr; formal :Decl);
BEGIN
  IF IsOpenArray(formal.typ) & (actual.typ.kind = typeArray) &
     (actual.typ.base = formal.typ.base) THEN
    (* Good - ARRAY OF X - ARRAY n OF X *)
  ELSIF (formal.kind = declVarParam) & ~actual.assignable THEN
    Lex.Error(l, "For argument ");
    Lex.Int(arg);
    Lex.PrintLn(", param is not assignable (expected VAR param)");
  ELSIF ~AssignmentCompatable(l, actual.typ, formal.typ, actual.iVal, actual.iVal) THEN
    Lex.Error(l, "For argument ");
    Lex.Int(arg);
    Lex.Str(", expected ");
    Lex.Str(TypeKindNames[formal.typ.kind]);
    Lex.Str(", got ");
    Lex.PrintLn(TypeKindNames[actual.typ.kind]);
  END;
END ExpectArgMatch;

PROCEDURE NewExprProcCall*(l :Lex.Lexer; proc, args :Expr) :Expr;
VAR
  e, arg   :Expr;
  i, count :INTEGER;
  formal   :Decl;
BEGIN
  e := proc;
  IF proc.typ.kind = typeProcedure THEN
    i := 0;
    count := proc.typ.length;
    NewExpr(e, exprProcCall, proc.typ.base); (* base = return type *)
    e.lhs := proc;
    e.rhs := args;
    arg := args;
    WHILE arg # NIL DO
      INC(i);
      arg := arg.next;
    END;
    IF i = count THEN
      i := 1;
      arg := args;
      formal := proc.typ.fields;
      WHILE count > 0 DO
        ExpectArgMatch(l, i, arg, formal);
        DEC(count);
        INC(i);
        formal := formal.next;
        arg := arg.next;
      END;
    ELSE
      Lex.Error(l, "Expected ");
      Lex.Int(count);
      Lex.Str(" parameters, got ");
      Lex.Int(i);
      Lex.Ln;
    END;
  ELSIF (proc.kind = exprIdentRef) & (proc.decl.kind = declBuiltin) THEN
    e := proc.decl.resolver(l, args);
  ELSE
    Lex.ErrorLn(l, "designator is not a PROCEDURE");
  END;
  RETURN e
END NewExprProcCall;

(*
PROCEDURE DumpDecl*(l :Lex.Lexer; d :Decl);
BEGIN
  Lex.Str("(DECL ");
  Lex.OutStr(l, d.qname.name);
  Lex.Str(" ");
  CASE d.kind OF
  declImport: Out.Str("IMPORT ")
  | declConst: Out.Str("CONST "); DumpExpr(l, d.expr);
  | declType: Out.Str("TYPE ");
  | declVar: Out.Str("VAR ");
  | declProcedure: Out.Str("PROCEDURE ");
  | declParam: Out.Str("PARAM ");
  | declVarParam: Out.Str("VARPARAM ");
  | declEND: Out.Str("SCOPE END ");
  END;
  Out.Str(TypeKindNames[d.typ.kind]);
  Out.PrintLn(")");

END DumpDecl;

PROCEDURE DumpExpr0*(l :Lex.Lexer; e :Expr);
VAR
  p :Expr;
BEGIN
  IF e = NIL THEN
    Out.PrintLn("(NIL EXPR)");
  ELSE
    Out.Str("(");
    CASE e.kind OF
       exprVal :
         Out.Str("VAL ");
         Out.Str(TypeKindNames[e.typ.kind]);
         CASE e.typ.kind OF
           typeInteger, typeBoolean: Out.Str(" "); Out.Int(e.iVal);
           | typeReal: Out.Str(" "); Out.Real(e.rVal);
           | typeString: Out.Str(" "); Out.Str(22X); Lex.OutStr(l, e.iVal); Out.Str(22X);
           | typeSet: Out.Str(" "); Out.Int(ORD(e.setVal));
         END;
     | exprUnary :
         Out.Str("UNARY ");
         Out.Str(Lex.TokenNames[e.op]);
         Out.Str(" ");
         Out.Str(TypeKindNames[e.typ.kind]);
         DumpExpr(l, e.lhs);
     | exprBinary :
         Out.Str("BINARY ");
         Out.Str(Lex.TokenNames[e.op]);
         Out.Str(" ");
         Out.Str(TypeKindNames[e.typ.kind]);
         DumpExpr(l, e.lhs);
         Out.Str(" ");
         DumpExpr(l, e.rhs);
     | exprIdentRef :
         Out.Str("IDENTREF ");
         DumpDecl(l, e.decl);
     | exprProcCall :
         Out.Str("PROCCALL ");
         DumpExpr(l, e.lhs);
         p := e.rhs;
         WHILE p # NIL DO
           DumpExpr(l, p);
           p := p.next;
         END;
     | exprFieldRef :
         Out.Str("FIELDREF ");
         DumpExpr(l, e.lhs);
         Out.Str(" ");
         Lex.OutStr(l, e.iVal);
     | exprPointerDeref :
         Out.Str("POINTERDEREF ");
         DumpExpr(l, e.lhs);
     | exprArrayRef :
         Out.Str("ARRAYREF ");
         DumpExpr(l, e.lhs);
         Out.Str(" ");
         DumpExpr(l, e.rhs);
     | exprTypeGuard :
         Out.Str("TYPEGUARD ");
         DumpExpr(l, e.lhs);
         Out.Str(" ");
         DumpDecl(l, e.decl);
    END;
    Out.PrintLn(")");
  END;
END DumpExpr0;
*)

PROCEDURE InitTypeKindNames;
BEGIN
  TypeKindNames[typeNil]       := "NIL";
  TypeKindNames[typeInteger]   := "INTEGER";
  TypeKindNames[typeReal]      := "REAL";
  TypeKindNames[typeBoolean]   := "BOOLEAN";
  TypeKindNames[typeChar]      := "CHAR";
  TypeKindNames[typeSet]       := "SET";
  TypeKindNames[typeString]    := "STRING";
  TypeKindNames[typePointer]   := "POINTER";
  TypeKindNames[typeArray]     := "ARRAY";
  TypeKindNames[typeRecord]    := "RECORD";
  TypeKindNames[typeProcedure] := "PROCEDURE";
  TypeKindNames[typeImport]    := "IMPORT";
END InitTypeKindNames;

BEGIN
  currentModuleName := 0;
(*  DumpExpr := DumpExpr0; *)
  InitTypeKindNames;
END AST.

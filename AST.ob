MODULE AST;

IMPORT Lex, Out;

CONST
  typeNil       = 1;
  typeInteger   = 2;
  typeReal      = 3;
  typeBoolean   = 4;
  typeChar      = 5;
  typeSet       = 6;
  typeString    = 7;
  typePointer   = 8;
  typeArray     = 9;
  typeRecord    = 10;
  typeProcedure = 11;

  declImport     = 1;
  declConst      = 2;
  declType*      = 3;
  declVar*       = 4;
  declProcedure* = 5;
  declParam*     = 6;
  declVarParam*  = 7;
  declField*     = 8;

  declEND = 1001;

TYPE
  StringId  = Lex.PoolIndex;
  TypeKind  = INTEGER;
  Type*     = POINTER TO TypeDesc;
  Decl*     = POINTER TO DeclDesc;
  TypeDesc  = RECORD
    kind    :TypeKind;
    base*   :Type; (* POINTER type, ARRAY element, RECORD base, PROCEDURE return type *)
    fields* :Decl; (* RECORD fields or PROCEDURE formal parameters, or name of forward decl *)
  END;
  DeclKind  = INTEGER;
  DeclDesc  = RECORD
    kind*     :DeclKind;
    next*     :Decl;
    name*     :StringId;
    typ*      :Type;
    exported* :BOOLEAN;
    decls*    :Decl; (* If kind = IMPORT then this field IS the imported MODULE's declarations *)
  END;
  Forward   = POINTER TO FwdDecl;
  FwdDecl   = RECORD
    t    :Type;
    next :Forward;
  END;

VAR
  scope :Decl;
  fwds  :Forward;

PROCEDURE LookupDecl0(name :StringId) :Decl;
VAR
  p :Decl;
BEGIN
  p := scope;
  WHILE (p # NIL) & (p.name # name) DO
    p := p.next;
  END;
  RETURN p
END LookupDecl0;


PROCEDURE LookupDecl*(l :Lex.Lexer; name :StringId) :Decl;
VAR
  p :Decl;
BEGIN
  p := LookupDecl0(name);
  IF p = NIL THEN
    Lex.Error(l, "");
    Lex.OutStr(l, name);
    Out.PrintLn(" undefined");
  END;
  RETURN p
END LookupDecl;

PROCEDURE AddDecl*(l :Lex.Lexer; VAR chain :Decl; name :StringId) :Decl;
VAR
  p, d :Decl;
BEGIN
  NEW(d);
  d.name := name;
  d.kind := 0;
  d.next := NIL;
  d.exported := FALSE;
  IF chain = NIL THEN NEW(chain);
    chain.kind := declEND;
    chain.name := 0;
    chain.next := NIL;
  END;
  IF chain.kind = declEND THEN
    d.next := chain;
    chain := d;
  ELSE
    p := chain;
    WHILE (p.next.kind # declEND) & (p.name # name) DO
      p := p.next;
    END;
    IF p.name = name THEN
      Lex.Error(l, "");
      Lex.OutStr(l, name);
      Out.PrintLn(" already defined");
    ELSE
      d.next := p.next;
      p.next := d;
    END;
  END;
  RETURN d
END AddDecl;

PROCEDURE AddScopeDecl*(l :Lex.Lexer; name :StringId) :Decl;
BEGIN
  RETURN AddDecl(l, scope, name)
END AddScopeDecl;

PROCEDURE NewType(VAR t :Type; kind :TypeKind);
BEGIN
  NEW(t);
  t.kind := kind;
  t.base := NIL;
  t.fields := NIL;
END NewType;

PROCEDURE NewArrayType*(base :Type) :Type;
VAR
  t :Type;
BEGIN
  NewType(t, typeArray);
  t.base := base;
  RETURN t
END NewArrayType;

PROCEDURE NewPointerType*(l :Lex.Lexer; base :Type) :Type;
VAR
  t :Type;
BEGIN
  t := NIL;
  IF (base # NIL) & (base.kind # typeRecord) THEN
    Lex.ErrorLn(l, "Pointer base type must be a RECORD");
  ELSE
    NewType(t, typePointer);
    t.base := base;
  END;
  RETURN t
END NewPointerType;

PROCEDURE NewPointerTypeByName*(l :Lex.Lexer; name :StringId) :Type;
VAR
  d :Decl;
  f :Forward;
  t :Type;
BEGIN
  t := NIL;
  d := LookupDecl0(name);
  IF d = NIL THEN
    (* forward decl *)
    NewType(t, typePointer);
    NEW(t.fields);
    t.fields.name := name;
    t.fields.next := NIL;
    NEW(f);
    f.t := t;
    f.next := fwds;
    fwds := f;
  ELSE
    IF d.kind # declType THEN
      Lex.Error(l, "");
      Lex.OutStr(l, d.name);
      Out.PrintLn(" is not a TYPE");
    END;
    t := NewPointerType(l, d.typ);
  END;
  RETURN t
END NewPointerTypeByName;

PROCEDURE NewProcedureType*() :Type;
VAR
  t :Type;
BEGIN
  NewType(t, typeProcedure);
  RETURN t
END NewProcedureType;

PROCEDURE NewRecordType*(l :Lex.Lexer; base :Type) :Type;
VAR
  t        :Type;
  d, dCopy :Decl;
BEGIN
  NewType(t, typeRecord);
  t.base := base;
  IF base # NIL THEN
    IF base.kind = typeRecord THEN
      (* Copy fields from base *)
      d := base.fields;
      WHILE (d # NIL) & (d.kind # declEND) DO
        dCopy := AddDecl(l, t.fields, d.name);
	dCopy.kind := d.kind;
	dCopy.typ := d.typ;
	dCopy.exported := d.exported;
	d := d.next;
      END;
    ELSE
      Lex.ErrorLn(l, "RECORD base type is not a RECORD");
    END;
  END;
  RETURN t
END NewRecordType;

PROCEDURE AddTypeDecl(VAR l :Lex.Lexer; name :StringId; t :Type);
VAR
  d :Decl;
BEGIN
  d := AddDecl(l, scope, name);
  d.kind := declType;
  d.typ := t;
END AddTypeDecl;

PROCEDURE InitGlobalScope*(VAR l :Lex.Lexer);
VAR
  t :Type;
BEGIN
  scope := NIL;
  fwds := NIL;
  NewType(t, typeNil);
  AddTypeDecl(l, Lex.Intern(l, "NIL"), t);
  NewType(t, typeInteger);
  AddTypeDecl(l, Lex.Intern(l, "INTEGER"), t);
  AddTypeDecl(l, Lex.Intern(l, "BYTE"), t);
  NewType(t, typeReal);
  AddTypeDecl(l, Lex.Intern(l, "REAL"), t);
  NewType(t, typeBoolean);
  AddTypeDecl(l, Lex.Intern(l, "BOOLEAN"), t);
  NewType(t, typeChar);
  AddTypeDecl(l, Lex.Intern(l, "CHAR"), t);
  NewType(t, typeSet);
  AddTypeDecl(l, Lex.Intern(l, "SET"), t);
END InitGlobalScope;

PROCEDURE ResolveForwards*(l :Lex.Lexer);
VAR
  d :Decl;
BEGIN
  WHILE fwds # NIL DO
    ASSERT(fwds.t.kind = typePointer);
    d := LookupDecl(l, fwds.t.fields.name);
    IF (d # NIL) & (d.kind = declType) & (d.typ.kind = typeRecord) THEN
      fwds.t.base := d.typ;
      fwds.t.fields := NIL;
    ELSE
      Lex.Error(l, "Bad forward declaration ");
      Lex.OutStr(l, fwds.t.fields.name);
      Out.Ln;
    END;
    fwds := fwds.next;
  END;
END ResolveForwards;

PROCEDURE AddFormalParamsToScope*(l :Lex.Lexer; procDecl :Decl);
VAR
  formal, actual :Decl;
BEGIN
  ASSERT(procDecl.kind = declProcedure);
  ASSERT(procDecl.typ.kind = typeProcedure);
  formal := procDecl.typ.fields;
  WHILE formal # NIL DO
    actual := AddScopeDecl(l, formal.name);
    actual.kind := formal.kind;
    actual.typ := formal.typ;
    formal := formal.next;
  END;
END AddFormalParamsToScope;

PROCEDURE OpenScope*() :Decl;
VAR
  d, oldScope :Decl;
BEGIN
  NEW(d);
  d.kind := declEND;
  d.name := 0;
  d.next := scope;
  oldScope := scope;
  scope := d;
  RETURN oldScope
END OpenScope;

PROCEDURE CloseScope*(s :Decl);
BEGIN
  scope := s;
END CloseScope;

PROCEDURE TestAST;
VAR
  l :Lex.Lexer;
  d :Decl;
  t :Type;
BEGIN
  Lex.LexerInitFromString(l, "");
  d := NIL;
  AddDecl(l, d, 10);
  AddDecl(l, d, 20);
  AddDecl(l, d, 30);
  AddDecl(l, d, 40);
  (* Expected error cases *)
  Out.Mute;
  AddDecl(l, d, 10);
  AddDecl(l, d, 20);
  AddDecl(l, d, 30);
  AddDecl(l, d, 40);
  scope := d;
  ASSERT(LookupDecl(l, 20) # NIL);
  ASSERT(LookupDecl(l, 100) = NIL);
  Out.Unmute;
  InitGlobalScope(l);
  ASSERT(LookupDecl(l, Lex.Intern(l, "NIL")) # NIL);
  d := LookupDecl(l, Lex.Intern(l, "NIL"));
  ASSERT(d.kind = declType);
  ASSERT(d.typ.kind = typeNil);
  d := LookupDecl(l, Lex.Intern(l, "INTEGER"));
  ASSERT(d.kind = declType);
  t := d.typ;
  d := LookupDecl(l, Lex.Intern(l, "BYTE"));
  ASSERT(t = d.typ);
  Out.PrintLn("PASS: AST test");
END TestAST;

BEGIN
  TestAST
END AST.

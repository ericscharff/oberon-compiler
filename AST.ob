MODULE AST;

IMPORT Lex, Out;

CONST
  typeNil       = 1;
  typeInteger   = 2;
  typeReal      = 3;
  typeBoolean   = 4;
  typeChar      = 5;
  typeSet       = 6;
  typeString    = 7;
  typePointer   = 8;
  typeArray     = 9;
  typeRecord    = 10;
  typeProcedure = 11;
  typeImport    = 12;

  declImport*    = 1;
  declConst      = 2;
  declType*      = 3;
  declVar*       = 4;
  declProcedure* = 5;
  declParam*     = 6;
  declVarParam*  = 7;
  declField*     = 8;
  declEND = 1001;

  exprVal*         = 1; (* CONST value *)
  exprUnary*       = 2;
  exprBinary*      = 3;
  expridentRef     = 4;
  exprProcCall     = 5;
  exprFieldRef     = 6;
  exprPointerDeref = 7;
  exprArrayRef     = 8;
  exprTypeguard    = 9;

TYPE
  StringId  = Lex.PoolIndex;
  TypeKind  = INTEGER;
  Type*     = POINTER TO TypeDesc;
  Decl*     = POINTER TO DeclDesc;
  TypeDesc  = RECORD
    kind    :TypeKind;
    base*   :Type; (* POINTER type, ARRAY element, RECORD base, PROCEDURE return type *)
    fields* :Decl; (* RECORD fields / PROCEDURE formal parameters / IMPORT decls / name of forward decl *)
  END;
  DeclKind  = INTEGER;
  DeclDesc  = RECORD
    kind*     :DeclKind;
    next*     :Decl;
    name*     :StringId;
    typ*      :Type;
    exported* :BOOLEAN;
  END;
  Forward   = POINTER TO FwdDecl;
  FwdDecl   = RECORD
    t    :Type;
    next :Forward;
  END;
  Expr*     = POINTER TO ExprDesc;
  ExprKind  = INTEGER;
  (*
  A call to a PROCEDURE, e.g., MyProc(arg1, Proc2(a, b), arr[i], 4) looks like
  Expr:
    kind  --> exprProcCall
    lhs   --> Expr:
                kind --> exprIdentDef
                decl --> Decl FOR MyProc
    rhs   --> Expr:
                kind --> exprIdentDef
                decl --> Decl FOR arg1
                next --> Expr:
                           kind --> exprProcCall
                           lhs  --> Expr:
                                      kind --> exprIdentRef
                                      decl --> decl for Proc2
                           rhs  --> Expr:
                                      kind --> exprIdentRef
                                      decl --> decl for a
                                      next --> Expr:
                                                 kind -> exprIdentRef
                                                 decl -> decl for b
                                                 next -> NIL
                           next --> Expr:
                                      kind --> exprArrayRef
                                      lhs -> Expr (identRef FOR arr)
                                      rhs -> Expr (identRef FOR i)
                                      next -> Expr:
                                                kind --> exprVal
                                                iVal --> 4
                                                typ  --> typeInteger
                                                next --> NIL
  In other words, a proc call's lhs is the PROCEDURE's definition,
  the rhs is the first arg, and then follows the next chain OF those args.
  *)
  ExprDesc  = RECORD
    kind  :ExprKind;
    typ   :Type;
    op    :Lex.TokenKind; (* for unary, binary                            *)
    lhs   :Expr;          (* for unary, binary, the base expr for         *)
                          (* arrayRef, pointerDeref, fieldRef, typeGuard, *)
                          (* PROCEDURE call designator                    *)
    rhs   :Expr;          (* for binary, also first arg PROCEDURE call    *)
                          (* for arrayRef, expr OF ARRAY index            *)
    next  :Expr;          (* for PROCEDURE call,next arg in list          *)
    decl  :Decl;          (* for identRef and typeguard                   *)
    iVal  :INTEGER;       (* for INTEGER, SET, BOOLEAN, STRING (StringId) *)
                          (* for fieldref, StringId OF field name         *)
    rVal  :REAL;
  END;

VAR
  scope, globalScope :Decl;
  fwds  :Forward;

PROCEDURE LookupDecl0(name :StringId) :Decl;
VAR
  p :Decl;
BEGIN
  p := scope;
  WHILE (p # NIL) & (p.name # name) DO
    p := p.next;
  END;
  RETURN p
END LookupDecl0;

PROCEDURE LookupDecl*(l :Lex.Lexer; name :StringId) :Decl;
VAR
  p :Decl;
BEGIN
  p := LookupDecl0(name);
  IF p = NIL THEN
    Lex.Error(l, "");
    Lex.OutStr(l, name);
    Out.PrintLn(" undefined");
  END;
  RETURN p
END LookupDecl;

PROCEDURE LookupImport*(l :Lex.Lexer; moduleName, name :StringId) :Decl;
VAR
  p, d :Decl;
BEGIN
  d := LookupDecl(l, moduleName);
  ASSERT(d.kind = declImport);
  p := d.typ.fields;
  WHILE (p # NIL) & (p.name # name) DO
    p := p.next;
  END;
  IF p = NIL THEN
    Lex.Error(l, "");
    Lex.OutStr(l, moduleName);
    Out.Str(".");
    Lex.OutStr(l, name);
    Out.PrintLn(" undefined");
  ELSIF ~p.exported THEN
    Lex.Error(l, "");
    Lex.OutStr(l, moduleName);
    Out.Str(".");
    Lex.OutStr(l, name);
    Out.PrintLn(" is not exported");
  END;
  RETURN p
END LookupImport;

PROCEDURE AddDecl*(l :Lex.Lexer; VAR chain :Decl; name :StringId) :Decl;
VAR
  p, d :Decl;
BEGIN
  NEW(d);
  d.name := name;
  d.kind := 0;
  d.typ := NIL;
  d.next := NIL;
  d.exported := FALSE;
  IF chain = NIL THEN NEW(chain);
    chain.kind := declEND;
    chain.name := 0;
    chain.next := NIL;
  END;
  IF chain.kind = declEND THEN
    d.next := chain;
    chain := d;
  ELSE
    p := chain;
    WHILE (p.next.kind # declEND) & (p.name # name) DO
      p := p.next;
    END;
    IF p.name = name THEN
      Lex.Error(l, "");
      Lex.OutStr(l, name);
      Out.PrintLn(" already defined");
    ELSE
      d.next := p.next;
      p.next := d;
    END;
  END;
  RETURN d
END AddDecl;

PROCEDURE AddScopeDecl*(l :Lex.Lexer; name :StringId) :Decl;
BEGIN
  RETURN AddDecl(l, scope, name)
END AddScopeDecl;

PROCEDURE NewType(VAR t :Type; kind :TypeKind);
BEGIN
  NEW(t);
  t.kind := kind;
  t.base := NIL;
  t.fields := NIL;
END NewType;

PROCEDURE AddImportDecl*(l :Lex.Lexer; name :StringId; decls :Decl);
VAR
  d :Decl;
BEGIN
  d := AddScopeDecl(l, name);
  d.kind := declImport;
  NewType(d.typ, typeImport);
  d.typ.fields := decls;
END AddImportDecl;

PROCEDURE NewArrayType*(base :Type) :Type;
VAR
  t :Type;
BEGIN
  NewType(t, typeArray);
  t.base := base;
  RETURN t
END NewArrayType;

PROCEDURE NewPointerType*(l :Lex.Lexer; base :Type) :Type;
VAR
  t :Type;
BEGIN
  t := NIL;
  IF (base # NIL) & (base.kind # typeRecord) THEN
    Lex.ErrorLn(l, "Pointer base type must be a RECORD");
  ELSE
    NewType(t, typePointer);
    t.base := base;
  END;
  RETURN t
END NewPointerType;

PROCEDURE NewPointerTypeByName*(l :Lex.Lexer; name :StringId) :Type;
VAR
  d :Decl;
  f :Forward;
  t :Type;
BEGIN
  t := NIL;
  d := LookupDecl0(name);
  IF d = NIL THEN
    (* forward decl *)
    NewType(t, typePointer);
    NEW(t.fields);
    t.fields.name := name;
    t.fields.next := NIL;
    NEW(f);
    f.t := t;
    f.next := fwds;
    fwds := f;
  ELSE
    IF d.kind # declType THEN
      Lex.Error(l, "");
      Lex.OutStr(l, d.name);
      Out.PrintLn(" is not a TYPE");
    END;
    t := NewPointerType(l, d.typ);
  END;
  RETURN t
END NewPointerTypeByName;

PROCEDURE NewProcedureType*() :Type;
VAR
  t :Type;
BEGIN
  NewType(t, typeProcedure);
  RETURN t
END NewProcedureType;

PROCEDURE NewRecordType*(l :Lex.Lexer; base :Type) :Type;
VAR
  t        :Type;
  d, dCopy :Decl;
BEGIN
  NewType(t, typeRecord);
  t.base := base;
  IF base # NIL THEN
    IF base.kind = typeRecord THEN
      (* Copy fields from base *)
      d := base.fields;
      WHILE (d # NIL) & (d.kind # declEND) DO
        dCopy := AddDecl(l, t.fields, d.name);
	dCopy.kind := d.kind;
	dCopy.typ := d.typ;
	dCopy.exported := d.exported;
	d := d.next;
      END;
    ELSE
      Lex.ErrorLn(l, "RECORD base type is not a RECORD");
    END;
  END;
  RETURN t
END NewRecordType;

PROCEDURE AddTypeDecl(VAR l :Lex.Lexer; name :StringId; t :Type);
VAR
  d :Decl;
BEGIN
  d := AddDecl(l, scope, name);
  d.kind := declType;
  d.typ := t;
END AddTypeDecl;

PROCEDURE InitGlobalScope*(VAR l :Lex.Lexer);
VAR
  t :Type;
BEGIN
  fwds := NIL;
  IF globalScope = NIL THEN
    scope := NIL;
    NewType(t, typeNil);
    AddTypeDecl(l, Lex.Intern(l, "NIL"), t);
    NewType(t, typeInteger);
    AddTypeDecl(l, Lex.Intern(l, "INTEGER"), t);
    AddTypeDecl(l, Lex.Intern(l, "BYTE"), t);
    NewType(t, typeReal);
    AddTypeDecl(l, Lex.Intern(l, "REAL"), t);
    NewType(t, typeBoolean);
    AddTypeDecl(l, Lex.Intern(l, "BOOLEAN"), t);
    NewType(t, typeChar);
    AddTypeDecl(l, Lex.Intern(l, "CHAR"), t);
    NewType(t, typeSet);
    AddTypeDecl(l, Lex.Intern(l, "SET"), t);
    (* stuff to fix *)
    AddTypeDecl(l, Lex.Intern(l, "INC"), t);
    AddTypeDecl(l, Lex.Intern(l, "DEC"), t);
    AddTypeDecl(l, Lex.Intern(l, "ASSERT"), t);
    AddTypeDecl(l, Lex.Intern(l, "ORD"), t);
    AddTypeDecl(l, Lex.Intern(l, "CHR"), t);
    AddTypeDecl(l, Lex.Intern(l, "FLT"), t);
    AddTypeDecl(l, Lex.Intern(l, "ABS"), t);
    AddTypeDecl(l, Lex.Intern(l, "NEW"), t);
    globalScope := scope;
  END;
  scope := globalScope;
END InitGlobalScope;

PROCEDURE ResolveForwards*(l :Lex.Lexer);
VAR
  d :Decl;
BEGIN
  WHILE fwds # NIL DO
    ASSERT(fwds.t.kind = typePointer);
    d := LookupDecl(l, fwds.t.fields.name);
    IF (d # NIL) & (d.kind = declType) & (d.typ.kind = typeRecord) THEN
      fwds.t.base := d.typ;
      fwds.t.fields := NIL;
    ELSE
      Lex.Error(l, "Bad forward declaration ");
      Lex.OutStr(l, fwds.t.fields.name);
      Out.Ln;
    END;
    fwds := fwds.next;
  END;
END ResolveForwards;

PROCEDURE AddFormalParamsToScope*(l :Lex.Lexer; procDecl :Decl);
VAR
  formal, actual :Decl;
BEGIN
  ASSERT(procDecl.kind = declProcedure);
  ASSERT(procDecl.typ.kind = typeProcedure);
  formal := procDecl.typ.fields;
  WHILE formal # NIL DO
    actual := AddScopeDecl(l, formal.name);
    actual.kind := formal.kind;
    actual.typ := formal.typ;
    formal := formal.next;
  END;
END AddFormalParamsToScope;

PROCEDURE CurrentScope*(): Decl;
BEGIN
  RETURN scope
END CurrentScope;

PROCEDURE OpenScope*() :Decl;
VAR
  d, oldScope :Decl;
BEGIN
  NEW(d);
  d.kind := declEND;
  d.name := 0;
  d.next := scope;
  oldScope := scope;
  scope := d;
  RETURN oldScope
END OpenScope;

PROCEDURE CloseScope*(s :Decl);
BEGIN
  scope := s;
END CloseScope;

PROCEDURE TestCleanup*;
BEGIN
  scope := NIL;
  globalScope := NIL;
END TestCleanup;

PROCEDURE TestAST;
VAR
  l :Lex.Lexer;
  d :Decl;
  t :Type;
BEGIN
  Lex.LexerInitFromString(l, "");
  d := NIL;
  AddDecl(l, d, 10);
  AddDecl(l, d, 20);
  AddDecl(l, d, 30);
  AddDecl(l, d, 40);
  (* Expected error cases *)
  Out.Mute;
  AddDecl(l, d, 10);
  AddDecl(l, d, 20);
  AddDecl(l, d, 30);
  AddDecl(l, d, 40);
  scope := d;
  ASSERT(LookupDecl(l, 20) # NIL);
  ASSERT(LookupDecl(l, 100) = NIL);
  Out.Unmute;
  InitGlobalScope(l);
  ASSERT(LookupDecl(l, Lex.Intern(l, "NIL")) # NIL);
  d := LookupDecl(l, Lex.Intern(l, "NIL"));
  ASSERT(d.kind = declType);
  ASSERT(d.typ.kind = typeNil);
  d := LookupDecl(l, Lex.Intern(l, "INTEGER"));
  ASSERT(d.kind = declType);
  t := d.typ;
  d := LookupDecl(l, Lex.Intern(l, "BYTE"));
  ASSERT(t = d.typ);
  TestCleanup;
  Out.PrintLn("PASS: AST test");
END TestAST;

BEGIN
  globalScope := NIL;
  TestAST
END AST.
